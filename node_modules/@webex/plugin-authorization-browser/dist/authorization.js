"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _applyDecoratedDescriptor2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/applyDecoratedDescriptor"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _apply = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/apply"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/assign"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _deleteProperty = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/delete-property"));

var _parseInt2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/parse-int"));

var _getOwnPropertyDescriptor = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor"));

var _omit2 = _interopRequireDefault(require("lodash/omit"));

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _cloneDeep2 = _interopRequireDefault(require("lodash/cloneDeep"));

var _querystring = _interopRequireDefault(require("querystring"));

var _url = _interopRequireDefault(require("url"));

var _common = require("@webex/common");

var _webexCore = require("@webex/webex-core");

var _uuid = _interopRequireDefault(require("uuid"));

var _dec, _dec2, _obj;

var OAUTH2_CSRF_TOKEN = 'oauth2-csrf-token';

var EMPTY_OBJECT_STRING = _common.base64.encode((0, _stringify.default)({}));
/**
 * Browser support for OAuth2. Automatically parses the URL hash for an access
 * token
 * @class
 * @name AuthorizationBrowser
 */


var Authorization = _webexCore.WebexPlugin.extend((_dec = (0, _common.whileInFlight)('isAuthorizing'), _dec2 = (0, _common.whileInFlight)('isAuthorizing'), (_obj = {
  derived: {
    /**
     * Alias of {@link AuthorizationBrowser#isAuthorizing}
     * @instance
     * @memberof AuthorizationBrowser
     * @type {boolean}
     */
    isAuthenticating: {
      deps: ['isAuthorizing'],
      fn: function fn() {
        return this.isAuthorizing;
      }
    }
  },
  session: {
    /**
     * Indicates if an Authorization Code exchange is inflight
     * @instance
     * @memberof AuthorizationBrowser
     * @type {boolean}
     */
    isAuthorizing: {
      default: false,
      type: 'boolean'
    },
    ready: {
      default: false,
      type: 'boolean'
    }
  },
  namespace: 'Credentials',

  /**
   * Initializer
   * @instance
   * @memberof AuthorizationBrowser
   * @param {Object} attrs {@link AmpersandState}
   * @param {boolean} attrs.parse Controls whether or not the the url should get
   * parsed for an access token
   * @private
   * @returns {Authorization}
   */
  // eslint-disable-next-line complexity
  initialize: function initialize(attrs, options) {
    var _this = this;

    var ret = (0, _apply.default)(_webexCore.WebexPlugin.prototype.initialize, this, [attrs, options]); // Reminder, we can't do parse based on config, because config is not
    // available until nextTick and we want to be able to throw errors found in
    // the url.

    if (attrs.parse === false) {
      this.ready = true;
      return ret;
    }

    var location = _url.default.parse(this.webex.getWindow().location.href, true);

    this._checkForErrors(location);

    var hash = location.hash;

    if (!hash) {
      this.ready = true;
      return ret;
    }

    if (hash.includes('#')) {
      hash = hash.substr(1);
    }

    location.hash = _querystring.default.parse(hash);

    if (location.hash.state) {
      location.hash.state = JSON.parse(_common.base64.decode(location.hash.state));
    }

    var tokenData = this._parseHash(location);

    if (!tokenData) {
      return ret;
    }

    this._cleanUrl(location); // Wait until nextTick in case `credentials` hasn't initialized yet


    process.nextTick(function () {
      _this.webex.credentials.set({
        supertoken: tokenData
      });

      _this.ready = true;
    });
    return ret;
  },

  /**
   * Kicks off an oauth flow
   * @instance
   * @memberof AuthorizationBrowser
   * @param {Object} options
   * @returns {Promise}
   */
  initiateLogin: function initiateLogin() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    options.state = options.state || {};
    options.state.csrf_token = this._generateSecurityToken(); // If we're not explicitly a confidential client, assume we're a public
    // client

    if (this.config.clientType === 'confidential') {
      return this.initiateAuthorizationCodeGrant(options);
    }

    return this.initiateImplicitGrant(options);
  },

  /**
   * Kicks off the Authorization Code grant flow. Typically called via
   * {@link AuthorizationBrowser#initiateLogin}
   * @instance
   * @memberof AuthorizationBrowser
   * @param {Object} options
   * @returns {Promise}
   */
  initiateImplicitGrant: function initiateImplicitGrant(options) {
    this.logger.info('authorization: initiating implicit grant flow');
    this.webex.getWindow().location = this.webex.credentials.buildLoginUrl((0, _assign.default)({
      response_type: 'token'
    }, options));
    return _promise.default.resolve();
  },

  /**
   * Kicks off the Implicit Code grant flow. Typically called via
   * {@link AuthorizationBrowser#initiateLogin}
   * @instance
   * @memberof AuthorizationBrowser
   * @param {Object} options
   * @returns {Promise}
   */
  initiateAuthorizationCodeGrant: function initiateAuthorizationCodeGrant(options) {
    this.logger.info('authorization: initiating authorization code grant flow');
    this.webex.getWindow().location = this.webex.credentials.buildLoginUrl((0, _assign.default)({
      response_type: 'code'
    }, options));
    return _promise.default.resolve();
  },

  /**
   * Requests a Webex access token for a user already authenticated into
   * your product.
   *
   * Note: You'll need to supply a jwtRefreshCallback of the form
   * `Promise<jwt> = jwtRefreshCallback(webex)` for automatic token refresh to
   * work.
   *
   * @instance
   * @memberof AuthorizationBrowser
   * @param {Object} options
   * @param {Object} options.jwt This is a jwt generated by your backend that
   * identifies a user in your system
   * @returns {Promise}
   */
  requestAccessTokenFromJwt: function requestAccessTokenFromJwt(_ref) {
    var _this2 = this;

    var jwt = _ref.jwt;
    var hydraUri = this.webex.internal.services.get('hydra', true);

    if (hydraUri && hydraUri.slice(-1) !== '/') {
      // add a `/` to hydra's uri from the services catalog so that
      // it matches the current env service format.
      hydraUri += '/';
    }

    hydraUri = hydraUri || process.env.HYDRA_SERVICE_URL || 'https://api.ciscospark.com/v1/';
    return this.webex.request({
      method: 'POST',
      uri: "".concat(hydraUri, "jwt/login"),
      headers: {
        authorization: jwt
      }
    }).then(function (_ref2) {
      var body = _ref2.body;
      return {
        access_token: body.token,
        token_type: 'Bearer',
        expires_in: body.expiresIn
      };
    }).then(function (token) {
      _this2.webex.credentials.set({
        supertoken: token
      });
    }).then(function () {
      return _this2.webex.internal.services.initServiceCatalogs();
    });
  },

  /**
   * Called by {@link WebexCore#logout()}. Redirects to the logout page
   * @instance
   * @memberof AuthorizationBrowser
   * @param {Object} options
   * @param {boolean} options.noRedirect if true, does not redirect
   * @returns {Promise}
   */
  logout: function logout() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (!options.noRedirect) {
      this.webex.getWindow().location = this.webex.credentials.buildLogoutUrl(options);
    }
  },

  /**
   * Checks if the result of the login redirect contains an error string
   * @instance
   * @memberof AuthorizationBrowser
   * @param {Object} location
   * @private
   * @returns {Promise}
   */
  _checkForErrors: function _checkForErrors(location) {
    var query = location.query;

    if (query && query.error) {
      var ErrorConstructor = _webexCore.grantErrors.select(query.error);

      throw new ErrorConstructor(query);
    }
  },

  /**
   * Removes no-longer needed values from the url (access token, csrf token, etc)
   * @instance
   * @memberof AuthorizationBrowser
   * @param {Object} location
   * @private
   * @returns {Promise}
   */
  _cleanUrl: function _cleanUrl(location) {
    location = (0, _cloneDeep2.default)(location);

    if (this.webex.getWindow().history && this.webex.getWindow().history.replaceState) {
      ['access_token', 'token_type', 'expires_in', 'refresh_token', 'refresh_token_expires_in'].forEach(function (key) {
        return (0, _deleteProperty.default)(location.hash, key);
      });

      if (!(0, _isEmpty2.default)(location.hash.state)) {
        location.hash.state = _common.base64.encode((0, _stringify.default)((0, _omit2.default)(location.hash.state, 'csrf_token')));

        if (location.hash.state === EMPTY_OBJECT_STRING) {
          (0, _deleteProperty.default)(location.hash, 'state');
        }
      } else {
        (0, _deleteProperty.default)(location.hash, 'state');
      }

      location.hash = _querystring.default.stringify(location.hash);
      this.webex.getWindow().history.replaceState({}, null, _url.default.format(location));
    }
  },

  /**
   * Generates a CSRF token and sticks in in sessionStorage
   * @instance
   * @memberof AuthorizationBrowser
   * @private
   * @returns {Promise}
   */
  _generateSecurityToken: function _generateSecurityToken() {
    this.logger.info('authorization: generating csrf token');

    var token = _uuid.default.v4();

    this.webex.getWindow().sessionStorage.setItem('oauth2-csrf-token', token);
    return token;
  },

  /**
   * Parses the url hash into an access token object
   * @instance
   * @memberof AuthorizationBrowser
   * @param {Object} location
   * @private
   * @returns {Object}
   */
  _parseHash: function _parseHash(location) {
    var hash = (0, _cloneDeep2.default)(location.hash);

    if (hash) {
      this._verifySecurityToken(hash);
    }

    if (!hash.access_token) {
      this.ready = true;
      return undefined;
    }

    if (hash.expires_in) {
      hash.expires_in = (0, _parseInt2.default)(hash.expires_in, 10);
    }

    if (hash.refresh_token_expires_in) {
      hash.refresh_token_expires_in = (0, _parseInt2.default)(hash.refresh_token_expires_in, 10);
    }

    return hash;
  },

  /**
   * Checks if the CSRF token in sessionStorage is the same as the one returned
   * in the url.
   * @instance
   * @memberof AuthorizationBrowser
   * @param {Object} hash
   * @private
   * @returns {Promise}
   */
  _verifySecurityToken: function _verifySecurityToken(hash) {
    var sessionToken = this.webex.getWindow().sessionStorage.getItem(OAUTH2_CSRF_TOKEN);
    this.webex.getWindow().sessionStorage.removeItem(OAUTH2_CSRF_TOKEN);

    if (!sessionToken) {
      return;
    }

    if (!hash.state) {
      throw new Error("Expected CSRF token ".concat(sessionToken, ", but not found in redirect hash"));
    }

    if (!hash.state.csrf_token) {
      throw new Error("Expected CSRF token ".concat(sessionToken, ", but not found in redirect hash"));
    }

    var token = hash.state.csrf_token;

    if (token !== sessionToken) {
      throw new Error("CSRF token ".concat(token, " does not match stored token ").concat(sessionToken));
    }
  },
  version: "1.125.6"
}, ((0, _applyDecoratedDescriptor2.default)(_obj, "initiateImplicitGrant", [_dec], (0, _getOwnPropertyDescriptor.default)(_obj, "initiateImplicitGrant"), _obj), (0, _applyDecoratedDescriptor2.default)(_obj, "initiateAuthorizationCodeGrant", [_dec2], (0, _getOwnPropertyDescriptor.default)(_obj, "initiateAuthorizationCodeGrant"), _obj), (0, _applyDecoratedDescriptor2.default)(_obj, "requestAccessTokenFromJwt", [_common.oneFlight], (0, _getOwnPropertyDescriptor.default)(_obj, "requestAccessTokenFromJwt"), _obj)), _obj)));

var _default = Authorization;
exports.default = _default;
//# sourceMappingURL=authorization.js.map
