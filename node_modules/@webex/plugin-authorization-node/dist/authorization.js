"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _getOwnPropertyDescriptor = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor"));

var _applyDecoratedDescriptor2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/applyDecoratedDescriptor"));

var _common = require("@webex/common");

var _webexCore = require("@webex/webex-core");

var _dec, _obj;

/**
 * NodeJS support for OAuth2
 * @class
 * @name AuthorizationNode
 */
var Authorization = _webexCore.WebexPlugin.extend((_dec = (0, _common.whileInFlight)('isAuthorizing'), (_obj = {
  derived: {
    /**
     * Alias of {@link AuthorizationNode#isAuthorizing}
     * @instance
     * @memberof AuthorizationNode
     * @type {boolean}
     */
    isAuthenticating: {
      deps: ['isAuthorizing'],
      fn: function fn() {
        return this.isAuthorizing;
      }
    }
  },
  session: {
    /**
     * Indicates if an Authorization Code exchange is inflight
     * @instance
     * @memberof AuthorizationNode
     * @type {boolean}
     */
    isAuthorizing: {
      default: false,
      type: 'boolean'
    }
  },
  namespace: 'Credentials',
  logout: function logout() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.webex.request({
      method: 'POST',
      uri: this.config.logoutUrl,
      body: {
        token: options.token,
        cisService: this.config.service
      }
    });
  },

  /**
   * Exchanges an authorization code for an access token
   * @instance
   * @memberof AuthorizationNode
   * @param {Object} options
   * @param {Object} options.code
   * @returns {Promise}
   */
  requestAuthorizationCodeGrant: function requestAuthorizationCodeGrant() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.logger.info('credentials: requesting authorization code grant');

    if (!options.code) {
      return _promise.default.reject(new Error('`options.code` is required'));
    }

    return this.webex.request({
      method: 'POST',
      uri: this.config.tokenUrl,
      form: {
        grant_type: 'authorization_code',
        redirect_uri: this.config.redirect_uri,
        code: options.code,
        self_contained_token: true
      },
      auth: {
        user: this.config.client_id,
        pass: this.config.client_secret,
        sendImmediately: true
      },
      shouldRefreshAccessToken: false
    }).then(function (res) {
      _this.webex.credentials.set({
        supertoken: res.body
      });
    }).catch(function (res) {
      if (res.statusCode !== 400) {
        return _promise.default.reject(res);
      }

      var ErrorConstructor = _webexCore.grantErrors.select(res.body.error);

      return _promise.default.reject(new ErrorConstructor(res._res || res));
    });
  },

  /**
   * Requests a Webex access token for a user already authenticated into
   * your product.
   *
   * Note: You'll need to supply a jwtRefreshCallback of the form
   * `Promise<jwt> = jwtRefreshCallback(webex)` for automatic token refresh to
   * work.
   *
   * @instance
   * @memberof AuthorizationNode
   * @param {Object} options
   * @param {Object} options.jwt This is a jwt generated by your backend that
   * identifies a user in your system
   * @returns {Promise}
   */
  requestAccessTokenFromJwt: function requestAccessTokenFromJwt(_ref) {
    var _this2 = this;

    var jwt = _ref.jwt;
    var hydraUri = this.webex.internal.services.get('hydra', true);

    if (hydraUri && hydraUri.slice(-1) !== '/') {
      // add a `/` to hydra's uri from the services catalog so that
      // it matches the current env service format.
      hydraUri += '/';
    }

    hydraUri = hydraUri || process.env.HYDRA_SERVICE_URL || 'https://api.ciscospark.com/v1/';
    return this.webex.request({
      method: 'POST',
      uri: "".concat(hydraUri, "jwt/login"),
      headers: {
        authorization: jwt
      }
    }).then(function (_ref2) {
      var body = _ref2.body;
      return {
        access_token: body.token,
        token_type: 'Bearer',
        expires_in: body.expiresIn
      };
    }).then(function (token) {
      _this2.webex.credentials.set({
        supertoken: token
      });
    }).then(function () {
      return _this2.webex.internal.services.initServiceCatalogs();
    });
  },
  version: "1.125.6"
}, ((0, _applyDecoratedDescriptor2.default)(_obj, "requestAuthorizationCodeGrant", [_dec, _common.oneFlight], (0, _getOwnPropertyDescriptor.default)(_obj, "requestAuthorizationCodeGrant"), _obj), (0, _applyDecoratedDescriptor2.default)(_obj, "requestAccessTokenFromJwt", [_common.oneFlight], (0, _getOwnPropertyDescriptor.default)(_obj, "requestAccessTokenFromJwt"), _obj)), _obj)));

var _default = Authorization;
exports.default = _default;
//# sourceMappingURL=authorization.js.map
