{"version":3,"sources":["user.js"],"names":["User","WebexPlugin","extend","keyFactory","email","options","String","create","namespace","children","batcher","UserUUIDBatcher","props","hasPassword","default","type","session","store","UserUUIDStore","activate","verificationToken","confirmationCode","id","reject","Error","scope","webex","config","credentials","activateOptions","request","uri","activationUrl","method","body","auth","user","client_id","pass","client_secret","sendImmediately","then","res","set","supertoken","tokenData","asUUID","all","map","u","_extractUUID","force","patterns","uuid","test","resolve","_extractEmailAddress","getUUID","fetchUUID","recordUUID","emailAddress","get","service","resource","getByEmail","userExists","catch","initialize","args","prototype","add","register","verify","setPassword","password","getUserToken","token","setPasswordUrl","internal","device","userId","headers","authorization","toString","schemas","update","displayName","verifyDefaults","services","collectPreauthCatalog","getClientToken","preloginId","shouldRefreshAccessToken","sso","getUserCI","lookupCI","verifyOptions","suppressEmail","userEntities","idBrokerUrl","idbroker","url","identityUrl","identity","entryUUID","entryEmail"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {isArray} from 'lodash';\nimport {deprecated, oneFlight, patterns, tap} from '@webex/common';\nimport {persist, WebexPlugin, waitForValue} from '@webex/webex-core';\n\nimport UserUUIDBatcher from './user-uuid-batcher';\nimport UserUUIDStore from './user-uuid-store';\n\n/**\n * @class\n */\nconst User = WebexPlugin.extend({\n  namespace: 'User',\n\n  children: {\n    batcher: UserUUIDBatcher\n  },\n\n  props: {\n    /**\n     * Indicates if the current user is known to have a password.\n     * @instance\n     * @memberof User\n     * @type {boolean}\n     */\n    hasPassword: {\n      default: false,\n      type: 'boolean'\n    }\n  },\n\n  session: {\n    store: {\n      default() {\n        return new UserUUIDStore();\n      },\n      type: 'any'\n    }\n  },\n\n  @waitForValue('@')\n  /**\n   * Activates a Webex user account and exchanges for user token.\n   * @instance\n   * @memberof User\n   * @param {Object} options\n   * @param {Object} options.confirmationCode (required -- optional if verification token is provided)\n   * @param {Object} options.id (required -- optional if verification token is provided)\n   * @param {Object} options.verificationToken (required -- optional if uuid and verification token provided)\n   * @param {Object} options.email (required with verificationToken for Federation/global user)\n   * @returns {Promise} Resolves with a userSession\n   */\n  activate(options = {}) {\n    if (!(options.verificationToken || (options.confirmationCode && options.id))) {\n      return Promise.reject(new Error('either options.verificationToken is required or both options.confirmationCode and options.id are required'));\n    }\n\n    options.scope = this.webex.config.credentials.scope;\n\n    // if we have options.email and options.verificationToken\n    // and Federation flag is enabled, flag that we need to\n    // lookup user's CI.\n    const activateOptions = Object.assign({}, options);\n\n    delete activateOptions.email;\n\n    return this.request({\n      uri: this.webex.config.credentials.activationUrl,\n      method: 'POST',\n      body: activateOptions,\n      auth: {\n        user: this.webex.config.credentials.client_id,\n        pass: this.webex.config.credentials.client_secret,\n        sendImmediately: true\n      }\n    })\n      .then((res) => {\n        this.webex.credentials.set({supertoken: res.body.tokenData});\n\n        return res.body;\n      });\n  },\n\n  /**\n   * Converts a user-identifying object to a uuid, perhaps by doing a network\n   * lookup\n   * @param {string|Object} user\n   * @param {Object} options\n   * @param {boolean} options.create if true, ensures the return UUID refers to\n   * an existing user (rather than creating one deterministically based on email\n   * address), even if that user must be created\n   * @returns {Promise<string>}\n   */\n  asUUID(user, options) {\n    if (!user) {\n      return Promise.reject(new Error('`user` is required'));\n    }\n\n    if (isArray(user)) {\n      return Promise.all(user.map((u) => this.asUUID(u, options)));\n    }\n\n    const id = this._extractUUID(user);\n\n    if (!(options && options.force) && patterns.uuid.test(id)) {\n      return Promise.resolve(id);\n    }\n\n    const email = this._extractEmailAddress(user);\n\n    if (!patterns.email.test(email)) {\n      return Promise.reject(new Error('Provided user object does not appear to identify a user'));\n    }\n\n    return this.getUUID(email, options);\n  },\n\n  /**\n   * Requests a uuid from the api\n   * @param {string} email\n   * @param {Object} options\n   * @param {boolean} options.create\n   * @returns {Promise<string>}\n   */\n  fetchUUID(email, options) {\n    return this.batcher.request({\n      email,\n      create: options && options.create\n    })\n      .then((user) => this.recordUUID(Object.assign({emailAddress: email}, user))\n        .then(() => user.id));\n  },\n\n  /**\n   * Fetches details about the current user\n   * @returns {Promise<Object>}\n   */\n  get() {\n    return this.request({\n      service: 'conversation',\n      resource: 'users'\n    })\n      .then((res) => res.body)\n      .then(tap((user) => this.recordUUID({\n        id: user.id,\n        // CI endpoints don't use the same user format as actors, so, email may\n        // be in one of a few fields\n        emailAddress: user.email || user.emailAddress\n      })));\n  },\n\n  /**\n   * Converts an email address to a uuid, perhaps by doing a network lookup\n   * @param {string} email\n   * @param {Object} options\n   * @param {boolean} options.create\n   * @returns {Promise<string>}\n   */\n  @oneFlight({keyFactory: (email, options) => email + String(options && options.create)})\n  getUUID(email, options) {\n    return this.store.getByEmail(email)\n      .then((user) => {\n        if (options && options.create && !user.userExists) {\n          return Promise.reject(new Error('User for specified email cannot be confirmed to exist'));\n        }\n\n        if (!user.id) {\n          return Promise.reject(new Error('No id recorded for specified user'));\n        }\n\n        return user.id;\n      })\n      .catch(() => this.fetchUUID(email, options));\n  },\n\n  @persist('@')\n  initialize(...args) {\n    return Reflect.apply(WebexPlugin.prototype.initialize, this, args);\n  },\n\n  /**\n   * Caches the uuid for the specified email address\n   * @param {Object} user\n   * @param {string} user.id\n   * @param {string} user.emailAddress\n   * @returns {Promise}\n   */\n  recordUUID(user) {\n    if (!user) {\n      return Promise.reject(new Error('`user` is required'));\n    }\n\n    if (!user.id) {\n      return Promise.reject(new Error('`user.id` is required'));\n    }\n\n    if (!patterns.uuid.test(user.id)) {\n      return Promise.reject(new Error('`user.id` must be a uuid'));\n    }\n\n    if (!user.emailAddress) {\n      return Promise.reject(new Error('`user.emailAddress` is required'));\n    }\n\n    if (!patterns.email.test(user.emailAddress)) {\n      return Promise.reject(new Error('`user.emailAddress` must be an email address'));\n    }\n\n    return this.store.add(user);\n  },\n\n  @deprecated('Use User#verify()')\n  register(...args) {\n    return this.verify(...args);\n  },\n\n  /**\n   * Updates a user's password with webex.\n   * @instance\n   * @memberof User\n   * @param {Object} options\n   * @param {string} options.password (required)\n   * @param {string} options.email (required when federation enabled)\n   * @returns {Promise} Resolves with complete user object containing new password\n   */\n  setPassword(options) {\n    options = options || {};\n    if (!options.password) {\n      return Promise.reject(new Error('`options.password` is required'));\n    }\n\n    return this.webex.credentials.getUserToken()\n      .then((token) => this.request({\n        uri: `${this.webex.config.credentials.setPasswordUrl}/${this.webex.internal.device.userId}`,\n        method: 'PATCH',\n        headers: {\n          authorization: token.toString()\n        },\n        body: {\n          schemas: ['urn:scim:schemas:core:1.0', 'urn:scim:schemas:extension:cisco:commonidentity:1.0'],\n          password: options.password\n        }\n      }))\n      .then((res) => {\n        this.hasPassword = true;\n\n        return res.body;\n      });\n  },\n\n  /**\n   * Updates the current user's display name\n   * @param {Object} options\n   * @param {string} options.displayName\n   * @returns {Promise<Object>}\n   */\n  update(options) {\n    options = options || {};\n    if (!options.displayName) {\n      return Promise.reject(new Error('`options.displayName` is required'));\n    }\n\n    return this.request({\n      method: 'PATCH',\n      service: 'conversation',\n      resource: 'users/user',\n      body: options\n    })\n      .then((res) => res.body);\n  },\n\n  /**\n   * Determines if the specified user needs to signup or can signin.\n   * Triggers activation email if client credentials are used\n   * @param {Object} options\n   * @param {string} options.email (required)\n   * @param {string} options.reqId required if need to check email status\n   * @param {string} options.preloginId\n   * @returns {Promise<Object>}\n   */\n  verify(options) {\n    options = Object.assign({}, this.config.verifyDefaults, options);\n    const {email} = options;\n\n    if (!email) {\n      return Promise.reject(new Error('`options.email` is required'));\n    }\n\n    return this.webex.internal.services.collectPreauthCatalog({email})\n      .then(() => this.webex.credentials.getUserToken())\n      .catch(() => this.webex.credentials.getClientToken())\n      .then((token) => this.request({\n        service: 'atlas',\n        resource: 'users/activations',\n        method: 'POST',\n        headers: {\n          authorization: token.toString(),\n          'x-prelogin-userid': options.preloginId\n        },\n        body: options,\n        shouldRefreshAccessToken: false\n      }))\n      .then((res) => {\n        if (res.body.hasPassword || res.body.sso) {\n          this.hasPassword = true;\n        }\n\n        return res.body;\n      });\n  },\n\n\n  /**\n   * If the passed-in lookupCI is true, retrieve the user's\n   * CI from Atlas and return the URL's via a Promise.\n   * Otherwise, return current CI in config via a Promise.\n   * Useful in a Promise chain to retrieve the CI based on\n   * conditions like Federation enabled, and suppresses sending\n   * an additional email to the user, since this is just a\n   * look-up.\n   * @param {string} email (required)\n   * @param {boolean} lookupCI (required)\n   * @returns {Promise<Object>}\n   */\n  getUserCI(email, lookupCI) {\n    if (lookupCI) {\n      // call verify first to get the user's CI, but suppress sending another email\n      const verifyOptions = {\n        email,\n        suppressEmail: true\n      };\n\n      return this.verify(verifyOptions).then((res) => Promise.resolve(res.userEntities));\n    }\n\n    return Promise.resolve(\n      {\n        idBrokerUrl: this.webex.config.credentials.idbroker.url,\n        identityUrl: this.webex.config.credentials.identity.url\n      }\n    );\n  },\n\n  /**\n   * Extracts the uuid from a user identifying object\n   * @param {string|Object} user\n   * @private\n   * @returns {string}\n   */\n  _extractUUID(user) {\n    return user.entryUUID || user.id || user;\n  },\n\n  /**\n   * Extracts the email address from a user identifying object\n   * @param {string|Object} user\n   * @private\n   * @returns {string}\n   */\n  _extractEmailAddress(user) {\n    return user.email || user.emailAddress || user.entryEmail || user;\n  }\n\n});\n\nexport default User;\n"]}