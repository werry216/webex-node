"use strict";

var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");

var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _apply = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/apply"));

var _deleteProperty = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/delete-property"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _isArray2 = _interopRequireDefault(require("lodash/isArray"));

var _cloneDeep2 = _interopRequireDefault(require("lodash/cloneDeep"));

var _common = require("@webex/common");

var _webexCore = require("@webex/webex-core");

var _verbToType;

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

var verbToType = (_verbToType = {}, (0, _defineProperty2.default)(_verbToType, _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.SHARE, _common.SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED), (0, _defineProperty2.default)(_verbToType, _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.POST, _common.SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED), (0, _defineProperty2.default)(_verbToType, _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.DELETE, _common.SDK_EVENT.EXTERNAL.EVENT_TYPE.DELETED), _verbToType);

var getRoomType = function getRoomType(roomTags) {
  return roomTags.includes(_common.SDK_EVENT.INTERNAL.ACTIVITY_TAG.ONE_ON_ONE) ? _common.SDK_EVENT.EXTERNAL.SPACE_TYPE.DIRECT : _common.SDK_EVENT.EXTERNAL.SPACE_TYPE.GROUP;
};
/**
 * @typedef {Object} MessageObject
 * @property {string} id - (server generated) Unique identifier for the message
 * @property {string} personId - The ID for the author of the messasge
 * @property {email} personEmail - The email for the author of the messasge
 * @property {string} roomId - The ID for the room of the message
 * @property {string} text - The message posted to the room in plain text
 * @property {string} markdown - The message posted to the room in markdown
 * @property {Array<string>} files - The source URL(s) for the message attachment(s).
 * See the {@link https://developer.webex.com/docs/api/basics#message-attachments|Message Attachments}
 * Guide for a list of supported media types.
 * @property {isoDate} created - (server generated) The date and time that the message was created
 */

/**
 * Messages are how people communicate in rooms. Each message timestamped and
 * represented in Webex as a distinct block of content. Messages can contain
 * plain text and a single file attachment. See the
 * {@link https://developer.webex.com/docs/api/basics#message-attachments|Message Attachments} Guide
 * for a list of supported media types.
 * @class
 */


var Messages = _webexCore.WebexPlugin.extend({
  /**
   * Initializer used to generate Messages
   * as a plugin wrapped around the provided arguments.
   * @private
   * @see WebexPlugin.initialize
   * @param  {...any} args
   * @returns {undefined}
   */
  initialize: function initialize() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (0, _apply.default)(_webexCore.WebexPlugin.prototype.initialize, this, args);
  },

  /**
   * Register to listen for incoming messages events
   * This is an alternate approach to registering for messages webhooks.
   * The events passed to any registered handlers will be similar to the webhook JSON,
   * but will omit webhook specific fields such as name, secret, url, etc.
   * The messages.listen() event objects can also include additional fields not
   * available in the webhook's JSON payload: `text`, `markdown`, and `files`.
   * These fields are available when their details are included in the web socket's
   * `activity` object. Retrieving other fields, such as the `html` field,
   * will require a manual request to get the corresponding message object.
   * To utilize the `listen()` method, the authorization token used
   * will need to have `spark:all` and `spark:kms` scopes enabled.
   * Note that by configuring your application to enable or disable `spark:all`
   * via its configuration page will also enable or disable `spark:kms`.
   * See the <a href="https://js.samples.s4d.io/browser-socket/">Sample App</a>
   * for more details.
   * @instance
   * @memberof Messages
   * @returns {Promise}
   * @example
   * webex.messages.listen()
   *   .then(() => {
   *     console.log('listening to message events');
   *     webex.messages.on('created', (event) => console.log(`Got a message:created event:\n${event}`);
   *     webex.messages.on('deleted', (event) => console.log(`Got a message:deleted event:\n${event}`);
   *   })
   *   .catch((e) => console.error(`Unable to register for message events: ${e}`));
   * // Some app logic...
   * // WHen it is time to cleanup
   * webex.messages.stopListening();
   * webex.messages.off('created');
   * webex.messages.off('deleted');
   */
  listen: function listen() {
    var _this = this;

    // Create a common envelope that we will wrap all events in
    return (0, _common.createEventEnvelope)(this.webex, _common.SDK_EVENT.EXTERNAL.RESOURCE.MESSAGES).then(function (envelope) {
      _this.eventEnvelope = envelope; // Register to listen to events

      return _this.webex.internal.mercury.connect().then(function () {
        _this.listenTo(_this.webex.internal.mercury, _common.SDK_EVENT.INTERNAL.WEBEX_ACTIVITY, function (event) {
          return _this.onWebexApiEvent(event);
        });
      });
    });
  },

  /**
   * Post a new message and/or media content into a room.
   * @instance
   * @memberof Messages
   * @param {MessageObject} message
   * @returns {Promise<MessageObject>}
   * @example
   * webex.rooms.create({title: 'Create Message Example'})
   *   .then(function(room) {
   *     return webex.messages.create({
   *       text: 'Howdy!',
   *       roomId: room.id
   *     });
   *   })
   *   .then(function(message) {
   *     var assert = require('assert');
   *     assert(message.id);
   *     assert(message.personId);
   *     assert(message.personEmail);
   *     assert(message.roomId);
   *     assert(message.created);
   *     return 'success';
   *   });
   *   // => success
   */
  create: function create(message) {
    var key = 'body';

    if (message.file) {
      this.logger.warn('Supplying a single `file` property is deprecated; please supply a `files` array');
      message.files = [message.file];
      (0, _deleteProperty.default)(message, 'file');
    }

    if ((0, _isArray2.default)(message.files) && message.files.reduce(function (type, file) {
      return type || typeof file !== 'string';
    }, false)) {
      key = 'formData';
    }

    var options = (0, _defineProperty2.default)({
      method: 'POST',
      service: 'hydra',
      resource: 'messages'
    }, key, message);
    return this.request(options).then(function (res) {
      return res.body;
    });
  },

  /**
   * Returns a single message.
   * @instance
   * @memberof Messages
   * @param {RoomObject|string} message
   * @returns {Promise<MessageObject>}
   * @example
   * var message;
   * webex.rooms.create({title: 'Get Message Example'})
   *   .then(function(room) {
   *     return webex.messages.create({
   *       text: 'Howdy!',
   *       roomId: room.id
   *     });
   *   })
   *   .then(function(m) {
   *     message = m;
   *     return webex.messages.get(message.id);
   *   })
   *   .then(function(message2) {
   *     var assert = require('assert');
   *     assert.deepEqual(message2, message);
   *     return 'success';
   *   });
   *   // => success
   */
  get: function get(message) {
    var id = message.id || message;
    return this.request({
      service: 'hydra',
      resource: "messages/".concat(id)
    }).then(function (res) {
      return res.body.items || res.body;
    });
  },

  /**
   * Returns a list of messages. In most cases the results will only contain
   * messages posted in rooms that the authentiated user is a member of.
   * @instance
   * @memberof Messages
   * @param {Object} options
   * @param {string} options.roomId
   * @param {number} options.max
   * @returns {Promise<Page<MessageObject>>}
   * @example
   * var message1, message2, room;
   * webex.rooms.create({title: 'List Messages Example'})
   *   .then(function(r) {
   *     room = r;
   *     return webex.messages.create({
   *       text: 'Howdy!',
   *       roomId: room.id
   *     });
   *   })
   *   .then(function(m) {
   *     message1 = m;
   *     return webex.messages.create({
   *       text: 'How are you?',
   *       roomId: room.id
   *     });
   *   })
   *   .then(function(m) {
   *     message2 = m;
   *     return webex.messages.list({roomId: room.id});
   *   })
   *   .then(function(messages) {
   *     var assert = require('assert');
   *     assert.equal(messages.length, 2);
   *     assert.equal(messages.items[0].id, message2.id);
   *     assert.equal(messages.items[1].id, message1.id);
   *     return 'success';
   *   });
   *   // => success
   */
  list: function list(options) {
    var _this2 = this;

    return this.request({
      service: 'hydra',
      resource: 'messages',
      qs: options
    }).then(function (res) {
      return new _webexCore.Page(res, _this2.webex);
    });
  },

  /**
   * Deletes a single message. Deleting a message will notify all members of the
   * room that the authenticated user deleted the message. Generally, users can
   * only delete their own messages except for the case of Moderated Rooms and
   * Org Administrators.
   * @instance
   * @memberof Messages
   * @param {MessageObject|uuid} message
   * @returns {Promise}}
   * @example
   * var message1, room;
   * webex.rooms.create({title: 'Messages Example'})
   *   .then(function(r) {
   *     room = r;
   *     return webex.messages.create({
   *       text: 'Howdy!',
   *       roomId: room.id
   *     });
   *   })
   *   .then(function(m) {
   *     message1 = m;
   *     return webex.messages.create({
   *       text: 'How are you?',
   *       roomId: room.id
   *     });
   *   })
   *   .then(function() {
   *     return webex.messages.remove(message1);
   *   })
   *   .then(function() {
   *     return webex.messages.list({roomId: room.id});
   *   })
   *   .then(function(messages) {
   *     var assert = require('assert');
   *     assert.equal(messages.items.length, 1);
   *     assert(messages.items[0].id !== message1.id);
   *     return 'success';
   *   });
   *   // => success
   */
  remove: function remove(message) {
    var id = message.id || message;
    return this.request({
      method: 'DELETE',
      service: 'hydra',
      resource: "messages/".concat(id)
    }).then(function (res) {
      // Firefox has some issues with 204s and/or DELETE. This should move to
      // http-core
      if (res.statusCode === 204) {
        return undefined;
      }

      return res.body;
    });
  },

  /**
   * Curry the 'trigger' method
   * @private
   * @memberof Messages
   * @param {string} type the type of event to fire
   * @returns {function} takes event and triggers it
   */
  fire: function fire(type) {
    var _this3 = this;

    return function (event) {
      return _this3.trigger(type, event);
    };
  },

  /**
   * This function is called when an internal membership events fires,
   * if the user registered for these events with the listen() function.
   * External users of the SDK should not call this function
   * @private
   * @memberof Messages
   * @param {Object} event
   * @param {Object} event.data contains the data of the event
   * @param {Object} event.data.activity the activity that triggered the event
   * @returns {void}
   */
  onWebexApiEvent: function onWebexApiEvent(_ref) {
    var activity = _ref.data.activity;
    var type = verbToType[activity.verb];

    if (!type) {
      return;
    }

    this.getMessageEvent(activity, type).then(this.fire(type));
  },

  /**
   * Constructs the data object for an event on the messages resource,
   * adhering to Hydra's Webehook data structure messages.
   * External users of the SDK should not call this function
   * @private
   * @memberof Messages
   * @param {Object} activity from mercury
   * @param {String} type the type of event
   * @returns {Object} constructed event
   */
  getMessageEvent: function getMessageEvent(activity, type) {
    var id = activity.id,
        _activity$actor = activity.actor,
        actorId = _activity$actor.entryUUID,
        emailAddress = _activity$actor.emailAddress,
        objectId = activity.object.id,
        _activity$target = activity.target,
        roomId = _activity$target.id,
        roomUrl = _activity$target.url,
        roomTags = _activity$target.tags;
    var cluster = (0, _common.getHydraClusterString)(this.webex, roomUrl);
    var combinedEvent = (0, _cloneDeep2.default)(this.eventEnvelope);
    combinedEvent.event = type;

    if (type === _common.SDK_EVENT.EXTERNAL.EVENT_TYPE.DELETED) {
      // Cannot fetch since the message is deleted
      // Convert the Mercury event to a Hydra event
      var personId = (0, _common.buildHydraPersonId)(actorId, cluster);
      return _promise.default.resolve(_objectSpread(_objectSpread({}, combinedEvent), {}, {
        actorId: personId,
        data: {
          id: (0, _common.buildHydraMessageId)(objectId, cluster),
          personEmail: emailAddress || actorId,
          personId: personId,
          roomId: (0, _common.buildHydraRoomId)(roomId, cluster),
          roomType: getRoomType(roomTags)
        }
      }));
    }

    return this.get((0, _common.buildHydraMessageId)(id, cluster)).then(function (data) {
      return _objectSpread(_objectSpread({}, combinedEvent), {}, {
        actorId: data.personId,
        data: data
      });
    });
  },
  version: "1.125.6"
});

var _default = Messages;
exports.default = _default;
//# sourceMappingURL=messages.js.map
