"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _defaults2 = _interopRequireDefault(require("lodash/defaults"));

var _webexCore = require("@webex/webex-core");

var _uuid = _interopRequireDefault(require("uuid"));

/*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */
var Support = _webexCore.WebexPlugin.extend({
  namespace: 'Support',
  getFeedbackUrl: function getFeedbackUrl(options) {
    options = options || {};
    return this.request({
      method: 'POST',
      api: 'conversation',
      resource: 'users/deskFeedbackUrl',
      body: (0, _defaults2.default)(options, {
        appVersion: this.config.appVersion,
        appType: this.config.appType,
        feedbackId: options.feedbackId || _uuid.default.v4(),
        languageCode: this.config.languageCode
      })
    }).then(function (res) {
      return res.body.url;
    });
  },
  getSupportUrl: function getSupportUrl() {
    return this.webex.request({
      method: 'GET',
      api: 'conversation',
      resource: 'users/deskSupportUrl',
      qs: {
        languageCode: this.config.languageCode
      }
    }).then(function (res) {
      return res.body.url;
    });
  },
  submitLogs: function submitLogs(metadata, logs) {
    var _this = this;

    var metadataArray = this._constructFileMetadata(metadata); // this is really testing that Ampersand is fully ready.  once it's ready, these exist


    if (!logs && this.webex.logger.sdkBuffer && this.webex.logger.clientBuffer && this.webex.logger.buffer) {
      logs = this.webex.logger.formatLogs();
    }

    var filename;

    if (metadata.locusId && metadata.callStart) {
      filename = "".concat(metadata.locusId, "_").concat(metadata.callStart, ".txt");
    } else {
      filename = "".concat(this.webex.sessionId, ".txt");
    }

    var userId;
    return this.webex.credentials.getUserToken().catch(function () {
      return _this.webex.credentials.getClientToken();
    }).then( /*#__PURE__*/function () {
      var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(token) {
        var headers, initalOpts, finalOpts, options;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                headers = {
                  authorization: token.toString()
                };
                initalOpts = {
                  service: 'clientLogs',
                  resource: 'logs/urls'
                };
                finalOpts = {
                  service: 'clientLogs',
                  resource: 'logs/meta'
                };
                options = (0, _defaults2.default)(initalOpts, {
                  file: logs,
                  shouldAttemptReauth: false,
                  headers: headers,
                  phases: {
                    initialize: {
                      body: {
                        file: filename
                      }
                    },
                    upload: {
                      $uri: function $uri(session) {
                        return session.tempURL;
                      }
                    },
                    finalize: (0, _defaults2.default)(finalOpts, {
                      $body: function $body(session) {
                        userId = session.userId;
                        return {
                          filename: session.logFilename,
                          data: metadataArray,
                          userId: _this.webex.internal.device.userId || session.userId
                        };
                      }
                    })
                  }
                });
                return _context.abrupt("return", _this.webex.upload(options));

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }()).then(function (body) {
      if (userId && !body.userId) {
        body.userId = userId;
      }

      return body;
    });
  },
  _constructFileMetadata: function _constructFileMetadata(metadata) {
    var metadataArray = ['locusId', 'callStart', 'feedbackId', 'correlationId', 'meetingId'].map(function (key) {
      if (metadata[key]) {
        return {
          key: key,
          value: metadata[key]
        };
      }

      return null;
    }).filter(function (entry) {
      return Boolean(entry);
    });

    if (this.webex.sessionId) {
      metadataArray.push({
        key: 'trackingId',
        value: this.webex.sessionId
      });
    }

    if (this.webex.internal.device.userId) {
      metadataArray.push({
        key: 'userId',
        value: this.webex.internal.device.userId
      });
    }

    if (this.webex.internal.device.orgId) {
      metadataArray.push({
        key: 'orgId',
        value: this.webex.internal.device.orgId
      });
    }

    return metadataArray;
  },
  version: "1.125.6"
});

var _default = Support;
exports.default = _default;
//# sourceMappingURL=support.js.map
