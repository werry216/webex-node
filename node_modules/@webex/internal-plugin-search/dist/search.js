"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _deleteProperty = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/delete-property"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/assign"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _getOwnPropertyDescriptor = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _applyDecoratedDescriptor2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/applyDecoratedDescriptor"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _common = require("@webex/common");

var _webexCore = require("@webex/webex-core");

var _obj;

var Search = _webexCore.WebexPlugin.extend((_obj = {
  namespace: 'Search',
  people: function people(options) {
    options = options || {};

    if (!options.queryString && options.query) {
      options.queryString = options.query;
      (0, _deleteProperty.default)(options, 'query');
    }

    if (!options.queryString) {
      return _promise.default.reject(new Error('`options.query` is required'));
    }

    return this.request({
      api: 'argonaut',
      resource: 'directory',
      method: 'POST',
      body: options
    }).then(function (res) {
      return res.body;
    });
  },
  bindSearchKey: function bindSearchKey() {
    var _this = this;

    return this.webex.internal.encryption.kms.createUnboundKeys({
      count: 1
    }).then(function (_ref) {
      var _ref2 = (0, _slicedToArray2.default)(_ref, 1),
          key = _ref2[0];

      return _this.webex.internal.encryption.kms.createResource({
        key: key,
        userIds: [_this.webex.internal.device.userId]
      }).then(function () {
        return _this.webex.internal.device.set('searchEncryptionKeyUrl', key.uri);
      });
    });
  },

  /**
  * Fetches search result activities
  * @param {Object} options
  * @param {boolean} options.includeRemoteClusterReferences when true,
  * includes search results from remote clusters
  * @returns {Promise<Array>} Resolves with the activities
  */
  search: function search(options) {
    var _this2 = this;

    /* eslint max-nested-callbacks: [0] */
    options = options || {};

    var promise = _promise.default.resolve();

    if (!this.webex.internal.device.searchEncryptionKeyUrl) {
      promise = this.bindSearchKey();
    }

    return promise.then(function () {
      return _this2.webex.request({
        service: 'argonaut',
        resource: 'search',
        method: 'POST',
        body: (0, _assign.default)(options, {
          searchEncryptionKeyUrl: _this2.webex.internal.device.searchEncryptionKeyUrl
        })
      });
    }).then(function (res) {
      var resActivities = (0, _get2.default)(res, 'body.activities.items', []);

      if (options.includeRemoteClusterReferences && res.body.breadcrumbs) {
        var breadcrumbs = res.body.breadcrumbs;
        var promises = [];
        (0, _keys.default)(breadcrumbs).forEach(function (cluster) {
          // Map activity URLs to their cluster
          var editedCluster = "".concat(cluster, ":identityLookup");
          var clusterActivityUrls = breadcrumbs[cluster].items.map(function (activity) {
            return activity.activityUrl;
          }); // Find activities per cluster

          var bulkActivitiesPromise = _this2.webex.internal.conversation.bulkActivitiesFetch(clusterActivityUrls, {
            cluster: editedCluster
          }).catch(function (err) {
            _this2.logger.warn('search: error fetching from remote clusters', err);

            return _promise.default.resolve([]);
          });

          promises.push(bulkActivitiesPromise);
        });
        return _promise.default.all(promises).then(function (clusterResults) {
          return clusterResults.reduce(function (accumulator, clusterResult) {
            return accumulator.concat(clusterResult);
          }, resActivities);
        });
      }

      return resActivities;
    });
  },
  version: "1.125.6"
}, ((0, _applyDecoratedDescriptor2.default)(_obj, "bindSearchKey", [_common.oneFlight], (0, _getOwnPropertyDescriptor.default)(_obj, "bindSearchKey"), _obj)), _obj));

var _default = Search;
exports.default = _default;
//# sourceMappingURL=search.js.map
