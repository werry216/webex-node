"use strict";

var _Object$keys2 = require("@babel/runtime-corejs2/core-js/object/keys");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");

var _Object$getOwnPropertyDescriptor2 = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");

var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/assign"));

var _deleteProperty = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/delete-property"));

var _now = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/date/now"));

var _getOwnPropertyDescriptor = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _applyDecoratedDescriptor2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/applyDecoratedDescriptor"));

var _set2 = _interopRequireDefault(require("lodash/set"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _camelCase2 = _interopRequireDefault(require("lodash/camelCase"));

var _url = _interopRequireDefault(require("url"));

var _webexCore = require("@webex/webex-core");

var _common = require("@webex/common");

var _backoff = _interopRequireDefault(require("backoff"));

var _socket = _interopRequireDefault(require("./socket"));

var _errors = require("./errors");

var _dec, _dec2, _obj;

function ownKeys(object, enumerableOnly) { var keys = _Object$keys2(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor2(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor2(source, key)); }); } } return target; }

var normalReconnectReasons = ['idle', 'done (forced)', 'pong not received', 'pong mismatch'];

var Mercury = _webexCore.WebexPlugin.extend((_dec = (0, _common.deprecated)('Mercury#listen(): Use Mercury#connect() instead'), _dec2 = (0, _common.deprecated)('Mercury#stopListening(): Use Mercury#disconnect() instead'), (_obj = {
  namespace: 'Mercury',
  session: {
    connected: {
      default: false,
      type: 'boolean'
    },
    connecting: {
      default: false,
      type: 'boolean'
    },
    socket: 'object',
    localClusterServiceUrls: 'object'
  },
  derived: {
    listening: {
      deps: ['connected'],
      fn: function fn() {
        return this.connected;
      }
    }
  },
  connect: function connect(webSocketUrl) {
    var _this = this;

    if (this.connected) {
      this.logger.info('mercury: already connected, will not connect again');
      return _promise.default.resolve();
    }

    this.connecting = true;
    return _promise.default.resolve(this.webex.internal.device.registered || this.webex.internal.device.register()).then(function () {
      _this.logger.info('mercury: connecting');

      return _this._connectWithBackoff(webSocketUrl);
    });
  },
  disconnect: function disconnect() {
    var _this2 = this;

    return new _promise.default(function (resolve) {
      if (_this2.backoffCall) {
        _this2.logger.info('mercury: aborting connection');

        _this2.backoffCall.abort();
      }

      if (_this2.socket) {
        _this2.socket.removeAllListeners('message');

        _this2.once('offline', resolve);

        _this2.socket.close();

        return;
      }

      resolve();
    });
  },
  listen: function listen() {
    /* eslint no-invalid-this: [0] */
    return this.connect();
  },
  stopListening: function stopListening() {
    /* eslint no-invalid-this: [0] */
    return this.disconnect();
  },
  processRegistrationStatusEvent: function processRegistrationStatusEvent(message) {
    this.localClusterServiceUrls = message.localClusterServiceUrls;
  },
  _applyOverrides: function _applyOverrides(event) {
    if (!event || !event.headers) {
      return;
    }

    var headerKeys = (0, _keys.default)(event.headers);
    headerKeys.forEach(function (keyPath) {
      (0, _set2.default)(event, keyPath, event.headers[keyPath]);
    });
  },
  _prepareUrl: function _prepareUrl(webSocketUrl) {
    var _this3 = this;

    if (!webSocketUrl) {
      webSocketUrl = this.webex.internal.device.webSocketUrl;
    }

    return this.webex.internal.feature.getFeature('developer', 'web-high-availability').then(function (haMessagingEnabled) {
      if (haMessagingEnabled) {
        return _this3.webex.internal.services.convertUrlToPriorityHostUrl(webSocketUrl);
      }

      return webSocketUrl;
    }).then(function (wsUrl) {
      webSocketUrl = wsUrl;
    }).then(function () {
      return _this3.webex.internal.feature.getFeature('developer', 'web-shared-mercury');
    }).then(function (webSharedMercury) {
      webSocketUrl = _url.default.parse(webSocketUrl, true);
      (0, _assign.default)(webSocketUrl.query, {
        outboundWireFormat: 'text',
        bufferStates: true,
        aliasHttpStatus: true
      });

      if (webSharedMercury) {
        (0, _assign.default)(webSocketUrl.query, {
          mercuryRegistrationStatus: true,
          isRegistrationRefreshEnabled: true
        });
        (0, _deleteProperty.default)(webSocketUrl.query, 'bufferStates');
      }

      if ((0, _get2.default)(_this3, 'webex.config.device.ephemeral', false)) {
        webSocketUrl.query.multipleConnections = true;
      }

      return _url.default.format(webSocketUrl);
    });
  },
  _attemptConnection: function _attemptConnection(socketUrl, callback) {
    var _this4 = this;

    var socket = new _socket.default();
    var attemptWSUrl;
    socket.on('close', function () {
      return _this4._onclose.apply(_this4, arguments);
    });
    socket.on('message', function () {
      return _this4._onmessage.apply(_this4, arguments);
    });
    socket.on('sequence-mismatch', function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _this4._emit.apply(_this4, ['sequence-mismatch'].concat(args));
    });

    _promise.default.all([this._prepareUrl(socketUrl), this.webex.credentials.getUserToken()]).then(function (_ref) {
      var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
          webSocketUrl = _ref2[0],
          token = _ref2[1];

      if (!_this4.backoffCall) {
        var msg = 'mercury: prevent socket open when backoffCall no longer defined';

        _this4.logger.info(msg);

        return _promise.default.reject(new Error(msg));
      }

      attemptWSUrl = webSocketUrl;
      var options = {
        forceCloseDelay: _this4.config.forceCloseDelay,
        pingInterval: _this4.config.pingInterval,
        pongTimeout: _this4.config.pongTimeout,
        token: token.toString(),
        trackingId: "".concat(_this4.webex.sessionId, "_").concat((0, _now.default)()),
        logger: _this4.logger
      }; // if the consumer has supplied request options use them

      if (_this4.webex.config.defaultMercuryOptions) {
        _this4.logger.info('mercury: setting custom options');

        options = _objectSpread(_objectSpread({}, options), _this4.webex.config.defaultMercuryOptions);
      } // Set the socket before opening it. This allows a disconnect() to close
      // the socket if it is in the process of being opened.


      _this4.socket = socket;
      return socket.open(webSocketUrl, options);
    }).then(function () {
      _this4.webex.internal.metrics.submitClientMetrics('web-ha-mercury', {
        fields: {
          success: true
        },
        tags: {
          action: 'connected',
          url: attemptWSUrl
        }
      });

      callback();
      return _this4.webex.internal.feature.getFeature('developer', 'web-high-availability').then(function (haMessagingEnabled) {
        if (haMessagingEnabled) {
          return _this4.webex.internal.device.refresh();
        }

        return _promise.default.resolve();
      });
    }).catch(function (reason) {
      // Suppress connection errors that appear to be network related. This
      // may end up suppressing metrics during outages, but we might not care
      // (especially since many of our outages happen in a way that client
      // metrics can't be trusted).
      if (reason.code !== 1006 && _this4.backoffCall && _this4.backoffCall.getNumRetries() > 0) {
        _this4._emit('connection_failed', reason, {
          retries: _this4.backoffCall.getNumRetries()
        });
      }

      _this4.logger.info('mercury: connection attempt failed', reason); // UnknownResponse is produced by IE for any 4XXX; treated it like a bad
      // web socket url and let WDM handle the token checking


      if (reason instanceof _errors.UnknownResponse) {
        _this4.logger.info('mercury: received unknown response code, refreshing device registration');

        return _this4.webex.internal.device.refresh().then(function () {
          return callback(reason);
        });
      } // NotAuthorized implies expired token


      if (reason instanceof _errors.NotAuthorized) {
        _this4.logger.info('mercury: received authorization error, reauthorizing');

        return _this4.webex.credentials.refresh({
          force: true
        }).then(function () {
          return callback(reason);
        });
      } // // NotFound implies expired web socket url
      // else if (reason instanceof NotFound) {
      //   this.logger.info(`mercury: received not found error, refreshing device registration`);
      //   return this.webex.internal.device.refresh()
      //     .then(() => callback(reason));
      // }
      // BadRequest implies current credentials are for a Service Account
      // Forbidden implies current user is not entitle for Webex


      if (reason instanceof _errors.BadRequest || reason instanceof _errors.Forbidden) {
        _this4.logger.warn('mercury: received unrecoverable response from mercury');

        _this4.backoffCall.abort();

        return callback(reason);
      }

      if (reason instanceof _errors.ConnectionError) {
        return _this4.webex.internal.feature.getFeature('developer', 'web-high-availability').then(function (haMessagingEnabled) {
          if (haMessagingEnabled) {
            _this4.logger.info('mercury: received a generic connection error, will try to connect to another datacenter');

            _this4.webex.internal.metrics.submitClientMetrics('web-ha-mercury', {
              fields: {
                success: false
              },
              tags: {
                action: 'failed',
                error: reason.message,
                url: attemptWSUrl
              }
            });

            return _this4.webex.internal.services.markFailedUrl(attemptWSUrl);
          }

          return null;
        }).then(function () {
          return callback(reason);
        });
      }

      return callback(reason);
    }).catch(function (reason) {
      _this4.logger.error('mercury: failed to handle connection failure', reason);

      callback(reason);
    });
  },
  _connectWithBackoff: function _connectWithBackoff(webSocketUrl) {
    var _this5 = this;

    return new _promise.default(function (resolve, reject) {
      // eslint gets confused about whether or not call is actually used
      // eslint-disable-next-line prefer-const
      var call;

      var onComplete = function onComplete(err) {
        _this5.connecting = false;
        _this5.backoffCall = undefined;

        if (err) {
          _this5.logger.info("mercury: failed to connect after ".concat(call.getNumRetries(), " retries; log statement about next retry was inaccurate; ").concat(err));

          return reject(err);
        }

        _this5.connected = true;

        _this5._emit('online');

        return resolve();
      }; // eslint-disable-next-line prefer-reflect


      call = _backoff.default.call(function (callback) {
        _this5.logger.info("mercury: executing connection attempt ".concat(call.getNumRetries()));

        _this5._attemptConnection(webSocketUrl, callback);
      }, onComplete);
      call.setStrategy(new _backoff.default.ExponentialStrategy({
        initialDelay: _this5.config.backoffTimeReset,
        maxDelay: _this5.config.backoffTimeMax
      }));

      if (_this5.config.maxRetries) {
        call.failAfter(_this5.config.maxRetries);
      }

      call.on('abort', function () {
        _this5.logger.info('mercury: connection aborted');

        reject(new Error('Mercury Connection Aborted'));
      });
      call.on('callback', function (err) {
        if (err) {
          var number = call.getNumRetries();
          var delay = Math.min(call.strategy_.nextBackoffDelay_, _this5.config.backoffTimeMax);

          _this5.logger.info("mercury: failed to connect; attempting retry ".concat(number + 1, " in ").concat(delay, " ms"));
          /* istanbul ignore if */


          if (process.env.NODE_ENV === 'development') {
            _this5.logger.debug('mercury: ', err, err.stack);
          }

          return;
        }

        _this5.logger.info('mercury: connected');
      });
      call.start();
      _this5.backoffCall = call;
    });
  },
  _emit: function _emit() {
    try {
      this.trigger.apply(this, arguments);
    } catch (error) {
      this.logger.error('mercury: error occurred in event handler', error);
    }
  },
  _getEventHandlers: function _getEventHandlers(eventType) {
    var _eventType$split = eventType.split('.'),
        _eventType$split2 = (0, _slicedToArray2.default)(_eventType$split, 2),
        namespace = _eventType$split2[0],
        name = _eventType$split2[1];

    var handlers = [];

    if (!this.webex[namespace] && !this.webex.internal[namespace]) {
      return handlers;
    }

    var handlerName = (0, _camelCase2.default)("process_".concat(name, "_event"));

    if ((this.webex[namespace] || this.webex.internal[namespace])[handlerName]) {
      handlers.push({
        name: handlerName,
        namespace: namespace
      });
    }

    return handlers;
  },
  _onclose: function _onclose(event) {
    // I don't see any way to avoid the complexity or statement count in here.

    /* eslint complexity: [0] */
    try {
      var reason = event.reason && event.reason.toLowerCase();
      var socketUrl = this.socket.url;
      this.socket.removeAllListeners();
      this.unset('socket');
      this.connected = false;

      this._emit('offline', event);

      switch (event.code) {
        case 1003:
          // metric: disconnect
          this.logger.info("mercury: Mercury service rejected last message; will not reconnect: ".concat(event.reason));

          this._emit('offline.permanent', event);

          break;

        case 4000:
          // metric: disconnect
          this.logger.info('mercury: socket replaced; will not reconnect');

          this._emit('offline.replaced', event);

          break;

        case 1001:
        case 1005:
        case 1006:
        case 1011:
          this.logger.info('mercury: socket disconnected; reconnecting');

          this._emit('offline.transient', event);

          this._reconnect(socketUrl); // metric: disconnect
          // if (code == 1011 && reason !== ping error) metric: unexpected disconnect


          break;

        case 1000:
          if (normalReconnectReasons.includes(reason)) {
            this.logger.info('mercury: socket disconnected; reconnecting');

            this._emit('offline.transient', event);

            this._reconnect(socketUrl); // metric: disconnect
            // if (reason === done forced) metric: force closure

          } else {
            this.logger.info('mercury: socket disconnected; will not reconnect');

            this._emit('offline.permanent', event);
          }

          break;

        default:
          this.logger.info('mercury: socket disconnected unexpectedly; will not reconnect'); // unexpected disconnect

          this._emit('offline.permanent', event);

      }
    } catch (error) {
      this.logger.error('mercury: error occurred in close handler', error);
    }
  },
  _onmessage: function _onmessage(event) {
    var _this6 = this;

    var envelope = event.data;

    if (process.env.ENABLE_MERCURY_LOGGING) {
      this.logger.debug('mercury: message envelope: ', envelope);
    }

    var data = envelope.data;

    this._applyOverrides(data);

    return this._getEventHandlers(data.eventType).reduce(function (promise, handler) {
      return promise.then(function () {
        var namespace = handler.namespace,
            name = handler.name;
        return new _promise.default(function (resolve) {
          return resolve((_this6.webex[namespace] || _this6.webex.internal[namespace])[name](data));
        }).catch(function (reason) {
          return _this6.logger.error("mercury: error occurred in autowired event handler for ".concat(data.eventType), reason);
        });
      });
    }, _promise.default.resolve()).then(function () {
      _this6._emit('event', event.data);

      var _data$eventType$split = data.eventType.split('.'),
          _data$eventType$split2 = (0, _slicedToArray2.default)(_data$eventType$split, 1),
          namespace = _data$eventType$split2[0];

      if (namespace === data.eventType) {
        _this6._emit("event:".concat(namespace), envelope);
      } else {
        _this6._emit("event:".concat(namespace), envelope);

        _this6._emit("event:".concat(data.eventType), envelope);
      }
    }).catch(function (reason) {
      _this6.logger.error('mercury: error occurred processing socket message', reason);
    });
  },
  _reconnect: function _reconnect(webSocketUrl) {
    this.logger.info('mercury: reconnecting');
    return this.connect(webSocketUrl);
  },
  version: "1.125.6"
}, ((0, _applyDecoratedDescriptor2.default)(_obj, "connect", [_common.oneFlight], (0, _getOwnPropertyDescriptor.default)(_obj, "connect"), _obj), (0, _applyDecoratedDescriptor2.default)(_obj, "disconnect", [_common.oneFlight], (0, _getOwnPropertyDescriptor.default)(_obj, "disconnect"), _obj), (0, _applyDecoratedDescriptor2.default)(_obj, "listen", [_dec], (0, _getOwnPropertyDescriptor.default)(_obj, "listen"), _obj), (0, _applyDecoratedDescriptor2.default)(_obj, "stopListening", [_dec2], (0, _getOwnPropertyDescriptor.default)(_obj, "stopListening"), _obj)), _obj)));

var _default = Mercury;
exports.default = _default;
//# sourceMappingURL=mercury.js.map
