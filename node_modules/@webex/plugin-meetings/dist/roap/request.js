"use strict";

var _Reflect$construct = require("@babel/runtime-corejs2/core-js/reflect/construct");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _webexCore = require("@webex/webex-core");

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _constants = require("../constants");

var _metrics = _interopRequireDefault(require("../metrics"));

var _config = require("../metrics/config");

var _parameter = _interopRequireDefault(require("../common/errors/parameter"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class RoapRequest
 */
var RoapRequest = /*#__PURE__*/function (_StatelessWebexPlugin) {
  (0, _inherits2.default)(RoapRequest, _StatelessWebexPlugin);

  var _super = _createSuper(RoapRequest);

  function RoapRequest() {
    (0, _classCallCheck2.default)(this, RoapRequest);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(RoapRequest, [{
    key: "attachRechabilityData",
    value:
    /**
     * Joins a meeting via ROAP
     * @param {Object} options
     * @returns {Promise} returns a promise that resolves/rejects whatever the request does
     */
    function attachRechabilityData(localSdp) {
      var reachabilityData = window.localStorage.getItem(_constants.REACHABILITY.localStorage);

      if (reachabilityData) {
        try {
          var reachabilityResult = JSON.parse(reachabilityData);
          /* istanbul ignore else */

          if (reachabilityResult && (0, _keys.default)(reachabilityResult).length) {
            localSdp.reachability = reachabilityResult;
          }
        } catch (e) {
          _loggerProxy.default.logger.error("Roap:request#attachReachabilityData --> Error in parsing reachability data: ".concat(e));
        }
      }

      return localSdp;
    }
  }, {
    key: "joinMeetingWithRoap",
    value: function joinMeetingWithRoap(options) {
      var _this = this;

      _loggerProxy.default.logger.info('Roap:request#joinMeetingWithRoap --> Join locus with roap');

      _loggerProxy.default.logger.info("Roap:request#joinMeetingWithRoap --> Local SDP: ".concat(options.roapMessage));

      return _promise.default.resolve().then( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        var _options$preferTransc;

        var deviceUrl, url, body;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                deviceUrl = _this.webex.internal.device.url;
                url = '';
                body = {
                  deviceUrl: deviceUrl,
                  usingResource: options.resourceId || null,
                  correlationId: options.correlationId,
                  localMedias: [{
                    localSdp: (0, _stringify.default)(_this.attachRechabilityData({
                      roapMessage: options.roapMessage,
                      audioMuted: false,
                      videoMuted: false
                    }))
                  }],
                  clientMediaPreferences: {
                    preferTranscoding: (_options$preferTransc = options.preferTranscoding) !== null && _options$preferTransc !== void 0 ? _options$preferTransc : true
                  }
                };

                if (!options.locusUrl) {
                  _context.next = 7;
                  break;
                }

                url = "".concat(options.locusUrl, "/").concat(_constants.PARTICIPANT);
                _context.next = 22;
                break;

              case 7:
                if (!options.sipUrl) {
                  _context.next = 21;
                  break;
                }

                _context.prev = 8;
                _context.next = 11;
                return _this.webex.internal.services.waitForCatalog('postauth');

              case 11:
                url = "".concat(_this.webex.internal.services.get('locus'), "/").concat(_constants.LOCI, "/").concat(_constants.CALL);
                body.invitee = {
                  address: options.sipTarget
                };
                _context.next = 19;
                break;

              case 15:
                _context.prev = 15;
                _context.t0 = _context["catch"](8);

                _loggerProxy.default.logger.error("Roap:request#joinMeetingWithRoap --> ".concat(_context.t0));

                throw _context.t0;

              case 19:
                _context.next = 22;
                break;

              case 21:
                throw new _parameter.default('Must provide a locusUrl or sipTarget');

              case 22:
                return _context.abrupt("return", _this.webex.request({
                  method: _constants.HTTP_VERBS.POST,
                  uri: url,
                  body: body
                }).then(function (res) {
                  var locus = res.body.locus;
                  locus.roapSeq = options.roapMessage.seq;
                  locus.id = locus.url.split('/').pop();

                  _loggerProxy.default.logger.info("Roap:request#joinMeetingWithRoap --> Joined locus [".concat(locus.id, "][").concat(locus.fullState.lastActive, "]"));

                  return locus;
                }).catch(function (err) {
                  _loggerProxy.default.logger.error("Roap:request#joinMeetingWithRoap --> failed with error: ".concat(err));

                  throw err;
                }));

              case 23:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[8, 15]]);
      })));
    }
    /**
     * Sends a ROAP message
     * @param {Object} options
     * @param {String} options.roapMessage
     * @param {String} options.locusId
     * @param {String} options.locusSelfId
     * @param {String} options.mediaId
     * @param {String} options.correlationId
     * @returns {Promise} returns the response/failure of the request
     */

  }, {
    key: "sendRoap",
    value: function sendRoap(options) {
      var _options$preferTransc2;

      var roapMessage = options.roapMessage,
          locusSelfUrl = options.locusSelfUrl,
          mediaId = options.mediaId,
          correlationId = options.correlationId,
          meetingId = options.meetingId;

      if (!mediaId) {
        _loggerProxy.default.logger.info('Roap:request#sendRoap --> Race Condition /call mediaID not present');
      }

      var mediaUrl = "".concat(locusSelfUrl, "/").concat(_constants.MEDIA);
      var deviceUrl = this.webex.internal.device.url;

      _loggerProxy.default.logger.info("Roap:request#sendRoap --> ".concat(mediaUrl, " \n ").concat(roapMessage.messageType, " \n seq:").concat(roapMessage.seq));

      _metrics.default.postEvent({
        event: _config.eventType.MEDIA_REQUEST,
        meetingId: meetingId
      });

      return this.webex.request({
        uri: mediaUrl,
        method: _constants.HTTP_VERBS.PUT,
        body: {
          device: {
            url: deviceUrl,
            deviceType: this.config.meetings.deviceType
          },
          correlationId: correlationId,
          localMedias: [{
            localSdp: (0, _stringify.default)(this.attachRechabilityData({
              roapMessage: roapMessage,
              // eslint-disable-next-line no-warning-comments
              // TODO: check whats the need for video and audiomute
              audioMuted: !!options.audioMuted,
              videoMuted: !!options.videoMuted
            })),
            mediaId: options.mediaId
          }],
          clientMediaPreferences: {
            preferTranscoding: (_options$preferTransc2 = options.preferTranscoding) !== null && _options$preferTransc2 !== void 0 ? _options$preferTransc2 : true
          }
        }
      }).then(function (res) {
        _metrics.default.postEvent({
          event: _config.eventType.MEDIA_RESPONSE,
          meetingId: meetingId
        }); // always it will be the first mediaConnection Object


        var mediaConnection = res.body.mediaConnections && res.body.mediaConnections.length > 0 && res.body.mediaConnections[0];

        _loggerProxy.default.logger.info("Roap:request#sendRoap --> response:".concat((0, _stringify.default)(mediaConnection, null, 2), "'\n StatusCode:'").concat(res.statusCode));

        var locus = res.body.locus;
        locus.roapSeq = options.roapMessage.seq;
        return locus;
      }).catch(function (err) {
        _metrics.default.postEvent({
          event: _config.eventType.MEDIA_RESPONSE,
          meetingId: meetingId,
          data: {
            error: _metrics.default.parseLocusError(err, true)
          }
        });

        _loggerProxy.default.logger.error("Roap:request#sendRoap --> Error:".concat((0, _stringify.default)(err, null, 2)));

        _loggerProxy.default.logger.error("Roap:request#sendRoapRequest --> errorBody:".concat((0, _stringify.default)(roapMessage, null, 2), " + '\\n mediaId:'").concat(options.mediaId));

        throw err;
      });
    }
  }]);
  return RoapRequest;
}(_webexCore.StatelessWebexPlugin);

exports.default = RoapRequest;
//# sourceMappingURL=request.js.map
