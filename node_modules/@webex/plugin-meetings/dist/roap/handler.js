"use strict";

var _Reflect$construct = require("@babel/runtime-corejs2/core-js/reflect/construct");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _webexCore = require("@webex/webex-core");

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _constants = require("../constants");

var _metrics = _interopRequireDefault(require("../metrics"));

var _util = _interopRequireDefault(require("./util"));

var _collection = _interopRequireDefault(require("./collection"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var checkForAndHandleErrors = function checkForAndHandleErrors(action, meeting, correlationId) {
  if (action && action.type) {
    if (action.msg && action.msg.messageType && action.msg.errorType) {
      if (_util.default.findError(action.msg.messageType, action.msg.errorType, action.type)) {
        _util.default.handleError(meeting.mediaProperties.peerConnection).then(function (res) {
          if (res) {
            _collection.default.deleteSessionSequence(correlationId, action.msg.seq);
          }
        }).catch(function (err) {
          _loggerProxy.default.logger.warn("Roap:handler#checkForAndHandleErrors --> Cannot reset the peer connection with error: ".concat(err));
        });

        return true;
      }
    }

    if (!_util.default.ensureMeeting(meeting, action.type)) {
      return true;
    }
  }

  return false;
};

var compareRemoteRoapOffer = function compareRemoteRoapOffer(lastRoapMessage, currentRoapMessage) {
  var _lastRoapMessage$msg;

  return (lastRoapMessage === null || lastRoapMessage === void 0 ? void 0 : (_lastRoapMessage$msg = lastRoapMessage.msg) === null || _lastRoapMessage$msg === void 0 ? void 0 : _lastRoapMessage$msg.seq) === currentRoapMessage.msg.seq;
};

var handleSessionStep = function handleSessionStep(_ref) {
  var roap = _ref.roap,
      session = _ref.session,
      locusUrl = _ref.locusUrl,
      correlationId = _ref.correlationId;
  var _roap$msg = roap.msg,
      sequenceId = _roap$msg.seq,
      messageType = _roap$msg.messageType;

  if (session.OFFER && messageType === _constants._OFFER_) {
    session.GLARE_OFFER = roap.msg;
    session.GLARE_OFFER.remote = !!roap.remote;
    var metricName = _constants.METRICS_OPERATIONAL_MEASURES.ROAP_GLARE_CONDITION;
    var data = {
      correlation_id: correlationId,
      locus_id: locusUrl.split('/').pop(),
      sequence: sequenceId
    };

    _metrics.default.sendOperationalMetric(metricName, data);

    _loggerProxy.default.logger.warn("Roap:handler#handleSessionStep --> Glare condition occurred with new mercury event, sequenceId: ".concat(sequenceId));
  } else {
    _loggerProxy.default.logger.info("Roap:handler#handleSessionStep --> Save OFFER/ANSWER seq:".concat(sequenceId, " new mercury event ").concat(messageType, "local state: ").concat((0, _stringify.default)(session.state.state, null, 2)));

    session[messageType] = roap.msg;
    session[messageType].remote = !!roap.remote;
  }
};
/**
 * @class RoapHandler
 */


var RoapHandler = /*#__PURE__*/function (_StatelessWebexPlugin) {
  (0, _inherits2.default)(RoapHandler, _StatelessWebexPlugin);

  var _super = _createSuper(RoapHandler);

  function RoapHandler(attrs, options, roapOk, roapAnswer) {
    var _this;

    (0, _classCallCheck2.default)(this, RoapHandler);
    _this = _super.call(this, {}, options);
    _this.attrs = attrs;
    _this.options = options;
    _this.roapOk = roapOk;
    _this.roapAnswer = roapAnswer;
    _this.lastRoapMessage = null;
    return _this;
  }
  /**
   *
   * @param {Object} session
   * @param {Meeting} meeting
   * @param {Object} action
   * @returns {null}
   */


  (0, _createClass2.default)(RoapHandler, [{
    key: "perform",
    value: function perform(session, meeting, action) {
      var _this2 = this;

      switch (session.state.state) {
        // case ROAP.ROAP_STATE.INIT:
        // case ROAP.ROAP_STATE.WAIT_RX_OFFER:
        // case ROAP.ROAP_STATE.WAIT_RX_ANSWER:
        // case ROAP.ROAP_STATE.WAIT_RX_OK:
        case _constants.ROAP.ROAP_STATE.WAIT_TX_ANSWER:
          // eslint-disable-next-line no-warning-comments
          // TODO: sometime the you get an answer while you are creating an offer so SKIP
          // Server will send the mercury event comes back
          if (_util.default.shouldHandleMedia(meeting)) {
            _util.default.updatePeerConnection(meeting, session).then(function (answerSdps) {
              _this2.roapAnswer({
                locusId: meeting.locusId,
                locusSelfId: meeting.locusInfo.self.id,
                mediaId: meeting.mediaId,
                sdps: answerSdps,
                seq: session.OFFER.seq,
                correlationId: meeting.correlationId,
                audioMuted: meeting.isAudioMuted(),
                videoMuted: meeting.isVideoMuted()
              });
            }).catch(function (error) {
              var metricName = _constants.METRICS_OPERATIONAL_MEASURES.ROAP_ANSWER_FAILURE;
              var data = {
                correlation_id: meeting.correlationId,
                locus_id: meeting.locusUrl.split('/').pop(),
                reason: error.message,
                stack: error.stack
              };
              var metadata = {
                type: error.name
              };

              _metrics.default.sendOperationalMetric(metricName, data, metadata);

              _loggerProxy.default.logger.error("Roap:handler#perform --> Error occured during wait receive answer, continuing, ".concat(error));
            });
          }

          break;

        case _constants.ROAP.ROAP_STATE.WAIT_TX_OK:
          if (!_util.default.shouldHandleMedia(meeting)) {
            _util.default.setRemoteDescription(meeting, session).then(function (res) {
              _this2.roapOk(res);
            });
          }

          break;
        // case ROAP.ROAP_STATE.IDLE_LOCAL_OFFER:

        case _constants.ROAP.ROAP_STATE.ERROR:
          _loggerProxy.default.logger.error("Roap:handler#perform --> Roap State ERROR for session: ".concat(session));

          break;

        case _constants.ROAP.ROAP_STATE.GLARE:
          session.GLARE_OFFER.tieBreaker = session.GLARE_OFFER.tieBreaker || 0;
          session.OFFER.tieBreaker = session.OFFER.tieBreaker || 0;

          _loggerProxy.default.logger.warn('Roap:handler#perform --> Roap State resolved the GLARE condition.');

          if (session.GLARE_OFFER.tieBreaker < session.OFFER.tieBreaker) {
            // 2
            _loggerProxy.default.logger.log('Roap:handler#perform --> Roap State local offer won after GLARE.');
          } else {
            _loggerProxy.default.logger.log('Roap:handler#perform --> Roap State remote offer won after GLARE.');
          }

          session.state.step(_constants.ROAP.ROAP_SIGNAL.GLARE_RESOLVED, meeting, action);
          this.perform(session, meeting);
          break;

        default:
          break;
      }
    }
    /**
     *
     * @param {String} signal
     * @param {Object} session
     * @param {Object} action
     * @param {Meeting} meeting
     * @param {String} prefix
     * @returns {null}
     */

  }, {
    key: "execute",
    value: function execute(signal, session, action, meeting, prefix) {
      if (session && session.state) {
        handleSessionStep({
          roap: action,
          locusUrl: meeting.locusUrl,
          correlationId: meeting.correlationId,
          session: session
        });
        signal = _constants.ROAP.ROAP_SIGNAL["".concat(prefix).concat(action.msg.messageType)];
        session.state.step(signal, meeting, action);
        this.perform(session, meeting, action);
      }
    }
    /**
     *
     * @param {Object} session
     * @param {Object} action
     * @param {Meeting} meeting
     * @param {String} correlationId
     * @returns {Boolean}
     */

  }, {
    key: "handleAction",
    value: function handleAction(session, action, meeting, correlationId) {
      var signal;

      switch (action.type) {
        case _constants.ROAP.RECEIVE_ROAP_MSG:
          if (compareRemoteRoapOffer(this.lastRoapMessage, action)) {
            _loggerProxy.default.logger.warn("Roap:handler#handleAction --> duplicate roap offer from server: ".concat(action.msg.seq));

            break;
          } else {
            this.lastRoapMessage = action;
            action.remote = true;
          }

          this.execute(signal, session, action, meeting, _constants.ROAP.RX_);
          break;

        case _constants.ROAP.SEND_ROAP_MSG:
          action.local = true;
          this.execute(signal, session, action, meeting, _constants.ROAP.TX_);
          break;

        case _constants.ROAP.SEND_ROAP_MSG_SUCCESS:
          // This means we got and answer and waiting for 200 ok for /participants
          if (_collection.default.getSessionSequence(correlationId, action.seq).ANSWER) {
            signal = _constants.ROAP.ROAP_SIGNAL.RX_ANSWER; // NOTE: When server send back an answer via mercury the
            // remote SDP is already saved sent and ok message is sent back
            // We dont have to indicate the roapHandler about the RX_ANSWER via SEND_ROAP_MSG_SUCCESS
            // RoapHandler.transition(signal, session, meeting);
          }

          break;

        case _constants.ROAP.RECEIVE_CALL_LEAVE:
          _collection.default.deleteSession(correlationId);

          _loggerProxy.default.logger.log("Roap:handler#handleAction --> RECEIVE_CALL_LEAVE event captured, cleaning up the RoapHandler for correlationId: ".concat(correlationId));

          break;

        case _constants.ROAP.RESET_ROAP_STATE:
          _collection.default.deleteSessionSequence(correlationId, action.msg.seq);

          _loggerProxy.default.logger.log("Roap:handler#handleAction --> RESET_ROAP_STATE event captured, resetting the RoapHandler state based on sequenceId: ".concat(action.msg.seq));

          break;

        default:
          return true;
      }

      return true;
    }
    /**
     *
     * @param {Object} action
     * @returns {Boolean}
     */

  }, {
    key: "submit",
    value: function submit(action) {
      var correlationId = action.correlationId;
      var seq = action.seq;

      if (!seq && action.msg) {
        seq = action.msg.seq;
      }

      var session = _collection.default.getSessionSequence(correlationId, seq);

      var meeting = this.webex.meetings.meetingCollection.getByKey('correlationId', correlationId);

      if (checkForAndHandleErrors(action, meeting, correlationId)) {
        return true;
      }

      return this.handleAction(session, action, meeting, correlationId);
    }
  }]);
  return RoapHandler;
}(_webexCore.StatelessWebexPlugin);

exports.default = RoapHandler;
//# sourceMappingURL=handler.js.map
