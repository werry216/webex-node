"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _taggedTemplateLiteral2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/taggedTemplateLiteral"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _difference2 = _interopRequireDefault(require("lodash/difference"));

var _queue = _interopRequireDefault(require("../common/queue"));

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10;

/**
 * Locus Delta Parser
 * @private
 * https://sqbu-github.cisco.com/WebExSquared/cloud-apps/wiki/Locus-Delta-Events
 */
var Parser = /*#__PURE__*/function () {
  // processing status
  // loci comparison states

  /**
   * @constructs Parser
   */
  function Parser() {
    (0, _classCallCheck2.default)(this, Parser);
    this.queue = new _queue.default();
    this.status = Parser.status.IDLE;
    this.onDeltaAction = null;
    this.workingCopy = null;
  }
  /**
   * Checks if two sequences overlap in time,
   * the sequence with the higher minimum value is greater.
   * Chooses sequence with most recent data.
   * @param {Types~Locus} current
   * @param {Types~Locus} incoming
   * @returns {string} loci comparison state
   */


  (0, _createClass2.default)(Parser, [{
    key: "isValidLocus",
    value:
    /**
     * Checks if newLoci or workingCopy is invalid.
     * @param {Types~Locus} newLoci
     * @returns {boolean}
     */
    function isValidLocus(newLoci) {
      var _this = this;

      var isValid = false;
      var IDLE = Parser.status.IDLE;
      var isLoci = Parser.isLoci;

      var setStatus = function setStatus(status) {
        _this.status = status;
      }; // one or both objects are not locus delta events


      if (!isLoci(this.workingCopy) || !isLoci(newLoci)) {
        setStatus(IDLE);

        _loggerProxy.default.logger.info('Locus-info:parser#processDeltaEvent --> Ignoring non-locus object. workingCopy:', this.workingCopy, 'newLoci:', newLoci);
      } else {
        isValid = true;
      }

      return isValid;
    }
    /**
     * Determines if a paricular locus's sequence is empty
     * @param {Types~Locus} locus
     * @returns {bool}
     */

  }, {
    key: "nextEvent",
    value:
    /**
     * Processes next event in queue,
     * if queue is empty sets status to idle.
     * @returns {undefined}
     */
    function nextEvent() {
      if (this.status === Parser.status.PAUSED) {
        _loggerProxy.default.logger.info('Locus-info:parser#nextEvent --> Locus parser paused.');

        return;
      } // continue processing until queue is empty


      if (this.queue.size() > 0) {
        this.processDeltaEvent();
      } else {
        this.status = Parser.status.IDLE;
      }
    }
    /**
     * Function handler for delta actions,
     * is set by instance callee.
     * @param {string} action Locus delta action
     * @param {Types~Locus} locus Locus delta
     * @returns {undefined}
     */
    // eslint-disable-next-line no-unused-vars

  }, {
    key: "onDeltaAction",
    value: function onDeltaAction(action, locus) {}
    /**
     * Event handler for locus delta events
     * @param {Types~Locus} loci Locus Delta
     * @returns {undefined}
     */

  }, {
    key: "onDeltaEvent",
    value: function onDeltaEvent(loci) {
      // enqueue the new loci
      this.queue.enqueue(loci); // start processing events in the queue if idle
      // and a function handler is defined

      if (this.status === Parser.status.IDLE && this.onDeltaAction) {
        // Update status, ensure we only process one event at a time.
        this.status = Parser.status.WORKING;
        this.processDeltaEvent();
      }
    }
    /**
     * Appends new data onto a string of existing data.
     * @param {string} newData
     * @param {string} oldData
     * @returns {string}
     */

  }, {
    key: "pause",
    value:
    /**
     * Pause locus processing
     * @returns {undefined}
     */
    function pause() {
      this.status = Parser.status.PAUSED;

      _loggerProxy.default.logger.info('Locus-info:parser#pause --> Locus parser paused.');
    }
    /**
     * Processes next locus delta in the queue,
     * continues until the queue is empty
     * or cleared.
     * @returns {undefined}
     */

  }, {
    key: "processDeltaEvent",
    value: function processDeltaEvent() {
      var _Parser$loci = Parser.loci,
          DESYNC = _Parser$loci.DESYNC,
          USE_INCOMING = _Parser$loci.USE_INCOMING;
      var extract = Parser.extractComparisonState;
      var newLoci = this.queue.dequeue();

      if (!this.isValidLocus(newLoci)) {
        return;
      }

      var result = Parser.compare(this.workingCopy, newLoci);
      var lociComparison = extract(result); // limited debugging, use chrome extension
      // for full debugging.

      _loggerProxy.default.logger.debug("Locus-info:parser#processDeltaEvent --> Locus Debug: ".concat(result));

      if (lociComparison === DESYNC) {
        // wait for desync response
        this.pause();
      } else if (lociComparison === USE_INCOMING) {
        // update working copy for future comparisons.
        // Note: The working copy of parser gets updated in .onFullLocus()
        // and here when USE_INCOMING locus.
        this.workingCopy = newLoci;
      }

      if (this.onDeltaAction) {
        _loggerProxy.default.logger.info("Locus-info:parser#processDeltaEvent --> Locus Delta Action: ".concat(lociComparison));

        this.onDeltaAction.call(this, lociComparison, newLoci);
      }

      this.nextEvent();
    }
    /**
     * Resume from a paused state
     * @returns {undefined}
     */

  }, {
    key: "resume",
    value: function resume() {
      _loggerProxy.default.logger.info('Locus-info:parser#resume --> Locus parser resumed.');

      this.status = Parser.status.WORKING;
      this.nextEvent();
    }
    /**
     * Gets related debug info for given error code
     * @param {string} debugCode Debug code
     * @param {string} comparison Locus comparison string
     * @returns {object} Debug message
     */

  }], [{
    key: "checkSequenceOverlap",
    value: function checkSequenceOverlap(current, incoming) {
      var comparison = null; // if earliest working copy sequence is more recent than last incoming sequence

      if (current.min > incoming.max) {
        // choose left side (current)
        comparison = "".concat(Parser.loci.GT, ":SO001");
      } // if last working copy sequence is before the earliest incoming sequence
      else if (current.max < incoming.min) {
          // choose right side (incoming)
          comparison = "".concat(Parser.loci.LT, ":SO002");
        } // if no match above, defaults to null


      return comparison;
    }
    /**
     * Checks if two sequences have unequal ranges.
     * Chooses sequence with most larger range.
     * @param {Types~Locus} current
     * @param {Types~Locus} incoming
     * @returns {object} loci comparison
     */

  }, {
    key: "checkUnequalRanges",
    value: function checkUnequalRanges(current, incoming) {
      var comparison = null;
      var currentIsNotUnique = current.unique.length === 0;
      var incomingIsNotUnique = incoming.unique.length === 0;
      var currentTotalRange = current.end - current.min;
      var incomingTotalRange = incoming.end - incoming.min; // no unique values for both loci

      if (currentIsNotUnique && incomingIsNotUnique) {
        // current working copy loci has a larger range
        if (currentTotalRange > incomingTotalRange) {
          // choose left side (current)
          comparison = "".concat(Parser.loci.GT, ":UR001");
        } // incoming delta loci has a larger range
        else if (currentTotalRange < incomingTotalRange) {
            // choose right side (incoming)
            comparison = "".concat(Parser.loci.LT, ":UR002");
          } else {
            // with no unique entries and with ranges either absent or
            // of the same size, the sequences are considered equal.
            comparison = "".concat(Parser.loci.EQ, ":UR003");
          }
      }

      return comparison;
    }
    /**
     * Checks if either sequences has unique entries.
     * Entries are considered unique if they do not overlap
     * with other Loci sequences or range values.
     * Chooses sequence with the unique entries.
     * @param {Types~Locus} current
     * @param {Types~Locus} incoming
     * @returns {string} loci comparison state
     */

  }, {
    key: "checkForUniqueEntries",
    value: function checkForUniqueEntries(current, incoming) {
      var comparison = null;
      var currentIsUnique = current.unique.length > 0;
      var incomingIsUnique = incoming.unique.length > 0; // current has unique entries and incoming does not

      if (currentIsUnique && !incomingIsUnique) {
        // choose left side (current)
        comparison = "".concat(Parser.loci.GT, ":UE001");
      } // current has no unique entries but incoming does
      else if (!currentIsUnique && incomingIsUnique) {
          // choose right side (incoming)
          comparison = "".concat(Parser.loci.LT, ":UE002");
        }

      return comparison;
    }
    /**
     * Checks both Locus Delta objects to see if they are
     * out of sync with one another. If so sends a DESYNC
     * request to the server.
     * @param {Types~Locus} current
     * @param {Types~Locus} incoming
     * @returns {string} loci comparison state
     */

  }, {
    key: "checkIfOutOfSync",
    value: function checkIfOutOfSync(current, incoming) {
      var comparison = null;
      var currentUniqueMin = current.unique[0];
      var incomingUniqueMin = incoming.unique[0];
      var currentHasNoRange = !current.start && !current.end;
      var incomingHasNoRange = !incoming.start && !incoming.end;
      var neitherSeqHasRange = currentHasNoRange && incomingHasNoRange;

      var hasUniqOverlap = function hasUniqOverlap(list, min, max) {
        return list.some(function (seq) {
          return min < seq && seq < max;
        });
      }; // current unique entries overlap the total range of incoming


      var currentUniqOverlap = hasUniqOverlap(current.unique, incoming.min, incoming.max); // vice-versa, incoming unique entries overlap the total range of current

      var incomingUniqOverlap = hasUniqOverlap(incoming.unique, current.min, current.max);

      if (neitherSeqHasRange || currentUniqOverlap || incomingUniqOverlap) {
        // outputs string indicating which condition occurred. ex: 0,1,0
        var debugInfo = "".concat(+neitherSeqHasRange, ",").concat(+currentUniqOverlap, ",").concat(+incomingUniqOverlap); // send DESYNC to server

        comparison = "".concat(Parser.loci.DESYNC, ":OOS001:").concat(debugInfo);
      } else if (currentUniqueMin > incomingUniqueMin) {
        // choose left side (current)
        comparison = "".concat(Parser.loci.GT, ":OOS002");
      } else {
        // choose right side (incoming)
        comparison = "".concat(Parser.loci.LT, ":OOS003");
      }

      return comparison;
    }
    /**
     * Compares two loci to determine which one contains the most recent state
     * @instance
     * @memberof Locus
     * @param {Types~Locus} current
     * @param {Types~Locus} incoming
     * @returns {string} loci comparison state
     */

  }, {
    key: "compare",
    value: function compare(current, incoming) {
      var isSequenceEmpty = Parser.isSequenceEmpty;
      var extract = Parser.extractComparisonState;
      var pack = Parser.packComparisonResult;

      if (isSequenceEmpty(current) || isSequenceEmpty(incoming)) {
        return pack(Parser.loci.USE_INCOMING, 'C001');
      }

      if (incoming.baseSequence) {
        return pack(Parser.compareDelta(current, incoming), 'C002');
      }

      var result = Parser.compareSequence(current.sequence, incoming.sequence);
      var action = Parser.compareToAction(extract(result));
      return pack(action, result);
    }
    /**
     * Compares two loci sequences (with delta params) and indicates what action
     * to take.
     * @instance
     * @memberof Locus
     * @param {Types~Locus} current
     * @param {Types~Locus} incoming
     * @private
     * @returns {string} loci comparison state
     */

  }, {
    key: "compareDelta",
    value: function compareDelta(current, incoming) {
      var _Parser$loci2 = Parser.loci,
          LT = _Parser$loci2.LT,
          GT = _Parser$loci2.GT,
          EQ = _Parser$loci2.EQ,
          DESYNC = _Parser$loci2.DESYNC,
          USE_INCOMING = _Parser$loci2.USE_INCOMING;
      var extract = Parser.extractComparisonState;
      var pack = Parser.packComparisonResult;
      var result = Parser.compareSequence(current.sequence, incoming.sequence);
      var comparison = extract(result);

      if (comparison !== LT) {
        return pack(Parser.compareToAction(comparison), result);
      }

      comparison = Parser.compareSequence(current.sequence, incoming.baseSequence);

      switch (extract(comparison)) {
        case GT:
        case EQ:
          comparison = USE_INCOMING;
          break;

        default:
          comparison = DESYNC;
      }

      return pack(comparison, result);
    }
    /**
     * Compares Locus sequences
     * @param {Types~Locus} current Current working copy
     * @param {Types~Locus} incoming New Locus delta
     * @returns {string}
     */

  }, {
    key: "compareSequence",
    value: function compareSequence(current, incoming) {
      // Locus sequence comparison rules in order of priority.
      // https://sqbu-github.cisco.com/WebExSquared/cloud-apps/wiki/Locus-Sequence-Comparison-Algorithm
      var local = Parser.getMetaData(current);
      var delta = Parser.getMetaData(incoming); // update loci metadata

      local.unique = Parser.getUniqueSequences(local, delta);
      delta.unique = Parser.getUniqueSequences(delta, local); // Locus sequence comparison rules
      // order matters

      var rules = [Parser.checkSequenceOverlap, Parser.checkUnequalRanges, Parser.checkForUniqueEntries, Parser.checkIfOutOfSync];

      for (var _i = 0, _rules = rules; _i < _rules.length; _i++) {
        var rule = _rules[_i];
        // Rule only returns a value if the rule applies,
        // otherwise returns null.
        var result = rule(local, delta);

        if (result) {
          return result;
        }
      } // error, none of rules above applied
      // should never get here as last rule
      // should be catch all.


      return Parser.loci.ERROR;
    }
    /**
     * Transates the result of a sequence comparison into an intended behavior
     * @param {string} result
     * @returns {string} Locus comparison action
     */

  }, {
    key: "compareToAction",
    value: function compareToAction(result) {
      var _Parser$loci3 = Parser.loci,
          DESYNC = _Parser$loci3.DESYNC,
          EQ = _Parser$loci3.EQ,
          ERROR = _Parser$loci3.ERROR,
          GT = _Parser$loci3.GT,
          LT = _Parser$loci3.LT,
          USE_CURRENT = _Parser$loci3.USE_CURRENT,
          USE_INCOMING = _Parser$loci3.USE_INCOMING;
      var action = ERROR;

      switch (result) {
        case EQ:
        case GT:
          action = USE_CURRENT;
          break;

        case LT:
          action = USE_INCOMING;
          break;

        case DESYNC:
          action = DESYNC;
          break;

        default:
          _loggerProxy.default.logger.info("Locus-info:parser#compareToAction --> Error: ".concat(result, " is not a recognized sequence comparison result."));

      }

      return action;
    }
    /**
     * Extracts a loci comparison from a string of data.
     * @param {string} lociComparisonResult Comparison result with extra data
     * @returns {string} Comparison of EQ, LT, GT, or DESYNC.
     */

  }, {
    key: "extractComparisonState",
    value: function extractComparisonState(lociComparisonResult) {
      return lociComparisonResult.split(':')[0];
    }
    /**
     * @typedef {object} LociMetadata
     * @property {number} start - Starting sequence number
     * @property {number} end - Ending sequence number
     * @property {number} first - First sequence number
     * @property {number} last - Last sequence number
     * @property {number} min - Minimum sequence number
     * @property {number} max - Maximum sequence number
     * @property {number} entries - Loci sequence entries
     */

    /**
     * Metadata for Locus delta
     * @param {Array.<number>} sequence Locus delta sequence
     * @returns {LociMetadata} Locus Delta Metadata
     */

  }, {
    key: "getMetaData",
    value: function getMetaData(sequence) {
      var entries = sequence.entries;
      var first = entries[0];
      var last = entries.slice(-1)[0]; // rangeStart or rangeEnd is 0 if a range doesn't exist

      var start = sequence.rangeStart;
      var end = sequence.rangeEnd; // sequence data

      return {
        start: start,
        end: end,
        first: first,
        last: last,
        // Rule is: rangeStart <= rangeEnd <= min(entries)
        min: start || first,
        // Grab last entry if exist else default to rangeEnd
        max: last || end,
        // keep reference to actual sequence entries
        entries: entries
      };
    }
    /**
     * Compares two Locus delta objects and notes unique
     * values contained within baseLoci.
     * @param {LociMetadata} baseLoci
     * @param {LociMetadata} otherLoci
     * @returns {Array.<number>} List of unique sequences
     */

  }, {
    key: "getUniqueSequences",
    value: function getUniqueSequences(baseLoci, otherLoci) {
      var diff = (0, _difference2.default)(baseLoci.entries, otherLoci.entries);
      var start = otherLoci.start,
          end = otherLoci.end;
      return Parser.getNumbersOutOfRange(diff, start, end);
    }
    /**
     * Returns an array of numbers outside of a given range.
     * @param {Array.<number>} list Array to filter
     * @param {number} rangeStart Start of range
     * @param {number} rangeEnd End of range
     * @returns {Array.<number>} Array of numbers sorted ASC
     */

  }, {
    key: "getNumbersOutOfRange",
    value: function getNumbersOutOfRange(list, rangeStart, rangeEnd) {
      // Collect all numbers if number is outside of specified range
      var output = list.filter(function (num) {
        return num < rangeStart || num > rangeEnd;
      }); // sort ascending

      return output.sort(function (a, b) {
        return a - b;
      });
    }
  }, {
    key: "isSequenceEmpty",
    value: function isSequenceEmpty(locus) {
      var _sequence$entries;

      var sequence = locus.sequence;
      var hasEmptyEntries = !((_sequence$entries = sequence.entries) !== null && _sequence$entries !== void 0 && _sequence$entries.length);
      var hasEmptyRange = sequence.rangeStart === 0 && sequence.rangeEnd === 0;
      return hasEmptyEntries && hasEmptyRange;
    }
    /**
     * Determines if an object has basic
     * structure of a locus object.
     * @param {Types~Locus} loci
     * @returns {boolean}
     */

  }, {
    key: "isLoci",
    value: function isLoci(loci) {
      if (!loci || !loci.sequence) {
        return false;
      }

      var hasProp = function hasProp(prop) {
        return Object.prototype.hasOwnProperty.call(loci.sequence, prop);
      };

      if (hasProp('rangeStart') && hasProp('rangeEnd')) {
        return true;
      }

      return false;
    }
  }, {
    key: "packComparisonResult",
    value: function packComparisonResult(newData, oldData) {
      return "".concat(newData, ":").concat(oldData);
    }
  }, {
    key: "getDebugMessage",
    value: function getDebugMessage(debugCode, comparison) {
      // removes extra spaces from multiline string
      var mStr = function mStr(strings) {
        return strings.join('').replace(/\s{2,}/g, ' ');
      };

      var resolutionMap = {
        EQ: "".concat(Parser.loci.LT, ": is equal (current == incoming)."),
        LT: "".concat(Parser.loci.LT, ": choose right side (incoming)."),
        GT: "".concat(Parser.loci.GT, ": choose left side (current).")
      };
      var debugMap = {
        SO001: {
          title: 'checkSequenceOverlap-001',
          description: mStr(_templateObject || (_templateObject = (0, _taggedTemplateLiteral2.default)(["Occurs if earliest working copy sequence is more             recent than last incoming sequence."], ["Occurs if earliest working copy sequence is more \\\n            recent than last incoming sequence."]))),
          logic: 'current.min > incoming.max'
        },
        SO002: {
          title: 'checkSequenceOverlap-002',
          description: mStr(_templateObject2 || (_templateObject2 = (0, _taggedTemplateLiteral2.default)(["Occurs if last working copy sequence is before the           earliest incoming sequence."], ["Occurs if last working copy sequence is before the \\\n          earliest incoming sequence."]))),
          logic: 'current.max < incoming.min'
        },
        UR001: {
          title: 'checkUnequalRanges-001',
          description: mStr(_templateObject3 || (_templateObject3 = (0, _taggedTemplateLiteral2.default)(["Occurs if there are no unique values for both loci,           and the current working copy loci has a larger range."], ["Occurs if there are no unique values for both loci, \\\n          and the current working copy loci has a larger range."]))),
          logic: 'currentTotalRange > incomingTotalRange'
        },
        UR002: {
          title: 'checkUnequalRanges-002',
          description: mStr(_templateObject4 || (_templateObject4 = (0, _taggedTemplateLiteral2.default)(["Occurs if there are no unique values for both loci,           and the incoming delta loci has a larger range."], ["Occurs if there are no unique values for both loci, \\\n          and the incoming delta loci has a larger range."]))),
          logic: 'currentTotalRange < incomingTotalRange'
        },
        UR003: {
          title: 'checkUnequalRanges-003',
          description: mStr(_templateObject5 || (_templateObject5 = (0, _taggedTemplateLiteral2.default)(["Occurs if there are no unique values for both loci,           and with ranges either absent or of the same size, the sequences           are considered equal."], ["Occurs if there are no unique values for both loci, \\\n          and with ranges either absent or of the same size, the sequences \\\n          are considered equal."]))),
          logic: 'currentTotalRange == incomingTotalRange'
        },
        UE001: {
          title: 'checkForUniqueEntries-001',
          description: mStr(_templateObject6 || (_templateObject6 = (0, _taggedTemplateLiteral2.default)(["Occurs if current loci has unique entries and           incoming does not. Entries are considered unique if they           do not overlap with other Loci sequences or range values."], ["Occurs if current loci has unique entries and \\\n          incoming does not. Entries are considered unique if they \\\n          do not overlap with other Loci sequences or range values."]))),
          logic: 'currentIsUnique && !incomingIsUnique'
        },
        UE002: {
          title: 'checkForUniqueEntries-002',
          description: mStr(_templateObject7 || (_templateObject7 = (0, _taggedTemplateLiteral2.default)(["Occurs if current has no unique entries but           incoming does. Entries are considered unique if they           do not overlap with other Loci sequences or range values."], ["Occurs if current has no unique entries but \\\n          incoming does. Entries are considered unique if they \\\n          do not overlap with other Loci sequences or range values."]))),
          logic: '!currentIsUnique && incomingIsUnique'
        },
        OOS001: {
          title: 'checkIfOutOfSync-001',
          description: mStr(_templateObject8 || (_templateObject8 = (0, _taggedTemplateLiteral2.default)(["Occurs if neither sequence has a range, or           if the current loci unique entries overlap the total range of the           incoming sequence, or if the incoming unique entries overlap           the total range of current sequence."], ["Occurs if neither sequence has a range, or \\\n          if the current loci unique entries overlap the total range of the \\\n          incoming sequence, or if the incoming unique entries overlap \\\n          the total range of current sequence."]))),
          logic: 'neitherSeqHasRange || currentUniqOverlap || incomingUniqOverlap'
        },
        OOS002: {
          title: 'checkIfOutOfSync-002',
          description: mStr(_templateObject9 || (_templateObject9 = (0, _taggedTemplateLiteral2.default)(["Occurs if the minimum value from sequences that are           unique to the current loci is greater than the minimum value from           sequences that are unique to the incoming loci."], ["Occurs if the minimum value from sequences that are \\\n          unique to the current loci is greater than the minimum value from \\\n          sequences that are unique to the incoming loci."]))),
          logic: 'currentUniqueMin > incomingUniqueMin'
        },
        OOS003: {
          title: 'checkIfOutOfSync-003',
          description: mStr(_templateObject10 || (_templateObject10 = (0, _taggedTemplateLiteral2.default)(["Occurs if none of the comparison rules applied.           It is a catch all."], ["Occurs if none of the comparison rules applied. \\\n          It is a catch all."]))),
          logic: 'else (catch all)'
        }
      };
      var debugObj = debugMap[debugCode];
      debugObj.title = "Debug: ".concat(debugObj.title);
      debugObj.resolution = resolutionMap[comparison];
      return debugObj;
    }
  }]);
  return Parser;
}();

exports.default = Parser;
(0, _defineProperty2.default)(Parser, "status", {
  IDLE: 'IDLE',
  PAUSED: 'PAUSED',
  WORKING: 'WORKING'
});
(0, _defineProperty2.default)(Parser, "loci", {
  EQ: 'EQUAL',
  GT: 'GREATER_THAN',
  LT: 'LESS_THAN',
  DESYNC: 'DESYNC',
  USE_INCOMING: 'USE_INCOMING',
  USE_CURRENT: 'USE_CURRENT',
  ERROR: 'ERROR'
});
//# sourceMappingURL=parser.js.map
