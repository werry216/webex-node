"use strict";

var _Reflect$construct = require("@babel/runtime-corejs2/core-js/reflect/construct");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _eventsScope = _interopRequireDefault(require("../common/events/events-scope"));

var _constants = require("../constants");

var _metrics = _interopRequireDefault(require("../metrics"));

var _config = require("../metrics/config");

var _infoUtils = _interopRequireDefault(require("../locus-info/infoUtils"));

var _fullState = _interopRequireDefault(require("../locus-info/fullState"));

var _selfUtils = _interopRequireDefault(require("../locus-info/selfUtils"));

var _hostUtils = _interopRequireDefault(require("../locus-info/hostUtils"));

var _controlsUtils = _interopRequireDefault(require("../locus-info/controlsUtils"));

var _mediaSharesUtils = _interopRequireDefault(require("../locus-info/mediaSharesUtils"));

var _parser = _interopRequireDefault(require("../locus-info/parser"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @description LocusInfo extends ChildEmitter to convert locusInfo info a private emitter to parent object
 * @export
 * @private
 * @class LocusInfo
 */
var LocusInfo = /*#__PURE__*/function (_EventsScope) {
  (0, _inherits2.default)(LocusInfo, _EventsScope);

  var _super = _createSuper(LocusInfo);

  function LocusInfo(updateMeeting, webex, meetingId) {
    var _this;

    (0, _classCallCheck2.default)(this, LocusInfo);
    _this = _super.call(this);
    _this.parsedLocus = {
      states: []
    };
    _this.webex = webex;
    _this.emitChange = false;
    _this.compareAndUpdateFlags = {};
    _this.meetingId = meetingId;
    _this.updateMeeting = updateMeeting;
    _this.locusParser = new _parser.default();
    return _this;
  }
  /**
   * Apply locus delta data to meeting
   * @param {string} action Locus delta action
   * @param {Locus} locus
   * @param {Meeting} meeting
   * @returns {undefined}
   */


  (0, _createClass2.default)(LocusInfo, [{
    key: "applyLocusDeltaData",
    value: function applyLocusDeltaData(action, locus, meeting) {
      var _this2 = this;

      var _LocusDeltaParser$loc = _parser.default.loci,
          DESYNC = _LocusDeltaParser$loc.DESYNC,
          USE_CURRENT = _LocusDeltaParser$loc.USE_CURRENT,
          USE_INCOMING = _LocusDeltaParser$loc.USE_INCOMING;

      switch (action) {
        case USE_INCOMING:
          meeting.locusInfo.onDeltaLocus(locus);
          break;

        case USE_CURRENT:
          meeting.locusDesync = false;
          meeting.needToGetFullLocus = false;
          break;

        case DESYNC:
          meeting.meetingRequest.getFullLocus({
            desync: true,
            locusUrl: meeting.locusUrl
          }).then(function (res) {
            meeting.locusInfo.onFullLocus(res.body); // Notify parser to resume processing delta events
            // now that we have full locus from DESYNC.

            _this2.locusParser.resume();
          });
          break;

        default:
          _loggerProxy.default.logger.info("Locus-info:index#applyLocusDeltaData --> Unknown locus delta action: ".concat(action));

      }
    }
    /**
     * Adds locus delta to parser's queue
     * and registers a function handler
     * to recieve parsed actions from queue.
     * @param {Locus} locus
     * @param {Meeting} meeting
     * @returns {undefined}
     */

  }, {
    key: "handleLocusDelta",
    value: function handleLocusDelta(locus, meeting) {
      var _this3 = this;

      // register a function to process delta actions
      if (!this.locusParser.onDeltaAction) {
        // delta action, along with associated loci
        // is passed into the function.
        this.locusParser.onDeltaAction = function (action, parsedLoci) {
          _this3.applyLocusDeltaData(action, parsedLoci, meeting);
        };
      } // queue delta event with parser


      this.locusParser.onDeltaEvent(locus);
    }
    /**
     * @param {Locus} locus
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "init",
    value: function init() {
      var locus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.created = locus.created || null;
      this.scheduledMeeting = locus.meeting || null;
      this.participantsUrl = locus.participantsUrl || null;
      this.replaces = locus.replaces || null;
      this.aclUrl = locus.aclUrl || null;
      this.baseSequence = locus.baseSequence || null;
      this.sequence = locus.sequence || null;
      this.membership = locus.membership || null;
      this.identities = locus.identities || null;
      this.participants = locus.participants || null;
      /**
       * Stores the delta values for a changed participant.
       *
       * @typedef {Object} DeltaParticipant
       * @property {Record<string, boolean>} delta - Contains changed streams.
       * @property {Object} person - Contains person data.
       */

      /**
       * Stored participant changes between the last event and the current event.
       * All previously stored events are overwritten between events.
       *
       * @instance
       * @type {Array<DeltaParticipant>}
       * @private
       * @member LocusInfo
       */

      this.deltaParticipants = []; // above section only updates the locusInfo object
      // The below section makes sure it updates the locusInfo as well as updates the meeting object

      this.updateParticipants(locus.participants); // For 1:1 space meeting the conversation Url does not exist in locus.conversation

      this.updateConversationUrl(locus.conversationUrl, locus.info);
      this.updateControls(locus.controls);
      this.updateLocusUrl(locus.url);
      this.updateFullState(locus.fullState);
      this.updateMeetingInfo(locus.info); // self and participants generate sipUrl for 1:1 meeting

      this.updateSelf(locus.self, locus.participants);
      this.updateHostInfo(locus.host);
      this.updateMediaShares(locus.mediaShares);
    }
    /**
     * @param {Object} locus
     * @param {Meeting} meeting
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "initialSetup",
    value: function initialSetup(locus, meeting) {
      // meeting already exisits just do an update
      if (meeting) {
        // Its a new delta event fetch the whole meeting object
        this.locusParser.onDeltaEvent(locus);
      } else {
        this.onFullLocus(locus);
      } // Change it to true after it recives it first locus object


      this.emitChange = true;
    }
    /**
     * @param {Meeting} meeting
     * @param {Object} data
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "parse",
    value: function parse(meeting, data) {
      var eventType = data.eventType;

      _loggerProxy.default.logger.info("Locus-info:index#parse --> received locus data: ".concat(eventType));

      switch (eventType) {
        case _constants.LOCUSEVENT.PARTICIPANT_JOIN:
        case _constants.LOCUSEVENT.PARTICIPANT_LEFT:
        case _constants.LOCUSEVENT.CONTROLS_UPDATED:
        case _constants.LOCUSEVENT.PARTICIPANT_AUDIO_MUTED:
        case _constants.LOCUSEVENT.PARTICIPANT_AUDIO_UNMUTED:
        case _constants.LOCUSEVENT.PARTICIPANT_VIDEO_MUTED:
        case _constants.LOCUSEVENT.PARTICIPANT_VIDEO_UNMUTED:
        case _constants.LOCUSEVENT.SELF_CHANGED:
        case _constants.LOCUSEVENT.PARTICIPANT_UPDATED:
        case _constants.LOCUSEVENT.PARTICIPANT_CONTROLS_UPDATED:
        case _constants.LOCUSEVENT.PARTICIPANT_ROLES_UPDATED:
        case _constants.LOCUSEVENT.PARTICIPANT_DECLINED:
        case _constants.LOCUSEVENT.FLOOR_GRANTED:
        case _constants.LOCUSEVENT.FLOOR_RELEASED:
          this.onFullLocus(data.locus, eventType);
          break;

        case _constants.LOCUSEVENT.DIFFERENCE:
          this.handleLocusDelta(data.locus, meeting);
          break;

        default:
          // Why will there be a event with no eventType ????
          // we may not need this, we can get full locus
          this.handleLocusDelta(data.locus, meeting);
      }
    }
    /**
     * @param {String} scope
     * @param {String} eventName
     * @param {Array} args
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "emitScoped",
    value: function emitScoped(scope, eventName, args) {
      return this.emit(scope, eventName, args);
    }
    /**
     * updates the locus with full locus object
     * @param {object} locus locus object
     * @param {sting} eventType particulat locus event
     * @returns {object} null
     * @memberof LocusInfo
     */

  }, {
    key: "onFullLocus",
    value: function onFullLocus(locus, eventType) {
      if (!locus) {
        _loggerProxy.default.logger.error('Locus-info:index#onFullLocus --> object passed as argument was invalid, continuing.');
      }

      this.updateParticipantDeltas(locus.participants);
      this.scheduledMeeting = locus.meeting || null;
      this.participants = locus.participants;
      this.updateLocusInfo(locus);
      this.updateParticipants(locus.participants);
      this.isMeetingActive();
      this.handleOneOnOneEvent(eventType); // set current (working copy) for parser

      this.locusParser.workingCopy = locus;
    } // used for ringing stops on one on one

    /**
     * @param {String} eventType
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "handleOneOnOneEvent",
    value: function handleOneOnOneEvent(eventType) {
      if (this.parsedLocus.fullState.type === _constants._CALL_) {
        // for 1:1 bob calls alice and alice declines, notify the meeting state
        if (eventType === _constants.LOCUSEVENT.PARTICIPANT_DECLINED) {
          // trigger the event for stop ringing
          this.emitScoped({
            file: 'locus-info',
            function: 'handleOneonOneEvent'
          }, _constants.EVENTS.REMOTE_RESPONSE, {
            remoteDeclined: true,
            remoteAnswered: false
          });
        } // for 1:1 bob calls alice and alice answers, notify the meeting state


        if (eventType === _constants.LOCUSEVENT.PARTICIPANT_JOIN) {
          // trigger the event for stop ringing
          this.emitScoped({
            file: 'locus-info',
            function: 'handleOneonOneEvent'
          }, _constants.EVENTS.REMOTE_RESPONSE, {
            remoteDeclined: false,
            remoteAnswered: true
          });
        }
      }
    }
    /**
     * @param {Object} locus
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "onDeltaLocus",
    value: function onDeltaLocus(locus) {
      this.updateLocusInfo(locus);
      this.updateParticipants(locus.participants);
      this.isMeetingActive();
    }
    /**
     * @param {Object} locus
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "updateLocusInfo",
    value: function updateLocusInfo(locus) {
      this.updateControls(locus.controls);
      this.updateConversationUrl(locus.conversationUrl, locus.info);
      this.updateCreated(locus.created);
      this.updateFullState(locus.fullState);
      this.updateHostInfo(locus.host);
      this.updateMeetingInfo(locus.info, locus.self);
      this.updateMediaShares(locus.mediaShares);
      this.updateParticipantsUrl(locus.participantsUrl);
      this.updateReplace(locus.replace);
      this.updateSelf(locus.self, locus.participants);
      this.updateLocusUrl(locus.url);
      this.updateAclUrl(locus.aclUrl);
      this.updateBasequence(locus.baseSequence);
      this.updateSequence(locus.sequence);
      this.updateMemberShip(locus.membership);
      this.updateIdentifiers(locus.identities);
      this.compareAndUpdate(); // update which required to compare different objects from locus
    }
    /**
     * @param {Array} participants
     * @param {Object} self
     * @returns {Array}
     * @memberof LocusInfo
     */

  }, {
    key: "getLocusPartner",
    value: function getLocusPartner(participants, self) {
      if (!participants || participants.length === 0) {
        return null;
      }

      return participants.find(function (participant) {
        return self && participant.identity !== self.identity && (participants.length <= 2 || participant.type === _constants._USER_ && !participant.removed);
      }) || this.partner;
    } // TODO: all the leave states need to be checked

    /**
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "isMeetingActive",
    value: function isMeetingActive() {
      if (this.parsedLocus.fullState.type === _constants._CALL_ || this.parsedLocus.fullState.type === _constants._SIP_BRIDGE_) {
        var partner = this.getLocusPartner(this.participants, this.self);
        this.updateMeeting({
          partner: partner
        }); // Check if guest user needs to be checked here
        // 1) when bob declines call from bob, (bob='DECLINED')
        // 2) When alice rejects call to bob , (bob='NOTIFIED')
        // When we dont add MEDIA for condition 2. The state of bob='IDLE'

        if (this.fullState && this.fullState.state === _constants.LOCUS.STATE.INACTIVE) {
          // TODO: update the meeting state
          _loggerProxy.default.logger.warn('Locus-info:index#isMeetingActive --> Call Ended, locus state is inactive.');

          _metrics.default.postEvent({
            event: _config.eventType.REMOTE_ENDED,
            meetingId: this.meetingId
          });

          this.emitScoped({
            file: 'locus-info',
            function: 'isMeetingActive'
          }, _constants.EVENTS.DESTROY_MEETING, {
            reason: _constants.CALL_REMOVED_REASON.CALL_INACTIVE,
            shouldLeave: false
          });
        } else if (partner.state === _constants.MEETING_STATE.STATES.LEFT && this.parsedLocus.self && (this.parsedLocus.self.state === _constants.MEETING_STATE.STATES.DECLINED || this.parsedLocus.self.state === _constants.MEETING_STATE.STATES.NOTIFIED || this.parsedLocus.self.state === _constants.MEETING_STATE.STATES.JOINED)) {
          _metrics.default.postEvent({
            event: _config.eventType.REMOTE_ENDED,
            meetingId: this.meetingId
          });

          this.emitScoped({
            file: 'locus-info',
            function: 'isMeetingActive'
          }, _constants.EVENTS.DESTROY_MEETING, {
            reason: _constants.CALL_REMOVED_REASON.PARTNER_LEFT,
            shouldLeave: this.parsedLocus.self.joinedWith && this.parsedLocus.self.joinedWith.state !== _constants._LEFT_
          });
        } else if (this.parsedLocus.self && this.parsedLocus.self.state === _constants.MEETING_STATE.STATES.LEFT && (partner.state === _constants.MEETING_STATE.STATES.LEFT || partner.state === _constants.MEETING_STATE.STATES.DECLINED || partner.state === _constants.MEETING_STATE.STATES.NOTIFIED || partner.state === _constants.MEETING_STATE.STATES.IDLE) // Happens when user just joins and adds no Media
        ) {
            _metrics.default.postEvent({
              event: _config.eventType.REMOTE_ENDED,
              meetingId: this.meetingId
            });

            this.emitScoped({
              file: 'locus-info',
              function: 'isMeetingActive'
            }, _constants.EVENTS.DESTROY_MEETING, {
              reason: _constants.CALL_REMOVED_REASON.SELF_LEFT,
              shouldLeave: false
            });
          }
      } else if (this.parsedLocus.fullState.type === _constants._MEETING_) {
        if (this.fullState && (this.fullState.state === _constants.LOCUS.STATE.INACTIVE || this.fullState.state === _constants.LOCUS.STATE.TERMINATING)) {
          _loggerProxy.default.logger.warn('Locus-info:index#isMeetingActive --> Meeting is ending due to inactive or terminating');

          _metrics.default.postEvent({
            event: _config.eventType.REMOTE_ENDED,
            meetingId: this.meetingId
          });

          this.emitScoped({
            file: 'locus-info',
            function: 'isMeetingActive'
          }, _constants.EVENTS.DESTROY_MEETING, {
            reason: _constants.MEETING_REMOVED_REASON.MEETING_INACTIVE_TERMINATING,
            shouldLeave: false
          });
        } else if (this.fullState && this.fullState.removed) {
          // user has been dropped from a meeting
          _metrics.default.postEvent({
            event: _config.eventType.REMOTE_ENDED,
            meetingId: this.meetingId
          });

          this.emitScoped({
            file: 'locus-info',
            function: 'isMeetingActive'
          }, _constants.EVENTS.DESTROY_MEETING, {
            reason: _constants.MEETING_REMOVED_REASON.FULLSTATE_REMOVED,
            shouldLeave: false
          });
        } // If you are  guest and you are removed from the meeting
        // You wont get any further events
        else if (this.parsedLocus.self && this.parsedLocus.self.removed) {
            // Check if we need to send an event
            this.emitScoped({
              file: 'locus-info',
              function: 'isMeetingActive'
            }, _constants.EVENTS.DESTROY_MEETING, {
              reason: _constants.MEETING_REMOVED_REASON.SELF_REMOVED,
              shouldLeave: false
            });
          }
      } else {
        _loggerProxy.default.logger.warn('Locus-info:index#isMeetingActive --> Meeting Type is unknown.');
      }
    }
    /**
     * checks if the host permissions have changed while in the meeting
     * This would be the case if your role as host or moderator has been updated
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "compareAndUpdate",
    value: function compareAndUpdate() {
      // TODO: check with locus team on host and moderator doc
      // use host as a validator if needed
      if (this.compareAndUpdateFlags.compareSelfAndHost || this.compareAndUpdateFlags.compareHostAndSelf) {
        this.compareSelfAndHost();
      }
    }
    /**
     * compared the self object to check if the user has host permissions
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "compareSelfAndHost",
    value: function compareSelfAndHost() {
      var _this$parsedLocus$hos;

      // In some cases the host info is not present but the moderator values changes from null to false so it triggers an update
      if (this.parsedLocus.self.selfIdentity === ((_this$parsedLocus$hos = this.parsedLocus.host) === null || _this$parsedLocus$hos === void 0 ? void 0 : _this$parsedLocus$hos.hostId) && this.parsedLocus.self.moderator) {
        this.emitScoped({
          file: 'locus-info',
          function: 'compareSelfAndHost'
        }, _constants.EVENTS.LOCUS_INFO_CAN_ASSIGN_HOST, {
          canAssignHost: true
        });
      } else {
        this.emitScoped({
          file: 'locus-info',
          function: 'compareSelfAndHost'
        }, _constants.EVENTS.LOCUS_INFO_CAN_ASSIGN_HOST, {
          canAssignHost: false
        });
      }
    }
    /**
     * Update the deltaParticipants property of this object based on a list of
     * provided participants.
     *
     * @param {Array} [participants] - The participants to update against.
     * @returns {void}
     */

  }, {
    key: "updateParticipantDeltas",
    value: function updateParticipantDeltas() {
      var _this4 = this;

      var participants = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      // Used to find a participant within a participants collection.
      var findParticipant = function findParticipant(participant, collection) {
        return collection.find(function (item) {
          return item.person.id === participant.person.id;
        });
      }; // Generates an object that indicates which state properties have changed.


      var generateDelta = function generateDelta() {
        var prevState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var newState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        // Setup deltas.
        var deltas = {
          audioStatus: prevState.audioStatus !== newState.audioStatus,
          videoSlidesStatus: prevState.videoSlidesStatus !== newState.videoSlidesStatus,
          videoStatus: prevState.videoStatus !== newState.videoStatus
        }; // Clean the object

        (0, _keys.default)(deltas).forEach(function (key) {
          if (deltas[key] !== true) {
            delete deltas[key];
          }
        });
        return deltas;
      };

      this.deltaParticipants = participants.reduce(function (collection, participant) {
        var existingParticipant = findParticipant(participant, _this4.participants || []) || {};
        var delta = generateDelta(existingParticipant.status, participant.status);
        var changed = (0, _keys.default)(delta).length > 0;

        if (changed) {
          collection.push({
            person: participant.person,
            delta: delta
          });
        }

        return collection;
      }, []);
    }
    /**
     *
     * @param {Object} participants new participants object
     * @param {boolen} deltaParticpantFlag  delta event
     * @returns {Array} updatedParticipants
     * @memberof LocusInfo
     */

  }, {
    key: "updateParticipants",
    value: function updateParticipants(participants) {
      this.emitScoped({
        file: 'locus-info',
        function: 'updateParticipants'
      }, _constants.EVENTS.LOCUS_INFO_UPDATE_PARTICIPANTS, {
        participants: participants,
        recordingId: this.parsedLocus.controls && this.parsedLocus.controls.modifiedBy,
        selfIdentity: this.parsedLocus.self && this.parsedLocus.self.selfIdentity,
        selfId: this.parsedLocus.self && this.parsedLocus.self.selfId,
        hostId: this.parsedLocus.host && this.parsedLocus.host.hostId
      });
    }
    /**
     * @param {Object} controls
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "updateControls",
    value: function updateControls(controls) {
      if (controls && !(0, _isEqual2.default)(this.controls, controls)) {
        this.parsedLocus.controls = _controlsUtils.default.parse(controls);

        var _ControlsUtils$getCon = _controlsUtils.default.getControls(this.controls, controls),
            _ControlsUtils$getCon2 = _ControlsUtils$getCon.updates,
            hasRecordingChanged = _ControlsUtils$getCon2.hasRecordingChanged,
            hasRecordingPausedChanged = _ControlsUtils$getCon2.hasRecordingPausedChanged,
            current = _ControlsUtils$getCon.current;

        if (hasRecordingChanged || hasRecordingPausedChanged) {
          var state = null;

          if (hasRecordingPausedChanged) {
            if (current.record.paused) {
              state = _constants.RECORDING_STATE.PAUSED;
            } else {
              // state will be `IDLE` if the recording is not active, even when there is a `pause` status change.
              state = current.record.recording ? _constants.RECORDING_STATE.RESUMED : _constants.RECORDING_STATE.IDLE;
            }
          } else if (hasRecordingChanged) {
            state = current.record.recording ? _constants.RECORDING_STATE.RECORDING : _constants.RECORDING_STATE.IDLE;
          }

          this.emitScoped({
            file: 'locus-info',
            function: 'updateControls'
          }, _constants.LOCUSINFO.EVENTS.CONTROLS_RECORDING_UPDATED, {
            state: state,
            modifiedBy: current.record.modifiedBy,
            lastModified: current.record.lastModified
          });
        }

        this.controls = controls;
      }
    }
    /**
     * @param {String} conversationUrl
     * @param {Object} info
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "updateConversationUrl",
    value: function updateConversationUrl(conversationUrl, info) {
      if (conversationUrl && !(0, _isEqual2.default)(this.conversationUrl, conversationUrl)) {
        this.conversationUrl = conversationUrl;
        this.updateMeeting({
          conversationUrl: conversationUrl
        });
      } else if (info && info.conversationUrl && !(0, _isEqual2.default)(this.conversationUrl, info.conversationUrl)) {
        this.conversationUrl = info.conversationUrl;
        this.updateMeeting({
          conversationUrl: info.conversationUrl
        });
      }
    }
    /**
     * @param {Object} created
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "updateCreated",
    value: function updateCreated(created) {
      if (created && !(0, _isEqual2.default)(this.created, created)) {
        this.created = created;
      }
    }
    /**
     * @param {Object} fullState
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "updateFullState",
    value: function updateFullState(fullState) {
      if (fullState && !(0, _isEqual2.default)(this.fullState, fullState)) {
        var result = _fullState.default.getFullState(this.fullState, fullState);

        this.updateMeeting(result.current);

        if (result.updates.meetingStateChangedTo) {
          this.emitScoped({
            file: 'locus-info',
            function: 'updateFullState'
          }, _constants.LOCUSINFO.EVENTS.FULL_STATE_MEETING_STATE_CHANGE, {
            previousState: result.previous && result.previous.meetingState,
            currentState: result.current.meetingState
          });
        }

        if (result.updates.meetingTypeChangedTo) {
          this.emitScoped({
            file: 'locus-info',
            function: 'updateFullState'
          }, _constants.LOCUSINFO.EVENTS.FULL_STATE_TYPE_UPDATE, {
            type: result.current.type
          });
        }

        this.parsedLocus.fullState = result.current;
        this.fullState = fullState;
      }
    }
    /**
     * handles when the locus.host is updated
     * @param {Object} host the locus.host property
     * @returns {undefined}
     * @memberof LocusInfo
     * emits internal event locus_info_update_host
     */

  }, {
    key: "updateHostInfo",
    value: function updateHostInfo(host) {
      if (host && !(0, _isEqual2.default)(this.host, host)) {
        var parsedHosts = _hostUtils.default.getHosts(this.host, host);

        this.updateMeeting(parsedHosts.current);
        this.parsedLocus.host = parsedHosts.current;

        if (parsedHosts.updates.isNewHost) {
          this.compareAndUpdateFlags.compareSelfAndHost = true;
          this.emitScoped({
            file: 'locus-info',
            function: 'updateHostInfo'
          }, _constants.EVENTS.LOCUS_INFO_UPDATE_HOST, {
            newHost: parsedHosts.current,
            oldHost: parsedHosts.previous
          });
        }

        this.host = host;
      } else {
        this.compareAndUpdateFlags.compareSelfAndHost = false;
      }
    }
    /**
     * @param {Object} info
     * @param {Object} self
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "updateMeetingInfo",
    value: function updateMeetingInfo(info, self) {
      if (info && (!(0, _isEqual2.default)(this.info, info) || !(0, _isEqual2.default)(_infoUtils.default.parsePolicy(info), _infoUtils.default.parsePolicy(this.info)) || !(0, _isEqual2.default)(_infoUtils.default.parseModerator(info) || _infoUtils.default.parseModerator(info)))) {
        var parsedInfo = _infoUtils.default.getInfos(this.parsedLocus.info, info);

        this.emitScoped({
          file: 'locus-info',
          function: 'updateMeetingInfo'
        }, _constants.LOCUSINFO.EVENTS.MEETING_INFO_UPDATED, {
          info: parsedInfo.current,
          self: self
        });

        if (parsedInfo.updates.isLocked) {
          this.emitScoped({
            file: 'locus-info',
            function: 'updateMeetingInfo'
          }, _constants.LOCUSINFO.EVENTS.MEETING_LOCKED, info);
        }

        if (parsedInfo.updates.isUnlocked) {
          this.emitScoped({
            file: 'locus-info',
            function: 'updateMeetingInfo'
          }, _constants.LOCUSINFO.EVENTS.MEETING_UNLOCKED, info);
        }

        this.info = info;
        this.parsedLocus.info = parsedInfo.current; // Parses the info and adds necessary values

        this.updateMeeting(parsedInfo.current);
      }
    }
    /**
     * handles when the locus.mediaShares is updated
     * @param {Object} mediaShares the locus.mediaShares property
     * @returns {undefined}
     * @memberof LocusInfo
     * emits internal event locus_info_update_media_shares
     */

  }, {
    key: "updateMediaShares",
    value: function updateMediaShares(mediaShares) {
      if (mediaShares && !(0, _isEqual2.default)(this.mediaShares, mediaShares)) {
        var parsedMediaShares = _mediaSharesUtils.default.getMediaShares(this.mediaShares, mediaShares);

        this.updateMeeting(parsedMediaShares.current);
        this.emitScoped({
          file: 'locus-info',
          function: 'updateMediaShares'
        }, _constants.EVENTS.LOCUS_INFO_UPDATE_MEDIA_SHARES, {
          current: parsedMediaShares.current,
          previous: parsedMediaShares.previous
        });
        this.parsedLocus.mediaShares = parsedMediaShares.current;
        this.mediaShares = mediaShares;
      }
    }
    /**
     * @param {String} participantsUrl
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "updateParticipantsUrl",
    value: function updateParticipantsUrl(participantsUrl) {
      if (participantsUrl && !(0, _isEqual2.default)(this.participantsUrl, participantsUrl)) {
        this.participantsUrl = participantsUrl;
      }
    }
    /**
     * @param {Object} replace
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "updateReplace",
    value: function updateReplace(replace) {
      if (replace && !(0, _isEqual2.default)(this.replace, replace)) {
        this.replace = replace;
      }
    }
    /**
     * handles when the locus.self is updated
     * @param {Object} self the locus.mediaShares property
     * @param {Array} participants the locus.participants property
     * @returns {undefined}
     * @memberof LocusInfo
     * emits internal events self_admitted_guest, self_unadmitted_guest, locus_info_update_self
     */

  }, {
    key: "updateSelf",
    value: function updateSelf(self, participants) {
      if (self && !(0, _isEqual2.default)(this.self, self)) {
        var parsedSelves = _selfUtils.default.getSelves(this.self, self, this.webex.internal.device.url);

        this.updateMeeting(parsedSelves.current);
        this.parsedLocus.self = parsedSelves.current;
        var element = this.parsedLocus.states[this.parsedLocus.states.length - 1];

        if (element !== parsedSelves.current.state) {
          this.parsedLocus.states.push(parsedSelves.current.state);
        } // TODO: check if we need to save the sipUri here as well
        // this.emit(LOCUSINFO.EVENTS.MEETING_UPDATE, SelfUtils.getSipUrl(this.getLocusPartner(participants, self), this.parsedLocus.fullState.type, this.parsedLocus.info.sipUri));


        var result = _selfUtils.default.getSipUrl(this.getLocusPartner(participants, self), this.parsedLocus.fullState.type, this.parsedLocus.info.sipUri);

        if (result.sipUri) {
          this.updateMeeting(result);
        }

        if (parsedSelves.updates.moderatorChanged) {
          this.compareAndUpdateFlags.compareHostAndSelf = true;
        } else {
          this.compareAndUpdateFlags.compareHostAndSelf = false;
        }

        if (parsedSelves.updates.isMediaInactiveOrReleased) {
          this.emitScoped({
            file: 'locus-info',
            function: 'updateSelf'
          }, _constants.LOCUSINFO.EVENTS.DISCONNECT_DUE_TO_INACTIVITY, {
            reason: self.reason
          });
        }

        if (parsedSelves.updates.moderatorChanged) {
          this.emitScoped({
            file: 'locus-info',
            function: 'updateSelf'
          }, _constants.LOCUSINFO.EVENTS.SELF_MODERATOR_CHANGED, self);
        }

        if (parsedSelves.updates.localAudioUnmuteRequiredByServer) {
          this.emitScoped({
            file: 'locus-info',
            function: 'updateSelf'
          }, _constants.LOCUSINFO.EVENTS.LOCAL_UNMUTE_REQUIRED, {
            muted: parsedSelves.current.remoteMuted,
            unmuteAllowed: parsedSelves.current.unmuteAllowed
          });
        }

        if (parsedSelves.updates.isMutedByOthersChanged) {
          this.emitScoped({
            file: 'locus-info',
            function: 'updateSelf'
          }, _constants.LOCUSINFO.EVENTS.SELF_REMOTE_MUTE_STATUS_UPDATED, {
            muted: parsedSelves.current.remoteMuted,
            unmuteAllowed: parsedSelves.current.unmuteAllowed
          });
        }

        if (parsedSelves.updates.localAudioUnmuteRequestedByServer) {
          this.emitScoped({
            file: 'locus-info',
            function: 'updateSelf'
          }, _constants.LOCUSINFO.EVENTS.LOCAL_UNMUTE_REQUESTED, {});
        }

        if (parsedSelves.updates.isUnadmittedGuest) {
          this.emitScoped({
            file: 'locus-info',
            function: 'updateSelf'
          }, _constants.LOCUSINFO.EVENTS.SELF_UNADMITTED_GUEST, self);
        }

        if (parsedSelves.updates.isAdmittedGuest) {
          this.emitScoped({
            file: 'locus-info',
            function: 'updateSelf'
          }, _constants.LOCUSINFO.EVENTS.SELF_ADMITTED_GUEST, self);
        }

        if (parsedSelves.updates.isMediaInactive) {
          this.emitScoped({
            file: 'locus-info',
            function: 'updateSelf'
          }, _constants.LOCUSINFO.EVENTS.MEDIA_INACTIVITY, _selfUtils.default.getMediaStatus(self.mediaSessions));
        }

        if (parsedSelves.updates.audioStateChange || parsedSelves.updates.videoStateChange || parsedSelves.updates.shareStateChange) {
          var _parsedSelves$current, _parsedSelves$current2, _parsedSelves$current3;

          this.emitScoped({
            file: 'locus-info',
            function: 'updateSelf'
          }, _constants.LOCUSINFO.EVENTS.MEDIA_STATUS_CHANGE, {
            audioStatus: (_parsedSelves$current = parsedSelves.current.currentMediaStatus) === null || _parsedSelves$current === void 0 ? void 0 : _parsedSelves$current.audio,
            videoStatus: (_parsedSelves$current2 = parsedSelves.current.currentMediaStatus) === null || _parsedSelves$current2 === void 0 ? void 0 : _parsedSelves$current2.video,
            shareStatus: (_parsedSelves$current3 = parsedSelves.current.currentMediaStatus) === null || _parsedSelves$current3 === void 0 ? void 0 : _parsedSelves$current3.share
          });
        }

        this.emitScoped({
          file: 'locus-info',
          function: 'updateSelf'
        }, _constants.EVENTS.LOCUS_INFO_UPDATE_SELF, {
          oldSelf: parsedSelves.previous,
          newSelf: parsedSelves.current
        });
        this.parsedLocus.self = parsedSelves.current;
        this.self = self;
      } else {
        this.compareAndUpdateFlags.compareHostAndSelf = false;
      }
    }
    /**
     * handles when the locus.url is updated
     * @param {String} url
     * @returns {undefined}
     * emits internal event locus_info_update_url
     */

  }, {
    key: "updateLocusUrl",
    value: function updateLocusUrl(url) {
      if (url && this.url !== url) {
        this.url = url;
        this.updateMeeting({
          locusUrl: url
        });
        this.emitScoped({
          file: 'locus-info',
          function: 'updateLocusUrl'
        }, _constants.EVENTS.LOCUS_INFO_UPDATE_URL, url);
      }
    }
    /**
     * @param {String} aclUrl
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "updateAclUrl",
    value: function updateAclUrl(aclUrl) {
      if (aclUrl && !(0, _isEqual2.default)(this.aclUrl, aclUrl)) {
        this.aclUrl = aclUrl;
      }
    }
    /**
     * @param {Number} baseSequence
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "updateBasequence",
    value: function updateBasequence(baseSequence) {
      if (baseSequence && !(0, _isEqual2.default)(this.baseSequence, baseSequence)) {
        this.baseSequence = baseSequence;
      }
    }
    /**
     * @param {Number} sequence
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "updateSequence",
    value: function updateSequence(sequence) {
      if (sequence && !(0, _isEqual2.default)(this.sequence, sequence)) {
        this.sequence = sequence;
      }
    }
    /**
     * @param {Object} membership
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "updateMemberShip",
    value: function updateMemberShip(membership) {
      if (membership && !(0, _isEqual2.default)(this.membership, membership)) {
        this.membership = membership;
      }
    }
    /**
     * @param {Array} identities
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: "updateIdentifiers",
    value: function updateIdentifiers(identities) {
      if (identities && !(0, _isEqual2.default)(this.identities, identities)) {
        this.identities = identities;
      }
    }
  }]);
  return LocusInfo;
}(_eventsScope.default);

exports.default = LocusInfo;
//# sourceMappingURL=index.js.map
