{"version":3,"sources":["parser.js"],"names":["Parser","queue","SimpleQueue","status","IDLE","onDeltaAction","workingCopy","newLoci","isValid","isLoci","setStatus","LoggerProxy","logger","info","PAUSED","size","processDeltaEvent","action","locus","loci","enqueue","WORKING","DESYNC","USE_INCOMING","extract","extractComparisonState","dequeue","isValidLocus","result","compare","lociComparison","debug","pause","call","nextEvent","current","incoming","comparison","min","max","GT","LT","currentIsNotUnique","unique","length","incomingIsNotUnique","currentTotalRange","end","incomingTotalRange","EQ","currentIsUnique","incomingIsUnique","currentUniqueMin","incomingUniqueMin","currentHasNoRange","start","incomingHasNoRange","neitherSeqHasRange","hasUniqOverlap","list","some","seq","currentUniqOverlap","incomingUniqOverlap","debugInfo","isSequenceEmpty","pack","packComparisonResult","baseSequence","compareDelta","compareSequence","sequence","compareToAction","local","getMetaData","delta","getUniqueSequences","rules","checkSequenceOverlap","checkUnequalRanges","checkForUniqueEntries","checkIfOutOfSync","rule","ERROR","USE_CURRENT","lociComparisonResult","split","entries","first","last","slice","rangeStart","rangeEnd","baseLoci","otherLoci","diff","getNumbersOutOfRange","output","filter","num","sort","a","b","hasEmptyEntries","hasEmptyRange","hasProp","prop","Object","prototype","hasOwnProperty","newData","oldData","debugCode","mStr","strings","join","replace","resolutionMap","debugMap","SO001","title","description","logic","SO002","UR001","UR002","UR003","UE001","UE002","OOS001","OOS002","OOS003","debugObj","resolution"],"mappings":"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","sourcesContent":["import {difference} from 'lodash';\n\nimport SimpleQueue from '../common/queue';\nimport LoggerProxy from '../common/logs/logger-proxy';\n\n/**\n * Locus Delta Parser\n * @private\n * https://sqbu-github.cisco.com/WebExSquared/cloud-apps/wiki/Locus-Delta-Events\n */\nexport default class Parser {\n  // processing status\n  static status = {\n    IDLE: 'IDLE',\n    PAUSED: 'PAUSED',\n    WORKING: 'WORKING'\n  }\n\n  // loci comparison states\n  static loci = {\n    EQ: 'EQUAL',\n    GT: 'GREATER_THAN',\n    LT: 'LESS_THAN',\n    DESYNC: 'DESYNC',\n    USE_INCOMING: 'USE_INCOMING',\n    USE_CURRENT: 'USE_CURRENT',\n    ERROR: 'ERROR'\n  }\n\n\n  /**\n   * @constructs Parser\n   */\n  constructor() {\n    this.queue = new SimpleQueue();\n    this.status = Parser.status.IDLE;\n    this.onDeltaAction = null;\n    this.workingCopy = null;\n  }\n\n\n  /**\n   * Checks if two sequences overlap in time,\n   * the sequence with the higher minimum value is greater.\n   * Chooses sequence with most recent data.\n   * @param {Types~Locus} current\n   * @param {Types~Locus} incoming\n   * @returns {string} loci comparison state\n   */\n  static checkSequenceOverlap(current, incoming) {\n    let comparison = null;\n\n    // if earliest working copy sequence is more recent than last incoming sequence\n    if (current.min > incoming.max) {\n      // choose left side (current)\n      comparison = `${Parser.loci.GT}:SO001`;\n    }\n    // if last working copy sequence is before the earliest incoming sequence\n    else if (current.max < incoming.min) {\n      // choose right side (incoming)\n      comparison = `${Parser.loci.LT}:SO002`;\n    }\n\n    // if no match above, defaults to null\n    return comparison;\n  }\n\n\n  /**\n   * Checks if two sequences have unequal ranges.\n   * Chooses sequence with most larger range.\n   * @param {Types~Locus} current\n   * @param {Types~Locus} incoming\n   * @returns {object} loci comparison\n   */\n  static checkUnequalRanges(current, incoming) {\n    let comparison = null;\n    const currentIsNotUnique = current.unique.length === 0;\n    const incomingIsNotUnique = incoming.unique.length === 0;\n    const currentTotalRange = current.end - current.min;\n    const incomingTotalRange = incoming.end - incoming.min;\n\n    // no unique values for both loci\n    if (currentIsNotUnique && incomingIsNotUnique) {\n      // current working copy loci has a larger range\n      if (currentTotalRange > incomingTotalRange) {\n        // choose left side (current)\n        comparison = `${Parser.loci.GT}:UR001`;\n      }\n      // incoming delta loci has a larger range\n      else if (currentTotalRange < incomingTotalRange) {\n        // choose right side (incoming)\n        comparison = `${Parser.loci.LT}:UR002`;\n      }\n      else {\n        // with no unique entries and with ranges either absent or\n        // of the same size, the sequences are considered equal.\n        comparison = `${Parser.loci.EQ}:UR003`;\n      }\n    }\n\n    return comparison;\n  }\n\n\n  /**\n   * Checks if either sequences has unique entries.\n   * Entries are considered unique if they do not overlap\n   * with other Loci sequences or range values.\n   * Chooses sequence with the unique entries.\n   * @param {Types~Locus} current\n   * @param {Types~Locus} incoming\n   * @returns {string} loci comparison state\n   */\n  static checkForUniqueEntries(current, incoming) {\n    let comparison = null;\n    const currentIsUnique = current.unique.length > 0;\n    const incomingIsUnique = incoming.unique.length > 0;\n\n    // current has unique entries and incoming does not\n    if (currentIsUnique && !incomingIsUnique) {\n      // choose left side (current)\n      comparison = `${Parser.loci.GT}:UE001`;\n    }\n    // current has no unique entries but incoming does\n    else if (!currentIsUnique && incomingIsUnique) {\n      // choose right side (incoming)\n      comparison = `${Parser.loci.LT}:UE002`;\n    }\n\n    return comparison;\n  }\n\n\n  /**\n   * Checks both Locus Delta objects to see if they are\n   * out of sync with one another. If so sends a DESYNC\n   * request to the server.\n   * @param {Types~Locus} current\n   * @param {Types~Locus} incoming\n   * @returns {string} loci comparison state\n   */\n  static checkIfOutOfSync(current, incoming) {\n    let comparison = null;\n    const currentUniqueMin = current.unique[0];\n    const incomingUniqueMin = incoming.unique[0];\n\n    const currentHasNoRange = !current.start && !current.end;\n    const incomingHasNoRange = !incoming.start && !incoming.end;\n    const neitherSeqHasRange = currentHasNoRange && incomingHasNoRange;\n\n    const hasUniqOverlap = (list, min, max) => list.some((seq) => min < seq && seq < max);\n    // current unique entries overlap the total range of incoming\n    const currentUniqOverlap = hasUniqOverlap(current.unique, incoming.min, incoming.max);\n    // vice-versa, incoming unique entries overlap the total range of current\n    const incomingUniqOverlap = hasUniqOverlap(incoming.unique, current.min, current.max);\n\n    if (neitherSeqHasRange || currentUniqOverlap || incomingUniqOverlap) {\n      // outputs string indicating which condition occurred. ex: 0,1,0\n      const debugInfo = `${+neitherSeqHasRange},${+currentUniqOverlap},${+incomingUniqOverlap}`;\n\n      // send DESYNC to server\n      comparison = `${Parser.loci.DESYNC}:OOS001:${debugInfo}`;\n    }\n    else if (currentUniqueMin > incomingUniqueMin) {\n      // choose left side (current)\n      comparison = `${Parser.loci.GT}:OOS002`;\n    }\n    else {\n      // choose right side (incoming)\n      comparison = `${Parser.loci.LT}:OOS003`;\n    }\n\n    return comparison;\n  }\n\n\n  /**\n   * Compares two loci to determine which one contains the most recent state\n   * @instance\n   * @memberof Locus\n   * @param {Types~Locus} current\n   * @param {Types~Locus} incoming\n   * @returns {string} loci comparison state\n   */\n  static compare(current, incoming) {\n    const {isSequenceEmpty} = Parser;\n    const {extractComparisonState: extract} = Parser;\n    const {packComparisonResult: pack} = Parser;\n\n\n    if (isSequenceEmpty(current) || isSequenceEmpty(incoming)) {\n      return pack(Parser.loci.USE_INCOMING, 'C001');\n    }\n\n    if (incoming.baseSequence) {\n      return pack(Parser.compareDelta(current, incoming), 'C002');\n    }\n\n    const result = Parser.compareSequence(current.sequence, incoming.sequence);\n    const action = Parser.compareToAction(extract(result));\n\n    return pack(action, result);\n  }\n\n\n  /**\n   * Compares two loci sequences (with delta params) and indicates what action\n   * to take.\n   * @instance\n   * @memberof Locus\n   * @param {Types~Locus} current\n   * @param {Types~Locus} incoming\n   * @private\n   * @returns {string} loci comparison state\n   */\n  static compareDelta(current, incoming) {\n    const {\n      LT, GT, EQ, DESYNC, USE_INCOMING\n    } = Parser.loci;\n    const {extractComparisonState: extract} = Parser;\n    const {packComparisonResult: pack} = Parser;\n\n    const result = Parser.compareSequence(current.sequence, incoming.sequence);\n    let comparison = extract(result);\n\n\n    if (comparison !== LT) {\n      return pack(Parser.compareToAction(comparison), result);\n    }\n\n    comparison = Parser.compareSequence(current.sequence, incoming.baseSequence);\n\n    switch (extract(comparison)) {\n      case GT:\n      case EQ:\n        comparison = USE_INCOMING;\n        break;\n\n      default:\n        comparison = DESYNC;\n    }\n\n    return pack(comparison, result);\n  }\n\n\n  /**\n   * Compares Locus sequences\n   * @param {Types~Locus} current Current working copy\n   * @param {Types~Locus} incoming New Locus delta\n   * @returns {string}\n   */\n  static compareSequence(current, incoming) {\n    // Locus sequence comparison rules in order of priority.\n    // https://sqbu-github.cisco.com/WebExSquared/cloud-apps/wiki/Locus-Sequence-Comparison-Algorithm\n\n    const local = Parser.getMetaData(current);\n    const delta = Parser.getMetaData(incoming);\n\n    // update loci metadata\n    local.unique = Parser.getUniqueSequences(local, delta);\n    delta.unique = Parser.getUniqueSequences(delta, local);\n\n    // Locus sequence comparison rules\n    // order matters\n    const rules = [\n      Parser.checkSequenceOverlap,\n      Parser.checkUnequalRanges,\n      Parser.checkForUniqueEntries,\n      Parser.checkIfOutOfSync\n    ];\n\n    for (const rule of rules) {\n      // Rule only returns a value if the rule applies,\n      // otherwise returns null.\n      const result = rule(local, delta);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    // error, none of rules above applied\n    // should never get here as last rule\n    // should be catch all.\n    return Parser.loci.ERROR;\n  }\n\n\n  /**\n   * Transates the result of a sequence comparison into an intended behavior\n   * @param {string} result\n   * @returns {string} Locus comparison action\n   */\n  static compareToAction(result) {\n    const {\n      DESYNC, EQ, ERROR, GT, LT, USE_CURRENT, USE_INCOMING\n    } = Parser.loci;\n\n    let action = ERROR;\n\n    switch (result) {\n      case EQ:\n      case GT:\n        action = USE_CURRENT;\n        break;\n      case LT:\n        action = USE_INCOMING;\n        break;\n      case DESYNC:\n        action = DESYNC;\n        break;\n      default:\n        LoggerProxy.logger.info(`Locus-info:parser#compareToAction --> Error: ${result} is not a recognized sequence comparison result.`);\n    }\n\n    return action;\n  }\n\n\n  /**\n   * Extracts a loci comparison from a string of data.\n   * @param {string} lociComparisonResult Comparison result with extra data\n   * @returns {string} Comparison of EQ, LT, GT, or DESYNC.\n   */\n  static extractComparisonState(lociComparisonResult) {\n    return lociComparisonResult.split(':')[0];\n  }\n\n\n  /**\n   * @typedef {object} LociMetadata\n   * @property {number} start - Starting sequence number\n   * @property {number} end - Ending sequence number\n   * @property {number} first - First sequence number\n   * @property {number} last - Last sequence number\n   * @property {number} min - Minimum sequence number\n   * @property {number} max - Maximum sequence number\n   * @property {number} entries - Loci sequence entries\n   */\n\n  /**\n   * Metadata for Locus delta\n   * @param {Array.<number>} sequence Locus delta sequence\n   * @returns {LociMetadata} Locus Delta Metadata\n   */\n  static getMetaData(sequence) {\n    const {entries} = sequence;\n    const first = entries[0];\n    const last = entries.slice(-1)[0];\n\n    // rangeStart or rangeEnd is 0 if a range doesn't exist\n    const start = sequence.rangeStart;\n    const end = sequence.rangeEnd;\n\n    // sequence data\n    return {\n      start,\n      end,\n      first,\n      last,\n      // Rule is: rangeStart <= rangeEnd <= min(entries)\n      min: start || first,\n      // Grab last entry if exist else default to rangeEnd\n      max: last || end,\n      // keep reference to actual sequence entries\n      entries\n    };\n  }\n\n\n  /**\n   * Compares two Locus delta objects and notes unique\n   * values contained within baseLoci.\n   * @param {LociMetadata} baseLoci\n   * @param {LociMetadata} otherLoci\n   * @returns {Array.<number>} List of unique sequences\n   */\n  static getUniqueSequences(baseLoci, otherLoci) {\n    const diff = difference(\n      baseLoci.entries,\n      otherLoci.entries\n    );\n    const {start, end} = otherLoci;\n\n    return Parser.getNumbersOutOfRange(diff, start, end);\n  }\n\n\n  /**\n   * Returns an array of numbers outside of a given range.\n   * @param {Array.<number>} list Array to filter\n   * @param {number} rangeStart Start of range\n   * @param {number} rangeEnd End of range\n   * @returns {Array.<number>} Array of numbers sorted ASC\n   */\n  static getNumbersOutOfRange(list, rangeStart, rangeEnd) {\n    // Collect all numbers if number is outside of specified range\n    const output = list.filter((num) => num < rangeStart || num > rangeEnd);\n\n    // sort ascending\n    return output.sort((a, b) => a - b);\n  }\n\n\n  /**\n   * Checks if newLoci or workingCopy is invalid.\n   * @param {Types~Locus} newLoci\n   * @returns {boolean}\n   */\n  isValidLocus(newLoci) {\n    let isValid = false;\n    const {IDLE} = Parser.status;\n    const {isLoci} = Parser;\n    const setStatus = (status) => { this.status = status; };\n\n    // one or both objects are not locus delta events\n    if (!isLoci(this.workingCopy) || !isLoci(newLoci)) {\n      setStatus(IDLE);\n      LoggerProxy.logger.info('Locus-info:parser#processDeltaEvent --> Ignoring non-locus object. workingCopy:', this.workingCopy, 'newLoci:', newLoci);\n    }\n    else {\n      isValid = true;\n    }\n\n    return isValid;\n  }\n\n\n  /**\n   * Determines if a paricular locus's sequence is empty\n   * @param {Types~Locus} locus\n   * @returns {bool}\n   */\n  static isSequenceEmpty(locus) {\n    const {sequence} = locus;\n    const hasEmptyEntries = !sequence.entries?.length;\n    const hasEmptyRange = sequence.rangeStart === 0 && sequence.rangeEnd === 0;\n\n    return hasEmptyEntries && hasEmptyRange;\n  }\n\n\n  /**\n   * Determines if an object has basic\n   * structure of a locus object.\n   * @param {Types~Locus} loci\n   * @returns {boolean}\n   */\n  static isLoci(loci) {\n    if (!loci || !loci.sequence) {\n      return false;\n    }\n    const hasProp = (prop) =>\n      Object.prototype.hasOwnProperty.call(loci.sequence, prop);\n\n    if (hasProp('rangeStart') && hasProp('rangeEnd')) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Processes next event in queue,\n   * if queue is empty sets status to idle.\n   * @returns {undefined}\n   */\n  nextEvent() {\n    if (this.status === Parser.status.PAUSED) {\n      LoggerProxy.logger.info('Locus-info:parser#nextEvent --> Locus parser paused.');\n\n      return;\n    }\n\n    // continue processing until queue is empty\n    if (this.queue.size() > 0) {\n      this.processDeltaEvent();\n    }\n    else {\n      this.status = Parser.status.IDLE;\n    }\n  }\n\n\n  /**\n   * Function handler for delta actions,\n   * is set by instance callee.\n   * @param {string} action Locus delta action\n   * @param {Types~Locus} locus Locus delta\n   * @returns {undefined}\n   */\n  // eslint-disable-next-line no-unused-vars\n  onDeltaAction(action, locus) {}\n\n\n  /**\n   * Event handler for locus delta events\n   * @param {Types~Locus} loci Locus Delta\n   * @returns {undefined}\n   */\n  onDeltaEvent(loci) {\n    // enqueue the new loci\n    this.queue.enqueue(loci);\n    // start processing events in the queue if idle\n    // and a function handler is defined\n    if (this.status === Parser.status.IDLE && this.onDeltaAction) {\n      // Update status, ensure we only process one event at a time.\n      this.status = Parser.status.WORKING;\n\n      this.processDeltaEvent();\n    }\n  }\n\n\n  /**\n   * Appends new data onto a string of existing data.\n   * @param {string} newData\n   * @param {string} oldData\n   * @returns {string}\n   */\n  static packComparisonResult(newData, oldData) {\n    return `${newData}:${oldData}`;\n  }\n\n\n  /**\n   * Pause locus processing\n   * @returns {undefined}\n   */\n  pause() {\n    this.status = Parser.status.PAUSED;\n    LoggerProxy.logger.info('Locus-info:parser#pause --> Locus parser paused.');\n  }\n\n\n  /**\n   * Processes next locus delta in the queue,\n   * continues until the queue is empty\n   * or cleared.\n   * @returns {undefined}\n   */\n  processDeltaEvent() {\n    const {DESYNC, USE_INCOMING} = Parser.loci;\n    const {extractComparisonState: extract} = Parser;\n    const newLoci = this.queue.dequeue();\n\n    if (!this.isValidLocus(newLoci)) {\n      return;\n    }\n\n    const result = Parser.compare(this.workingCopy, newLoci);\n    const lociComparison = extract(result);\n\n    // limited debugging, use chrome extension\n    // for full debugging.\n    LoggerProxy.logger.debug(`Locus-info:parser#processDeltaEvent --> Locus Debug: ${result}`);\n\n    if (lociComparison === DESYNC) {\n      // wait for desync response\n      this.pause();\n    }\n    else if (lociComparison === USE_INCOMING) {\n      // update working copy for future comparisons.\n      // Note: The working copy of parser gets updated in .onFullLocus()\n      // and here when USE_INCOMING locus.\n      this.workingCopy = newLoci;\n    }\n\n    if (this.onDeltaAction) {\n      LoggerProxy.logger.info(`Locus-info:parser#processDeltaEvent --> Locus Delta Action: ${lociComparison}`);\n      this.onDeltaAction.call(this, lociComparison, newLoci);\n    }\n\n    this.nextEvent();\n  }\n\n\n  /**\n   * Resume from a paused state\n   * @returns {undefined}\n   */\n  resume() {\n    LoggerProxy.logger.info('Locus-info:parser#resume --> Locus parser resumed.');\n    this.status = Parser.status.WORKING;\n    this.nextEvent();\n  }\n\n\n  /**\n   * Gets related debug info for given error code\n   * @param {string} debugCode Debug code\n   * @param {string} comparison Locus comparison string\n   * @returns {object} Debug message\n   */\n  static getDebugMessage(debugCode, comparison) {\n    // removes extra spaces from multiline string\n    const mStr = (strings) => strings.join('').replace(/\\s{2,}/g, ' ');\n\n    const resolutionMap = {\n      EQ: `${Parser.loci.LT}: is equal (current == incoming).`,\n      LT: `${Parser.loci.LT}: choose right side (incoming).`,\n      GT: `${Parser.loci.GT}: choose left side (current).`\n    };\n\n    const debugMap = {\n      SO001: {\n        title: 'checkSequenceOverlap-001',\n        description: mStr`Occurs if earliest working copy sequence is more \\\n            recent than last incoming sequence.`,\n        logic: 'current.min > incoming.max'\n      },\n\n      SO002: {\n        title: 'checkSequenceOverlap-002',\n        description: mStr`Occurs if last working copy sequence is before the \\\n          earliest incoming sequence.`,\n        logic: 'current.max < incoming.min'\n      },\n\n      UR001: {\n        title: 'checkUnequalRanges-001',\n        description: mStr`Occurs if there are no unique values for both loci, \\\n          and the current working copy loci has a larger range.`,\n        logic: 'currentTotalRange > incomingTotalRange'\n      },\n\n      UR002: {\n        title: 'checkUnequalRanges-002',\n        description: mStr`Occurs if there are no unique values for both loci, \\\n          and the incoming delta loci has a larger range.`,\n        logic: 'currentTotalRange < incomingTotalRange'\n      },\n\n      UR003: {\n        title: 'checkUnequalRanges-003',\n        description: mStr`Occurs if there are no unique values for both loci, \\\n          and with ranges either absent or of the same size, the sequences \\\n          are considered equal.`,\n        logic: 'currentTotalRange == incomingTotalRange'\n      },\n\n      UE001: {\n        title: 'checkForUniqueEntries-001',\n        description: mStr`Occurs if current loci has unique entries and \\\n          incoming does not. Entries are considered unique if they \\\n          do not overlap with other Loci sequences or range values.`,\n        logic: 'currentIsUnique && !incomingIsUnique'\n      },\n\n      UE002: {\n        title: 'checkForUniqueEntries-002',\n        description: mStr`Occurs if current has no unique entries but \\\n          incoming does. Entries are considered unique if they \\\n          do not overlap with other Loci sequences or range values.`,\n        logic: '!currentIsUnique && incomingIsUnique'\n      },\n\n      OOS001: {\n        title: 'checkIfOutOfSync-001',\n        description: mStr`Occurs if neither sequence has a range, or \\\n          if the current loci unique entries overlap the total range of the \\\n          incoming sequence, or if the incoming unique entries overlap \\\n          the total range of current sequence.`,\n        logic: 'neitherSeqHasRange || currentUniqOverlap || incomingUniqOverlap'\n      },\n\n      OOS002: {\n        title: 'checkIfOutOfSync-002',\n        description: mStr`Occurs if the minimum value from sequences that are \\\n          unique to the current loci is greater than the minimum value from \\\n          sequences that are unique to the incoming loci.`,\n        logic: 'currentUniqueMin > incomingUniqueMin'\n      },\n\n      OOS003: {\n        title: 'checkIfOutOfSync-003',\n        description: mStr`Occurs if none of the comparison rules applied. \\\n          It is a catch all.`,\n        logic: 'else (catch all)'\n      }\n    };\n\n    const debugObj = debugMap[debugCode];\n\n    debugObj.title = `Debug: ${debugObj.title}`;\n    debugObj.resolution = resolutionMap[comparison];\n\n    return debugObj;\n  }\n}\n"]}