{"version":3,"sources":["controlsUtils.js"],"names":["ControlsUtils","parse","controls","parsedControls","record","modifiedBy","getId","paused","recording","lastModified","meta","getControls","oldControls","newControls","previous","current","updates","hasRecordingPausedChanged","hasRecordingChanged"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,aAAa,GAAG,EAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACAA,aAAa,CAACC,KAAd,GAAsB,UAACC,QAAD,EAAc;AAClC,MAAMC,cAAc,qBAAOD,QAAP,CAApB;;AAEA,MAAIA,QAAQ,IAAIA,QAAQ,CAACE,MAAzB,EAAiC;AAC/BD,IAAAA,cAAc,CAACC,MAAf,GAAwB;AACtBC,MAAAA,UAAU,EAAEL,aAAa,CAACM,KAAd,CAAoBJ,QAApB,CADU;AAEtBK,MAAAA,MAAM,EAAEL,QAAQ,CAACE,MAAT,CAAgBG,MAAhB,GAAyBL,QAAQ,CAACE,MAAT,CAAgBG,MAAzC,GAAkD,KAFpC;AAGtBC,MAAAA,SAAS,EAAEN,QAAQ,CAACE,MAAT,CAAgBI,SAHL;AAItBC,MAAAA,YAAY,EAAEP,QAAQ,CAACE,MAAT,CAAgBM,IAAhB,CAAqBD;AAJb,KAAxB;AAMD;;AAED,SAAON,cAAP;AACD,CAbD;AAeA;AACA;AACA;AACA;AACA;AACA;;;AACAH,aAAa,CAACW,WAAd,GAA4B,UAACC,WAAD,EAAcC,WAAd,EAA8B;AAAA;;AACxD,MAAMC,QAAQ,GAAGd,aAAa,CAACC,KAAd,CAAoBW,WAApB,CAAjB;AACA,MAAMG,OAAO,GAAGf,aAAa,CAACC,KAAd,CAAoBY,WAApB,CAAhB;AAEA,SAAO;AACLC,IAAAA,QAAQ,EAARA,QADK;AAELC,IAAAA,OAAO,EAAPA,OAFK;AAGLC,IAAAA,OAAO,EAAE;AACPC,MAAAA,yBAAyB,EAAE,CAAAF,OAAO,SAAP,IAAAA,OAAO,WAAP,YAAAA,OAAO,CAAEX,MAAT,KAAmB,CAAC,uBAC7CU,QAD6C,aAC7CA,QAD6C,2CAC7CA,QAAQ,CAAEV,MADmC,qDAC7C,iBAAkBG,MAD2B,EACnBQ,OAAO,CAACX,MAAR,CAAeG,MADI,CADxC;AAIPW,MAAAA,mBAAmB,EAAE,CAAAH,OAAO,SAAP,IAAAA,OAAO,WAAP,YAAAA,OAAO,CAAEX,MAAT,KAAmB,CAAC,uBACvCU,QADuC,aACvCA,QADuC,4CACvCA,QAAQ,CAAEV,MAD6B,sDACvC,kBAAkBI,SADqB,EACVO,OADU,aACVA,OADU,0CACVA,OAAO,CAAEX,MADC,oDACV,gBAAiBI,SADP;AAJlC;AAHJ,GAAP;AAYD,CAhBD;AAkBA;AACA;AACA;AACA;AACA;;;AACAR,aAAa,CAACM,KAAd,GAAsB,UAACJ,QAAD,EAAc;AAClC,MAAIA,QAAQ,CAACE,MAAT,CAAgBM,IAApB,EAA0B;AACxB,WAAOR,QAAQ,CAACE,MAAT,CAAgBM,IAAhB,CAAqBL,UAA5B;AACD;;AAED,SAAO,IAAP;AACD,CAND;;eAQeL,a","sourcesContent":["import {isEqual} from 'lodash';\n\nconst ControlsUtils = {};\n\n/**\n * Controls\n * @typedef {Object} LocusControls\n * @property {Object} record\n * @property {Boolean} record.recording\n * @property {Object} record.meta\n * @property {String} record.meta.modifiedBy\n */\n\n/**\n * parse the relevant host values that we care about: id\n * @param {LocusControls} controls\n * @returns {Object} parsedObject - parsed host or null if host was undefined\n * @returns {String} parsedObject.recordingId\n */\nControlsUtils.parse = (controls) => {\n  const parsedControls = {...controls};\n\n  if (controls && controls.record) {\n    parsedControls.record = {\n      modifiedBy: ControlsUtils.getId(controls),\n      paused: controls.record.paused ? controls.record.paused : false,\n      recording: controls.record.recording,\n      lastModified: controls.record.meta.lastModified\n    };\n  }\n\n  return parsedControls;\n};\n\n/**\n * parses and returns previous state vs current state and triggers the changes.\n * @param {LocusControl} oldControls previous state\n * @param {LocusControl} newControls current state\n * @returns {Object} combination of state plus the changes\n */\nControlsUtils.getControls = (oldControls, newControls) => {\n  const previous = ControlsUtils.parse(oldControls);\n  const current = ControlsUtils.parse(newControls);\n\n  return {\n    previous,\n    current,\n    updates: {\n      hasRecordingPausedChanged: current?.record && !isEqual(\n        previous?.record?.paused, current.record.paused\n      ),\n      hasRecordingChanged: current?.record && !isEqual(\n        previous?.record?.recording, current?.record?.recording\n      )\n    }\n  };\n};\n\n/**\n * Extract the id from the record controls object\n * @param {LocusControls} controls\n * @returns {String|null}\n */\nControlsUtils.getId = (controls) => {\n  if (controls.record.meta) {\n    return controls.record.meta.modifiedBy;\n  }\n\n  return null;\n};\n\nexport default ControlsUtils;\n"]}