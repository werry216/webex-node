"use strict";

var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");

var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _values = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/values"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _includes2 = _interopRequireDefault(require("lodash/includes"));

var _util = _interopRequireDefault(require("util"));

var _uuid = _interopRequireDefault(require("uuid"));

var _window = _interopRequireDefault(require("global/window"));

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _constants = require("../constants");

var _config = _interopRequireDefault(require("../common/config"));

var _browserDetection = _interopRequireDefault(require("../common/browser-detection"));

var _config2 = require("./config");

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

var OSMap = {
  'Chrome OS': _config2.OS_NAME.chrome,
  macOS: _config2.OS_NAME.MAC,
  Windows: _config2.OS_NAME.WINDOWS,
  iOS: _config2.OS_NAME.IOS,
  Android: _config2.OS_NAME.ANDROID,
  Linux: _config2.OS_NAME.LINUX
};

var _BrowserDetection = (0, _browserDetection.default)(),
    getOSName = _BrowserDetection.getOSName,
    getOSVersion = _BrowserDetection.getOSVersion,
    getBrowserName = _BrowserDetection.getBrowserName,
    getBrowserVersion = _BrowserDetection.getBrowserVersion;
/**
 * @description Metrics handles all the call metrics events
 * @export
 * @class Metrics
 */


var Metrics = /*#__PURE__*/function () {
  /**
     * Create Metrics Object
     * @constructor
     * @public
     * @memberof Meetings
     */
  function Metrics() {
    (0, _classCallCheck2.default)(this, Metrics);

    if (!Metrics.instance) {
      /**
       * @instance
       * @type {Array}
       * @private
       * @memberof Metrics
       */
      this._events = [];
      /**
      * @instance
      * @type {MeetingCollection}
      * @private
      * @memberof Metrics
      */

      this.meetingCollection = null;
      /**
      * @instance
      * @type {MeetingCollection}
      * @private
      * @memberof Metrics
      */

      this.keys = (0, _values.default)(_config2.eventType);
      /**
       * @instance
       * @type {Metrics}
       * @private
       * @memberof Metrics
       */

      Metrics.instance = this;
    }

    return Metrics.instance;
  }
  /**
   * Initializes the Metrics singleton with a meeting Collection.
   *
   * @param {Object} meetingCollection meetings object
   * @param {Object} webex  webex SDK object
   *
   * @returns {void}
   */


  (0, _createClass2.default)(Metrics, [{
    key: "initialSetup",
    value: function initialSetup(meetingCollection, webex) {
      this.meetingCollection = meetingCollection;
      this.webex = webex;
    }
    /**
     * poste Meeting event metrics
     * @param {object} options {meetingId/meeting} as a json object
     * @param {Meeting} options.meeting Meeting object
     * @param {String} options.meetingId
     * @param {object} options.data
     * @param {object} options.event
     * @returns {object} null
     */

  }, {
    key: "postEvent",
    value: function postEvent(options) {
      var meetingId = options.meetingId,
          _options$data = options.data,
          data = _options$data === void 0 ? {} : _options$data,
          event = options.event;
      var meeting = options.meeting;

      if (this.keys.indexOf(event) === -1) {
        _loggerProxy.default.logger.error("Metrics:index#postEvent --> Event ".concat(event, " doesn't exist in dictionary"));
      }

      if (!meeting && meetingId) {
        meeting = this.meetingCollection.get(meetingId);
      }

      if (meeting) {
        if (!meeting.callEvents) {
          meeting.callEvents = [];
        }

        if (event === _config2.eventType.MEDIA_QUALITY) {
          data.event = event;
          meeting.sendMediaQualityAnalyzerMetrics(data);
        } else {
          meeting.callEvents.push(event);
          data.event = event;
          meeting.sendCallAnalyzerMetrics(data);
        }
      } else {
        _loggerProxy.default.logger.info("Metrics:index#postEvent --> Event received for meetingId:".concat(meetingId, ", but meeting not found in collection."));
      }
    }
    /**
     *  Docs for Call analyzer metrics
    *   https://sqbu-github.cisco.com/WebExSquared/call-analyzer/wiki
    *   https://sqbu-github.cisco.com/WebExSquared/event-dictionary/blob/master/diagnostic-events.raml
    */

  }, {
    key: "initPayload",
    value: function initPayload(eventType, identifiers, options) {
      var _this$webex$meetings$;

      var payload = {
        eventId: _uuid.default.v4(),
        version: 1,
        origin: {
          buildType: 'prod',
          name: 'endpoint',
          networkType: 'unknown',
          userAgent: this.userAgentToString(),
          clientInfo: {
            clientType: options.clientType,
            clientVersion: "".concat(_config2.CLIENT_NAME, "/").concat(this.webex.version),
            osVersion: getOSVersion() || 'unknown',
            subClientType: options.subClientType,
            os: this.getOsName(),
            browser: getBrowserName(),
            browserVersion: getBrowserVersion()
          }
        },
        originTime: {
          triggered: new Date().toISOString()
        },
        senderCountryCode: (_this$webex$meetings$ = this.webex.meetings.geoHintInfo) === null || _this$webex$meetings$ === void 0 ? void 0 : _this$webex$meetings$.countryCode,
        event: {
          name: eventType,
          canProceed: true,
          identifiers: identifiers,
          eventData: {
            webClientDomain: _window.default.location.hostname
          }
        }
      }; // TODO: more options should be checked and some of them should be mandatory in certain conditions

      if (options) {
        if (Object.prototype.hasOwnProperty.call(options, 'canProceed')) {
          payload.event.canProceed = options.canProceed;
        }

        if (options.errors) {
          payload.event.errors = options.errors;
        }

        if (options.mediaType) {
          payload.event.mediaType = options.mediaType;
        }

        if (options.trigger) {
          payload.event.trigger = options.trigger;
        }

        if (options.pstnAudioType) {
          payload.event.pstnAudioType = options.pstnAudioType;
        }

        if (options.mediaCapabilities) {
          payload.event.mediaCapabilities = options.mediaCapabilities;
        }

        if (options.recoveredBy) {
          payload.event.recoveredBy = options.recoveredBy;
        }
      }

      return payload;
    }
    /**
     * returns metrics friendly OS versions
     * @param {String} osName Os name
     * @returns {String}
     * @private
     * @memberof Metrics
     */

  }, {
    key: "getOsName",
    value: function getOsName() {
      var _OSMap$getOSName;

      return (_OSMap$getOSName = OSMap[getOSName()]) !== null && _OSMap$getOSName !== void 0 ? _OSMap$getOSName : _config2.OS_NAME.OTHERS;
    }
    /**
     * get the payload specific for a media quality event through call analyzer
     * @param {String} eventType the event name
     * @param {Object} identifiers contains the identifiers needed for CA
     * @param {String} identifiers.correlationId
     * @param {String} identifiers.locusUrl
     * @param {String} identifiers.locusId
     * @param {Object} options
     * @param {Object} options.intervalData
     * @param {String} options.clientType
     * @returns {Object}
     * @public
     * @memberof Metrics
     */

  }, {
    key: "initMediaPayload",
    value: function initMediaPayload(eventType, identifiers, options) {
      var _this$webex$meetings$2;

      var payload = {
        eventId: _uuid.default.v4(),
        version: 1,
        origin: {
          buildType: 'prod',
          name: 'endpoint',
          networkType: options.networkType || _config2.UNKNOWN,
          userAgent: this.userAgentToString(),
          clientInfo: {
            clientType: options.clientType,
            // TODO: Only clientType: 'TEAMS_CLIENT' is whitelisted
            clientVersion: "".concat(_config2.CLIENT_NAME, "/").concat(this.webex.version),
            os: this.getOsName(),
            osVersion: getOSVersion() || _config2.UNKNOWN,
            subClientType: options.subClientType,
            browser: getBrowserName(),
            browserVersion: getBrowserVersion()
          }
        },
        originTime: {
          triggered: new Date().toISOString()
        },
        senderCountryCode: (_this$webex$meetings$2 = this.webex.meetings.geoHintInfo) === null || _this$webex$meetings$2 === void 0 ? void 0 : _this$webex$meetings$2.countryCode,
        event: {
          name: eventType,
          canProceed: true,
          identifiers: identifiers,
          intervals: [options.intervalData],
          eventData: {
            webClientDomain: _window.default.location.hostname
          },
          sourceMetadata: {
            applicationSoftwareType: _config2.CLIENT_NAME,
            applicationSoftwareVersion: this.webex.version,
            mediaEngineSoftwareType: getBrowserName() || 'browser',
            mediaEngineSoftwareVersion: getOSVersion() || _config2.UNKNOWN,
            startTime: new Date().toISOString()
          }
        }
      };
      return payload;
    }
    /**
     * This function Parses a Locus error and returns a diagnostic event payload.
     * It should keep updating from:
     * https://sqbu-github.cisco.com/WebExSquared/spark-client-framework/blob/master/spark-client-framework/Adapters/TelephonyAdapter/TelephonyAdapter.cpp#L920
     *
     * @param {Object} err the error Object from Locus response
     * @param {boolean} showToUser true if a toast is shown to user
     * @returns {{showToUser: boolean, category: string, errorDescription: string,
     *  errorCode: number, errorData: *, fatal: boolean, name: string}}
     */

  }, {
    key: "parseLocusError",
    value: function parseLocusError(err, showToUser) {
      var errorCode;

      if (err && err.body && err.body.errorCode) {
        switch (_config2.errorCodes[err.body.errorCode]) {
          case _constants.MEETING_ERRORS.FREE_USER_MAX_PARTICIPANTS_EXCEEDED:
            errorCode = 3007;
            break;

          case _constants.MEETING_ERRORS.PAID_USER_MAX_PARTICIPANTS_EXCEEDED:
          case _constants.MEETING_ERRORS.SERVICE_MAX_PARTICIPANTS_EXCEEDED:
            errorCode = 3002;
            break;

          case _constants.MEETING_ERRORS.INACTIVE:
            errorCode = 4001;
            break;

          case _constants.MEETING_ERRORS.EXCEEDED_MAX_JOINED_PARTICIPANTS:
          case _constants.MEETING_ERRORS.EXCEEDED_SERVICE_MAX_PARTICIPANTS:
            errorCode = 3001;
            break;

          case _constants.MEETING_ERRORS.MEETING_IS_LOCKED:
            errorCode = 4002;
            break;

          case _constants.MEETING_ERRORS.MEETING_IS_TERMINATING:
            errorCode = 4003;
            break;

          case _constants.MEETING_ERRORS.MEETING_REQUIRE_MODERATOR_PIN_INTENT:
            errorCode = 4004;
            break;

          case _constants.MEETING_ERRORS.MEETING_REQUIRE_MODERATOR_PIN:
            errorCode = 4005;
            break;

          case _constants.MEETING_ERRORS.MEETING_REQUIRE_MODERATOR_ROLE:
            errorCode = 4006;
            break;

          case _constants.MEETING_ERRORS.JOIN_RESTRICTED_USER:
          case _constants.MEETING_ERRORS.GET_RESTRICTED_USER:
          case _constants.MEETING_ERRORS.CREATE_MEDIA_RESTRICTED_USER:
            errorCode = 3005;
            break;

          case _constants.MEETING_ERRORS.JOIN_RESTRICTED_USER_NOT_IN_ROOM:
            errorCode = 4007;
            break;

          case _constants.MEETING_ERRORS.MEETING_NOT_FOUND:
            errorCode = 4011;
            break;

          case _constants.MEETING_ERRORS.NOT_WEBEX_SITE:
            errorCode = 4012;
            break;

          case _constants.MEETING_ERRORS.INVALID_JOIN_TIME:
            errorCode = 4013;
            break;

          case _constants.MEETING_ERRORS.PHONE_NUMBER_NOT_A_NUMBER:
            errorCode = 4016;
            break;

          case _constants.MEETING_ERRORS.PHONE_NUMBER_TOO_LONG:
            errorCode = 4017;
            break;

          case _constants.MEETING_ERRORS.INVALID_DIALABLE_KEY:
            errorCode = 4018;
            break;

          case _constants.MEETING_ERRORS.ONE_ON_ONE_TO_SELF_NOT_ALLOWED:
            errorCode = 4019;
            break;

          case _constants.MEETING_ERRORS.REMOVED_PARTICIPANT:
            errorCode = 4020;
            break;

          case _constants.MEETING_ERRORS.MEETING_LINK_NOT_FOUND:
            errorCode = 4021;
            break;

          case _constants.MEETING_ERRORS.PHONE_NUMBER_TOO_SHORT_AFTER_IDD:
            errorCode = 4022;
            break;

          case _constants.MEETING_ERRORS.INVALID_INVITEE_ADDRESS:
            errorCode = 4023;
            break;

          case _constants.MEETING_ERRORS.PMR_ACCOUNT_LOCKED:
            errorCode = 4024;
            break;

          case _constants.MEETING_ERRORS.RESOURCE_GUEST_FORBIDDEN:
            errorCode = 4025;
            break;

          case _constants.MEETING_ERRORS.PMR_ACCOUNT_SUSPENDED:
            errorCode = 4026;
            break;

          case _constants.MEETING_ERRORS.EMPTY_PHONE_NUMBER_OR_COUNTRY_CODE:
            errorCode = 4027;
            break;

          case _constants.MEETING_ERRORS.INVALID_SINCE_OR_SEQUENCE_HASH_IN_REQUEST:
            errorCode = 1006;
            break;

          case _constants.MEETING_ERRORS.CONVERSATION_NOT_FOUND:
            errorCode = 4028;
            break;

          case _constants.MEETING_ERRORS.RECORDING_CONTROL_NOT_SUPPORTED:
          case _constants.MEETING_ERRORS.RECORDING_NOT_STARTED:
          case _constants.MEETING_ERRORS.RECORDING_NOT_ENABLED:
            errorCode = 4029;
            break;

          default:
            errorCode = 4008;
        }
      } else {
        errorCode = 4008;
      }

      return this.generateErrorPayload(errorCode, showToUser, _config2.error.name.LOCUS_RESPONSE, err);
    }
  }, {
    key: "generateErrorPayload",
    value: function generateErrorPayload(errorCode, shownToUser, name, err) {
      if (_config2.error.errors[errorCode]) {
        var errorPayload = {
          shownToUser: shownToUser || false,
          category: _config2.error.errors[errorCode][2],
          errorDescription: _config2.error.errors[errorCode][0],
          errorCode: errorCode,
          fatal: !(0, _includes2.default)(_config2.error.notFatalErrorList, errorCode),
          name: name || _config2.error.name.OTHER
        };

        if (err && err.body) {
          errorPayload.errorData = err.body;
        }

        return errorPayload;
      }

      return null;
    }
    /**
     * Returns a formated string of the user agent.
     *
     * @returns {string} formatted user agent information
     */

  }, {
    key: "userAgentToString",
    value: function userAgentToString() {
      var userAgentOption;
      var browserInfo;

      var clientInfo = _util.default.format('client=%s', "".concat(_config.default.meetings.metrics.clientName));

      if (['chrome', 'firefox', 'msie', 'msedge', 'safari'].indexOf(getBrowserName().toLowerCase()) !== -1) {
        browserInfo = _util.default.format('browser=%s', "".concat(getBrowserName().toLowerCase(), "/").concat(getBrowserVersion().split('.')[0]));
      }

      var osInfo = _util.default.format('os=%s', "".concat(getOSName(), "/").concat(getOSVersion().split('.')[0]));

      if (browserInfo) {
        userAgentOption = "(".concat(browserInfo);
      }

      if (osInfo) {
        userAgentOption = userAgentOption ? "".concat(userAgentOption, "; ").concat(clientInfo, "; ").concat(osInfo) : "".concat(clientInfo, "; (").concat(osInfo);
      }

      if (userAgentOption) {
        userAgentOption += ')';
        return _util.default.format('webex-js-sdk/%s %s', "".concat(process.env.NODE_ENV, "-").concat(this.webex.version), userAgentOption);
      }

      return _util.default.format('webex-js-sdk/%s', "".concat(process.env.NODE_ENV, "-").concat(this.webex.version));
    }
    /**
     * Uploads given metric to the Metrics service as an operational metric.
     * Metadata about the environment such as browser, OS, SDK and their versions
     * are automatically added when the metric is sent.
     *
     * The Metrics service will send an operational metric to InfluxDB for
     * aggregation.
     * See https://confluence-eng-gpk2.cisco.com/conf/display/WBXT/Getting+started+with+Metrics+Service.
     *
     * @param {string} metricName  Name of the metric (measurement) to send
     * @param {Object} metricFields  Key-valye pairs of data or values about this metric
     * @param {Object} metricTags  Key-value pairs of metric metadata
     *
     * @returns {void}
     */

  }, {
    key: "sendOperationalMetric",
    value: function sendOperationalMetric(metricName) {
      var metricFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var metricTags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var fields = _objectSpread(_objectSpread({}, metricFields), {}, {
        browser_version: getBrowserVersion(),
        os_version: getOSVersion(),
        sdk_version: this.webex.version
      });

      var tags = _objectSpread(_objectSpread({}, metricTags), {}, {
        browser: getBrowserName(),
        org_id: this.webex.credentials.getOrgId(),
        os: getOSName(),
        domain: _window.default.location.hostname,
        client_id: this.webex.credentials.config.client_id
      });

      if (!metricName) {
        throw Error('Missing operational metric name. Please provide one');
      }

      this.webex.internal.metrics.submitClientMetrics(metricName, {
        type: ['operational'],
        fields: fields,
        tags: tags
      });
    }
  }]);
  return Metrics;
}(); // Export Metrics singleton ---------------------------------------------------


var instance = new Metrics();
var _default = instance;
exports.default = _default;
//# sourceMappingURL=index.js.map
