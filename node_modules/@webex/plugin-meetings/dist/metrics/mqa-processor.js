"use strict";

var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");

var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _constants = require("../constants");

var _browserDetection = _interopRequireDefault(require("../common/browser-detection"));

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

var _BrowserDetection = (0, _browserDetection.default)(),
    isBrowser = _BrowserDetection.isBrowser;
/**
 * @description MQAProcessor handles interval data for MQA
 * @export
 * @class MQAProcessor
 */


var MQAProcessor = /*#__PURE__*/function () {
  /**
     * @constructor
     * @public
     * @memberof MQAProcessor
     */
  function MQAProcessor() {
    (0, _classCallCheck2.default)(this, MQAProcessor);
    this.data = {
      videoReceive: [],
      audioTransmit: [],
      audioReceive: [],
      videoTransmit: []
    };
    this.intervalNumber = 1;
  }
  /**
   * @param {String} id
   * @param {Array<WebRTCData>} interval - a slice of metrics history
   * @returns {undefined}
   * @memberof MQAProcessor
   */


  (0, _createClass2.default)(MQAProcessor, [{
    key: "process",
    value: function process(id, interval) {
      var rtcCandidatePair, rtcOutVideo, rtpOutVideo; // TODO: , rtcInVideo, rtpInVideo, rtcOutAudio, rtcInAudio, rtpInAudio, rtpOutAudio; // TODO:

      var vsTransmit;
      var _this$data = this.data,
          videoReceive = _this$data.videoReceive,
          audioTransmit = _this$data.audioTransmit,
          audioReceive = _this$data.audioReceive,
          videoTransmit = _this$data.videoTransmit;
      var sumValue = interval[0]; // the head is the last interval value, webRTC spec has some values automatically summed

      if (sumValue) {
        rtcCandidatePair = sumValue.rtcCandidatePair;
      }

      switch (id) {
        case _constants.STATS.AUDIO_SENDER_ID:
          audioTransmit.push();
          break;

        case _constants.STATS.AUDIO_RECEIVER_ID:
          audioReceive.push();
          break;

        case _constants.STATS.VIDEO_SENDER_ID:
          videoTransmit.push();
          break;

        case _constants.STATS.VIDEO_RECEIVER_ID:
          videoReceive.push();
          break;

        case _constants.STATS.SHARE_SENDER_ID:
          if (sumValue) {
            rtcOutVideo = sumValue.rtcOutVideo;
            rtpOutVideo = sumValue.rtpOutVideo;
          }

          vsTransmit = _objectSpread({}, _constants.MQA_STATS.DEFAULT_SHARE_SENDER_STATS);

          if (isBrowser('firefox')) {
            vsTransmit.common.remoteLossRate = rtpOutVideo ? rtpOutVideo.pliCount / (interval.length * this.intervalNumber) : 0;
            vsTransmit.common.rtpPackets = rtpOutVideo ? rtpOutVideo.packetsSent / (interval.length * this.intervalNumber) : 0;
            vsTransmit.streams[0].common.transmittedFrameRate = rtcOutVideo ? rtcOutVideo.framesEncoded / (interval.length * this.intervalNumber) : 0;
            vsTransmit.streams[0].common.rtpPackets = rtpOutVideo ? rtpOutVideo.packetsSent / (interval.length * this.intervalNumber) : 0;
          } else {
            vsTransmit.common.availableBitRate = rtcCandidatePair ? rtcCandidatePair.availableOutgoingBitrate : 0;
            vsTransmit.common.remoteLossRate = rtpOutVideo ? rtpOutVideo.pliCount / (interval.length * this.intervalNumber) : 0;
            vsTransmit.common.roundTripTime = rtcCandidatePair ? rtcCandidatePair.totalRoundTripTime / (interval.length * this.intervalNumber) : 0;
            vsTransmit.common.rtpPackets = rtpOutVideo ? rtpOutVideo.packetsSent / (interval.length * this.intervalNumber) : 0;
            vsTransmit.streams[0].common.rtpPackets = rtpOutVideo ? rtpOutVideo.packetsSent / (interval.length * this.intervalNumber) : 0;
            vsTransmit.streams[0].common.transmittedBitrate = rtcCandidatePair ? rtcCandidatePair.availableOutgoingBitrate : 0;
            vsTransmit.streams[0].common.transmittedFrameRate = rtcOutVideo ? rtcOutVideo.framesSent / (interval.length * this.intervalNumber) : 0;
            vsTransmit.streams[0].transmittedHeight = rtcOutVideo ? rtcOutVideo.frameHeight : 0;
            vsTransmit.streams[0].transmittedKeyFrames = rtcOutVideo ? rtcOutVideo.hugeFramesSent : 0;
            vsTransmit.streams[0].transmittedWidth = rtcOutVideo ? rtcOutVideo.frameWidth : 0;
          }

          videoTransmit.push(vsTransmit);
          break;

        default:
          break;
      }

      this.data.intervalMetadata = this.data.intervalMetadata || _objectSpread({}, _constants.MQA_STATS.intervalMetadata);
    }
    /**
     * get the data payload for media quality events after they all have been processed
     * wait to call this until after you have all the data from the interval you want
     * this method clears the data as a side effect
     * @returns {Object}
     * @memberof MQAProcessor
     */

  }, {
    key: "getData",
    value: function getData() {
      this.intervalNumber += 1;

      var payload = _objectSpread(_objectSpread({}, this.data), {}, {
        intervalNumber: this.intervalNumber
      });

      this.data = {
        videoReceive: [],
        audioTransmit: [],
        audioReceive: [],
        videoTransmit: []
      };
      return payload;
    }
  }]);
  return MQAProcessor;
}();

var _default = MQAProcessor;
exports.default = _default;
//# sourceMappingURL=mqa-processor.js.map
