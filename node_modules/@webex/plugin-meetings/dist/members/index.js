"use strict";

var _Reflect$construct = require("@babel/runtime-corejs2/core-js/reflect/construct");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _webexCore = require("@webex/webex-core");

var _constants = require("../constants");

var _triggerProxy = _interopRequireDefault(require("../common/events/trigger-proxy"));

var _member = _interopRequireDefault(require("../member"));

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _parameter = _interopRequireDefault(require("../common/errors/parameter"));

var _collection = _interopRequireDefault(require("./collection"));

var _request = _interopRequireDefault(require("./request"));

var _util = _interopRequireDefault(require("./util"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
   * Members Update Event
   * Emitted when something in the roster list needs to be updated
   * @event members:update
   * @instance
   * @property {Object} delta the changes to the members list
   * @property {Array} delta.updated array only the updates, includes removals, as they will have updated status and member properties
   * @property {Array} delta.added array added members to the meeting
   * @property {Array} full array the full members collection
   * @memberof Members
   */

/**
   * Members Content Update Event
   * Emitted when who is sharing changes
   * @event members:content:update
   * @instance
   * @property {String} activeContentSharingId
   * @property {String} endedContentSharingId
   * @memberof Members
   */

/**
   * Members Host Update Event
   * Emitted when who is the host changes
   * @event members:host:update
   * @instance
   * @property {String} activeHostId
   * @property {String} endedHostId
   * @memberof Members
   */

/**
   * Members Self Update Event
   * Emitted when who is the self changes
   * @event members:self:update
   * @instance
   * @property {String} activeSelfId
   * @property {String} endedSelfId
   * @memberof Members
   */

/**
 * @class Members
 */
var Members = /*#__PURE__*/function (_StatelessWebexPlugin) {
  (0, _inherits2.default)(Members, _StatelessWebexPlugin);

  var _super = _createSuper(Members);

  /**
   *
   * @param {Object} attrs
   * @param {Object} options
   * @memberof Members
   */
  function Members(attrs, options) {
    var _this;

    (0, _classCallCheck2.default)(this, Members);
    _this = _super.call(this, {}, options);
    /**
     * The Members Request object to interact with server
     * @instance
     * @type {MembersRequest}
     * @private
     * @memberof Members
    */

    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "namespace", _constants.MEETINGS);
    _this.membersRequest = new _request.default({}, options);
    /**
     * The Members Collection cache
     * @instance
     * @type {MembersCollection}
     * @private
     * @memberof Members
    */

    _this.membersCollection = new _collection.default();
    /**
     * The current locus url for the active meeting
     * @instance
     * @type {String}
     * @private
     * @memberof Members
    */

    _this.locusUrl = attrs.locusUrl || null;
    /**
     * The current hostId for the meeting
     * @instance
     * @type {String}
     * @private
     * @memberof Members
    */

    _this.hostId = null;
    /**
     * The current type for the meeting, could be MEETING or CALL
     * @instance
     * @type {String}
     * @private
     * @memberof Members
    */

    _this.type = null;
    /**
     * Locus has a self object, sent individually to the client
     * i.e., each person in the call gets their own self object from locus.
     * We need to maintain that self object, because we also get information about all the participants
     * and differentiate those participants from self.
     * The self id shouldnt ever change, but it does have properties that will change
     * and we use values in locus-info, such as to determine if i am admitted to the meeting or not as guest.
     * The current selfId for the meeting
     * @instance
     * @type {String}
     * @private
     * @memberof Members
    */

    _this.selfId = null;
    /**
     * The current mediaShareContentId for the meeting
     * @instance
     * @type {String}
     * @private
     * @memberof Members
    */

    _this.mediaShareContentId = null;
    /**
     * The current recordingId for the meeting, if it exists
     * @instance
     * @type {String}
     * @private
     * @memberof Members
    */

    _this.recordingId = null;
    return _this;
  }
  /**
   * Internal update the self Id value
   * @param {Object} payload
   * @param {Object} payload.newSelf
   * @param {Object} payload.oldSelf
   * @returns {undefined}
   * @private
   * @memberof Members
   */


  (0, _createClass2.default)(Members, [{
    key: "locusSelfUpdate",
    value: function locusSelfUpdate(payload) {
      var newSelfId = null;
      var oldSelfId = null;

      if (payload) {
        if (payload.newSelf) {
          newSelfId = payload.newSelf.id;
        }

        if (payload.oldSelf) {
          oldSelfId = payload.oldSelf.id;
        }
      }

      if (newSelfId) {
        var theSelf = this.membersCollection.get(newSelfId);

        if (theSelf) {
          theSelf.setIsSelf(true);
        }
      }

      if (oldSelfId) {
        var notSelf = this.membersCollection.get(oldSelfId);

        if (notSelf) {
          notSelf.setIsSelf(false);
        }
      }

      this.selfId = newSelfId;

      _triggerProxy.default.trigger(this, {
        file: 'members',
        function: 'locusSelfUpdate'
      }, _constants.EVENT_TRIGGERS.MEMBERS_SELF_UPDATE, {
        activeSelfId: newSelfId,
        endedSelfId: oldSelfId
      });
    }
    /**
     * Internal update the hostId value
     * @param {Object} payload
     * @param {Object} payload.newHost
     * @param {Object} payload.oldHost
     * @returns {undefined}
     * @private
     * @memberof Members
     */

  }, {
    key: "locusHostUpdate",
    value: function locusHostUpdate(payload) {
      var newHostId = null;
      var oldHostId = null;

      if (payload) {
        if (payload.newHost) {
          newHostId = payload.newHost.id;
        }

        if (payload.oldHost) {
          oldHostId = payload.oldHost.id;
        }
      }

      if (newHostId) {
        var theHost = this.membersCollection.get(newHostId);

        if (theHost) {
          theHost.setIsHost(true);
        }
      }

      if (oldHostId) {
        var notHost = this.membersCollection.get(oldHostId);

        if (notHost) {
          notHost.setIsHost(false);
        }
      }

      this.hostId = newHostId;

      _triggerProxy.default.trigger(this, {
        file: 'members',
        function: 'locusHostUpdate'
      }, _constants.EVENT_TRIGGERS.MEMBERS_HOST_UPDATE, {
        activeHostId: newHostId,
        endedHostId: oldHostId
      });
    }
    /**
     * when new participant updates come in, both delta and full participants, update them in members collection
     * delta object in the event will have {updated, added} and full will be the full membersCollection
     * @param {Object} payload
     * @param {Object} payload.participants
     * @returns {undefined}
     * @private
     * @memberof Members
     */

  }, {
    key: "locusParticipantsUpdate",
    value: function locusParticipantsUpdate(payload) {
      if (payload) {
        var delta = this.handleLocusInfoUpdatedParticipants(payload);
        var full = this.handleMembersUpdate(delta); // SDK should propagate the full list for both delta and non delta updates

        _triggerProxy.default.trigger(this, {
          file: 'members',
          function: 'locusParticipantsUpdate'
        }, _constants.EVENT_TRIGGERS.MEMBERS_UPDATE, {
          delta: delta,
          full: full
        });
      }
    }
    /**
     * Internal update the content id
     * @param {Object} payload
     * @param {Object} payload.current
     * @param {Object} payload.previous
     * @returns {undefined}
     * @private
     * @memberof Members
     */

  }, {
    key: "locusMediaSharesUpdate",
    value: function locusMediaSharesUpdate(payload) {
      var currentContent = payload.current;
      var previousContent = payload.previous;
      var whoSharing = null;
      var whoStopped = null;

      if (currentContent && currentContent.contentId) {
        if (currentContent.disposition === _constants.FLOOR_ACTION.GRANTED) {
          whoSharing = currentContent.contentId;
          whoStopped = previousContent && previousContent.contentId;
        } else if (currentContent.disposition === _constants.FLOOR_ACTION.RELEASED) {
          whoStopped = currentContent.contentId;
        }
      }

      if (whoSharing) {
        var shareMember = this.membersCollection.get(whoSharing);

        if (shareMember) {
          shareMember.setIsContentSharing(true);
        }
      }

      if (whoStopped) {
        var stopMember = this.membersCollection.get(whoStopped);

        if (stopMember) {
          stopMember.setIsContentSharing(false);
        }
      }

      this.mediaShareContentId = whoSharing;

      _triggerProxy.default.trigger(this, {
        file: 'members',
        function: 'locusMediaSharesUpdate'
      }, _constants.EVENT_TRIGGERS.MEMBERS_CONTENT_UPDATE, {
        activeContentSharingId: whoSharing,
        endedContentSharingId: whoStopped
      });
    }
    /**
     * Internal update the locus url value
     * @param {Object} payload
     * @param {String} payload.locusUrl
     * @returns {undefined}
     * @private
     * @memberof Members
     */

  }, {
    key: "locusUrlUpdate",
    value: function locusUrlUpdate(payload) {
      if (payload) {
        this.setLocusUrl(null, payload);
      }
    }
    /**
     * Internal update the type of meeting
     * @param {Object} payload
     * @param {String} payload.type
     * @returns {undefined}
     * @private
     * @memberof Members
     */

  }, {
    key: "locusFullStateTypeUpdate",
    value: function locusFullStateTypeUpdate(payload) {
      // TODO: at some point there could be a timing issue here, for updating each member
      // ie., if the type changes AND there is no locus update, then each member will not know the type of call
      // which means they cannot determine isMutable && isRemovable
      // for now this scenario is impossible to occur since we always get a locus update when the type changes
      // except for in delta locus meetings, but in that case, the type will always have been set differently
      // from the outset anyway
      if (payload) {
        this.setType(payload);
      }
    }
    /**
     * sets values in the members collection for updated and added properties from delta
     * @param {Object} membersUpdate {updated: [], added: []}
     * @returns {Object} membersCollection
     * @private
     * @memberof Members
     */

  }, {
    key: "handleMembersUpdate",
    value: function handleMembersUpdate(membersUpdate) {
      if (membersUpdate) {
        if (membersUpdate.updated) {
          this.constructMembers(membersUpdate.updated);
        }

        if (membersUpdate.added) {
          this.constructMembers(membersUpdate.added);
        }
      }

      return this.membersCollection.getAll();
    }
    /**
     * set members to the member collection from each updated/added lists as passed in
     * @param {Array} list
     * @returns {undefined}
     * @private
     * @memberof Members
     */

  }, {
    key: "constructMembers",
    value: function constructMembers(list) {
      var _this2 = this;

      list.forEach(function (member) {
        _this2.membersCollection.set(member.id, member);
      });
    }
    /**
     * Internal update the participants value
     * @param {Object} payload
     * @returns {Object}
     * @private
     * @memberof Members
     */

  }, {
    key: "handleLocusInfoUpdatedParticipants",
    value: function handleLocusInfoUpdatedParticipants(payload) {
      this.hostId = payload.hostId || this.hostId;
      this.selfId = payload.selfId || this.selfId;
      this.recordingId = payload.recordingId;

      if (!payload.participants) {
        _loggerProxy.default.logger.warn('Members:index#handleLocusInfoUpdatedParticipants --> participants payload is missing.');
      }

      var memberUpdate = this.update(payload.participants);
      return memberUpdate;
    }
    /**
     * Update the locus Url
     * @param {Object} locus
     * @param {String} [locusUrl] optional, takes precedence
     * @throws {ParameterError}
     * @returns {undefined}
     * @public
     * @memberof Members
     */

  }, {
    key: "setLocusUrl",
    value: function setLocusUrl(locus) {
      var locusUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (locusUrl) {
        this.locusUrl = locusUrl;
      } else if (locus && (locus.locusUrl || locus.url)) {
        this.locusUrl = locus.locusUrl || locus.url;
      } else {
        throw new _parameter.default('Setting locusUrl for the Members module should be done with a locus object or locusUrl');
      }
    }
    /**
     * Update the host id
     * @param {Object} locus
     * @param {String} [hostId] optional, takes precedence
     * @throws {ParameterError}
     * @returns {undefined}
     * @public
     * @memberof Members
     */

  }, {
    key: "setHostId",
    value: function setHostId(locus) {
      var hostId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (hostId) {
        this.hostId = hostId;
      } else if (locus) {
        this.hostId = locus && locus.owner && locus.owner.info ? locus.owner.info : null;
      } else {
        throw new _parameter.default('Setting hostid for the Members module should be done with a locus object or hostId');
      }
    }
    /**
     * Update the type
     * @param {Object} fullState
     * @param {String} [type] optional, takes precedence
     * @throws {ParameterError}
     * @returns {undefined}
     * @public
     * @memberof Members
     */

  }, {
    key: "setType",
    value: function setType(fullState) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (type) {
        this.type = type;
      } else if (fullState) {
        this.type = fullState && fullState.type || null;
      } else {
        throw new _parameter.default('Setting type for the Members module should be done with a fullstate object or type string');
      }
    }
    /**
     * Update the self Id
     * @param {Object} locus
     * @param {String} [selfId] optional, takes precedence
     * @throws {Error}
     * @returns {undefined}
     * @memberof Members
     */

  }, {
    key: "setSelfId",
    value: function setSelfId(locus) {
      var selfId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (selfId) {
        this.selfId = selfId;
      } else if (locus) {
        this.selfId = locus && locus.self && locus.self.person && locus.self.person.id ? locus.self.person.id : null;
      } else {
        throw new _parameter.default('Setting selfid for the Members module should be done with a locus object or selfId');
      }
    }
    /**
     * Update the media share content id
     * @param {Object} locus
     * @param {String} [contentId] optional, takes precedence
     * @throws {Error}
     * @returns {undefined}
     * @memberof Members
     */

  }, {
    key: "setMediaShareContentId",
    value: function setMediaShareContentId(locus, contentId) {
      if (contentId) {
        this.mediaShareContentId = contentId;
      } else if (locus) {
        var contentMediaShare = locus.mediaShares && locus.mediaShares.length && locus.mediaShares.find(function (mediaShare) {
          return mediaShare.name === _constants.CONTENT;
        });
        this.mediaShareContentId = contentMediaShare && contentMediaShare.floor && contentMediaShare.floor.beneficiary && contentMediaShare.floor.beneficiary.id || null;
      } else {
        throw new _parameter.default('Setting hostid for the Members module should be done with a locus object or hostId');
      }
    }
    /**
     * Find all the updates, and added members
     * Removed/left members will end up in updates
     * Each array contains only members
     * @param {Array} participants the locus participants
     * @returns {Object} {added: {Array}, updated: {Array}}
     * @private
     * @memberof Members
     */

  }, {
    key: "update",
    value: function update(participants) {
      var _this3 = this;

      var membersUpdate = {
        added: [],
        updated: []
      };

      if (participants) {
        participants.forEach(function (participant) {
          if (participant.hideInRoster) {
            return;
          }

          var existing = _this3.membersCollection.get(participant.id);

          if (existing) {
            // TODO: compare existing member to new participant coming in properties and determine if updated (this helps for non delta events)
            // on client re renders, but we will have to determine what values to compare to determine difference, premature optimization
            membersUpdate.updated.push(new _member.default(participant, {
              recordingId: _this3.recordingId,
              selfId: _this3.selfId,
              hostId: _this3.hostId,
              contentSharingId: _this3.mediaShareContentId,
              type: _this3.type
            }));
          } else {
            membersUpdate.added.push(new _member.default(participant, {
              recordingId: _this3.recordingId,
              selfId: _this3.selfId,
              hostId: _this3.hostId,
              contentSharingId: _this3.mediaShareContentId,
              type: _this3.type
            }));
          }
        });
      }

      return membersUpdate;
    }
    /**
     * Adds a guest Member to the associated meeting
     * @param {String} invitee
     * @param {Boolean} [alertIfActive]
     * @returns {Promise}
     * @memberof Members
     */

  }, {
    key: "addMember",
    value: function addMember(invitee, alertIfActive) {
      if (!this.locusUrl) {
        return _promise.default.reject(new _parameter.default('The associated locus url for this meeting object must be defined.'));
      }

      if (_util.default.isInvalidInvitee(invitee)) {
        return _promise.default.reject(new _parameter.default('The invitee must be defined with either a valid email, or emailAddress property.'));
      }

      var options = _util.default.generateAddMemberOptions(invitee, this.locusUrl, alertIfActive);

      return this.membersRequest.addMembers(options);
    }
    /**
     * Admits waiting members (invited guests to meeting)
     * @param {Array} memberIds
     * @returns {Promise}
     * @public
     * @memberof Members
     */

  }, {
    key: "admitMembers",
    value: function admitMembers(memberIds) {
      if ((0, _isEmpty2.default)(memberIds)) {
        return _promise.default.reject(new _parameter.default('No member ids provided to admit.'));
      }

      var options = _util.default.generateAdmitMemberOptions(memberIds, this.locusUrl);

      return this.membersRequest.admitMember(options);
    }
    /**
     * Removes a member from the meeting
     * @param {String} memberId
     * @returns {Promise}
     * @public
     * @memberof Members
     */

  }, {
    key: "removeMember",
    value: function removeMember(memberId) {
      if (!this.locusUrl) {
        return _promise.default.reject(new _parameter.default('The associated locus url for this meeting object must be defined.'));
      }

      if (!memberId) {
        return _promise.default.reject(new _parameter.default('The member id must be defined to remove the member.'));
      }

      var options = _util.default.generateRemoveMemberOptions(memberId, this.locusUrl);

      return this.membersRequest.removeMember(options);
    }
    /**
     * Audio mutes another member in a meeting
     * @param {String} memberId
     * @param {boolean} [mute] default true
     * @returns {Promise}
     * @public
     * @memberof Members
     */

  }, {
    key: "muteMember",
    value: function muteMember(memberId) {
      var mute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (!this.locusUrl) {
        return _promise.default.reject(new _parameter.default('The associated locus url for this meetings members object must be defined.'));
      }

      if (!memberId) {
        return _promise.default.reject(new _parameter.default('The member id must be defined to mute the member.'));
      }

      var options = _util.default.generateMuteMemberOptions(memberId, mute, this.locusUrl);

      return this.membersRequest.muteMember(options);
    }
    /**
     * Transfers the host to another member
     * @param {String} memberId
     * @param {boolean} [moderator] default true
     * @returns {Promise}
     * @public
     * @memberof Members
     */

  }, {
    key: "transferHostToMember",
    value: function transferHostToMember(memberId) {
      var moderator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (!this.locusUrl) {
        return _promise.default.reject(new _parameter.default('The associated locus url for this meetings members object must be defined.'));
      }

      if (!memberId) {
        return _promise.default.reject(new _parameter.default('The member id must be defined to transfer host to the member.'));
      }

      var options = _util.default.generateTransferHostMemberOptions(memberId, moderator, this.locusUrl);

      return this.membersRequest.transferHostToMember(options);
    }
  }]);
  return Members;
}(_webexCore.StatelessWebexPlugin);

exports.default = Members;
//# sourceMappingURL=index.js.map
