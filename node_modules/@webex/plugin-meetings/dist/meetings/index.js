"use strict";

var _Reflect$construct = require("@babel/runtime-corejs2/core-js/reflect/construct");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _values = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/values"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

require("@webex/internal-plugin-mercury");

var _webexCore = require("@webex/webex-core");

require("webrtc-adapter");

var _metrics = _interopRequireDefault(require("../metrics"));

var _config = require("../metrics/config");

var _loggerConfig = _interopRequireDefault(require("../common/logs/logger-config"));

var _config2 = _interopRequireDefault(require("../common/config"));

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _request = _interopRequireDefault(require("../common/logs/request"));

var _triggerProxy = _interopRequireDefault(require("../common/events/trigger-proxy"));

var _media = _interopRequireDefault(require("../media"));

var _util = _interopRequireDefault(require("../meeting/util"));

var _constants = require("../constants");

var _meetingInfo = _interopRequireDefault(require("../meeting-info"));

var _meeting = _interopRequireDefault(require("../meeting"));

var _personalMeetingRoom = _interopRequireDefault(require("../personal-meeting-room"));

var _reachability = _interopRequireDefault(require("../reachability"));

var _request2 = _interopRequireDefault(require("../meetings/request"));

var _analyzer = _interopRequireDefault(require("../analyzer/analyzer"));

var _calculator = _interopRequireDefault(require("../analyzer/calculator"));

var _collection = _interopRequireDefault(require("./collection"));

var _util2 = _interopRequireDefault(require("./util"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
   * Meetings Ready Event
   * Emitted when the meetings instance on webex is ready
   * @event meetings:ready
   * @instance
   * @memberof Meetings
   */

/**
   * Meetings Network Disconnected Event
   * Emitted when the meetings instance is disconnected from
   * the internal mercury server
   * @event network:disconnected
   * @instance
   * @memberof Meetings
   */

/**
 * Meetings Registered Event
 * Emitted when the meetings instance has been registered and listening
 * @event meetings:registered
 * @instance
 * @memberof Meetings
 */

/**
    * Meeting Removed Event
    * Emitted when a meeting was removed from the cache of meetings
    * @event meeting:removed
    * @instance
    * @type {Object}
    * @property {String} meetingId the removed meeting
    * @property {Object} response the server response
    * @property {String} type what type of meeting it was
    * @memberof Meetings
    */

/**
    * Meeting Added Event
    * Emitted when a meeting was added to the cache of meetings
    * @event meeting:added
    * @instance
    * @type {Object}
    * @property {String} meetingId the added meeting
    * @property {String} type what type of meeting it was
    * @memberof Meetings
    */

/**
   * Maintain a cache of meetings and sync with services.
   * @class
   */
var Meetings = /*#__PURE__*/function (_WebexPlugin) {
  (0, _inherits2.default)(Meetings, _WebexPlugin);

  var _super = _createSuper(Meetings);

  /**
   * Initializes the Meetings Plugin
   * @constructor
   * @public
   * @memberof Meetings
   */
  function Meetings() {
    var _this;

    (0, _classCallCheck2.default)(this, Meetings);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    /**
     * The MeetingInfo object to interact with server
     * @instance
     * @type {Object}
     * @private
     * @memberof Meetings
     */

    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "namespace", _constants.MEETINGS);
    _this.meetingInfo = new _meetingInfo.default(_this.webex);
    /**
     * The Meetings request to interact with server
     * @instance
     * @type {Object}
     * @private
     * @memberof Meetings
     */

    _this.request = new _request2.default({}, {
      parent: _this.webex
    });
    /**
     * Log upload request helper
     * @instance
     * @type {Object}
     * @private
     * @memberof Meetings
     */

    _this.loggerRequest = new _request.default({
      webex: _this.webex
    });
    _this.meetingCollection = new _collection.default();
    /**
     * The PersonalMeetingRoom object to interact with server
     * @instance
     * @type {Object}
     * @public
     * @memberof Meetings
     */

    _this.personalMeetingRoom = new _personalMeetingRoom.default({}, {
      parent: _this.webex
    });
    /**
     * The Reachability object to interact with server, starts as null until {@link Meeting#setReachability} is called
     * starts as null
     * @instance
     * @type {Object}
     * @private
     * @memberof Meetings
     */

    _this.reachability = null;
    /**
     * If the meetings plugin has been registered and listening via {@link Meetings#register}
     * @instance
     * @type {Boolean}
     * @public
     * @memberof Meetings
     */

    _this.registered = false;
    /**
     * The public interface for the internal Media util files. These are helpful to expose outside the context
     * of a meeting so that a user can access media without creating a meeting instance.
     * @instance
     * @type {Object}
     * @private
     * @memberof Meetings
     */

    _this.media = {
      getUserMedia: _media.default.getUserMedia,
      getSupportedDevice: _media.default.getSupportedDevice
    };

    _this.onReady();

    _util2.default.checkH264Support({
      disableNotifications: true
    });

    _metrics.default.initialSetup(_this.meetingCollection, _this.webex);

    return _this;
  }
  /**
   * handle locus events and takes meeting actions with them as they come in
   * @param {Object} data a locus event
   * @param {String} data.locusUrl
   * @param {Object} data.locus
   * @param {String} data.eventType
   * @returns {undefined}
   * @private
   * @memberof Meetings
   */


  (0, _createClass2.default)(Meetings, [{
    key: "handleLocusEvent",
    value: function handleLocusEvent(data) {
      var _data$locus,
          _data$locus$replaces,
          _this2 = this;

      var meeting = null; // getting meeting by correlationId. This will happen for the new event
      // Either the locus
      // TODO : Add check for the callBack Address

      meeting = this.meetingCollection.getByKey(_constants.LOCUS_URL, data.locusUrl) || this.meetingCollection.getByKey(_constants.CORRELATION_ID, _util2.default.checkForCorrelationId(this.webex.internal.device.url, data.locus)) || this.meetingCollection.getByKey(_constants.SIP_URI, data.locus.self && data.locus.self.callbackInfo && data.locus.self.callbackInfo.callbackAddress) || this.meetingCollection.getByKey(_constants.CONVERSATION_URL, data.locus.conversationUrl); // Special case when locus has got replaced, This only happend once if a replace locus exists
      // https://sqbu-github.cisco.com/WebExSquared/locus/wiki/Locus-changing-mid-call

      if (!meeting && ((_data$locus = data.locus) === null || _data$locus === void 0 ? void 0 : (_data$locus$replaces = _data$locus.replaces) === null || _data$locus$replaces === void 0 ? void 0 : _data$locus$replaces.length) > 0) {
        // Always the last element in the replace is the active one
        meeting = this.meetingCollection.getByKey(_constants.LOCUS_URL, data.locus.replaces[data.locus.replaces.length - 1].locusUrl);
      }

      if (!meeting) {
        // TODO: create meeting when we get a meeting object
        // const checkForEnded = (locus) => {
        // TODO: you already ended the meeting but you got an event later
        // Mainly for 1:1 Callsor meeting
        // Happens mainly after refresh
        // 1:1 Meeting
        // 1)  You ended a call before but you got a mercury event
        // Make sure end the call and cleanup the meeting only if the mercury
        // event says so
        // 2) Maintain lastSync time in the meetings object which helps to compare
        // If the meeting came befor or after the sync . ANy meeting start time before the sync time is invalid
        // For space Meeting
        // Check the locus object and see who has joined
        // };
        // rather then locus object change to locus url
        if (data.locus && data.locus.fullState && data.locus.fullState.state === _constants.LOCUS.STATE.INACTIVE) {
          // just ignore the event as its already ended and not active
          _loggerProxy.default.logger.warn('Meetings:index#handleLocusEvent --> Locus event received for meeting, after it was ended.');

          return;
        } // When its wireless share or guest and user leaves the meeting we dont have to keep the meeting object
        // Any future events will be neglected


        if (data.locus && data.locus.self && data.locus.self.state === _constants._LEFT_ && data.locus.self.removed === true) {
          // just ignore the event as its already ended and not active
          _loggerProxy.default.logger.warn('Meetings:index#handleLocusEvent --> Locus event received for meeting, after it was ended.');

          return;
        }

        this.create(data.locus, _constants._LOCUS_ID_).then(function (newMeeting) {
          meeting = newMeeting;

          if (data.eventType === _constants.LOCUSEVENT.DIFFERENCE) {
            // its a delta object and we have a new meeting
            meeting.locusInfo.initialSetup(data.locus, meeting);
          } else {
            // Its a new meeting and have a fresh locus object
            meeting.locusInfo.initialSetup(data.locus);
          }
        }).catch(function (e) {
          console.log(e);
        }).finally(function () {
          // There will be cases where locus event comes in gets created and deleted because its a 1:1 and meeting gets deleted
          // because the other user left so before sending 'added' event make sure it exists in the collection
          if (_this2.getMeetingByType(_constants._ID_, meeting.id)) {
            _metrics.default.postEvent({
              event: _config.eventType.REMOTE_STARTED,
              meeting: meeting,
              data: {
                trigger: _config.trigger.MERCURY_EVENT
              }
            });

            _triggerProxy.default.trigger(_this2, {
              file: 'meetings',
              function: 'handleLocusEvent'
            }, _constants.EVENT_TRIGGERS.MEETING_ADDED, {
              meeting: meeting,
              type: meeting.type === _constants._MEETING_ ? _constants._JOIN_ : _constants._INCOMING_
            });
          } else {
            // Meeting got added but was not found in the collection. It might have got destroyed
            _loggerProxy.default.logger.warn('Meetings:index#handleLocusEvent --> Created and destroyed meeting object before sending an event');
          }
        });
      } else {
        meeting.locusInfo.parse(meeting, data);
      }
    }
    /**
     * handles locus events through mercury that are not roap
     * @param {Object} envelope
     * @param {Object} envelope.data
     * @param {String} envelope.data.eventType
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */

  }, {
    key: "handleLocusMercury",
    value: function handleLocusMercury(envelope) {
      var data = envelope.data;
      var eventType = data.eventType;

      if (eventType && eventType !== _constants.LOCUSEVENT.MESSAGE_ROAP) {
        this.handleLocusEvent(data);
      }
    }
    /**
     * handles mecury offline event
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */

  }, {
    key: "handleMercuryOffline",
    value: function handleMercuryOffline() {
      _triggerProxy.default.trigger(this, {
        file: 'meetings/index',
        function: 'handleMercuryOffline'
      }, _constants.EVENT_TRIGGERS.MEETINGS_NETWORK_DISCONNECTED);
    }
    /**
     * registers for locus and roap mercury events
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */

  }, {
    key: "listenForEvents",
    value: function listenForEvents() {
      var _this3 = this;

      this.webex.internal.mercury.on(_constants.LOCUSEVENT.LOCUS_MERCURY, function (envelope) {
        _this3.handleLocusMercury(envelope);
      });
      this.webex.internal.mercury.on(_constants.ROAP.ROAP_MERCURY, function (envelope) {
        _util2.default.handleRoapMercury(envelope, _this3.meetingCollection);
      });
      this.webex.internal.mercury.on(_constants.ONLINE, function () {
        _this3.syncMeetings();
      });
      this.webex.internal.mercury.on(_constants.OFFLINE, function () {
        _this3.handleMercuryOffline();
      });
    }
    /**
     * stops listening for locus and roap mercury events
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */

  }, {
    key: "stopListeningForEvents",
    value: function stopListeningForEvents() {
      this.webex.internal.mercury.off(_constants.LOCUSEVENT.LOCUS_MERCURY);
      this.webex.internal.mercury.off(_constants.ROAP.ROAP_MERCURY);
      this.webex.internal.mercury.off(_constants.ONLINE);
    }
    /**
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */

  }, {
    key: "onReady",
    value: function onReady() {
      var _this4 = this;

      this.webex.once(_constants.READY, function () {
        _config2.default.set(_this4.config);

        _loggerConfig.default.set(_this4.config.logging);

        _loggerProxy.default.set(_this4.webex.logger);

        _triggerProxy.default.trigger(_this4, {
          file: 'meetings',
          function: 'onReady'
        }, _constants.EVENT_TRIGGERS.MEETINGS_READY);
      });
    }
    /**
     * Explicitly sets up the meetings plugin by registering
     * the device, connecting to mercury, and listening for locus events.
     *
     * @returns {Promise}
     * @public
     * @memberof Meetings
     */

  }, {
    key: "register",
    value: function register() {
      var _this5 = this;

      if (!this.webex.canAuthorize) {
        _loggerProxy.default.logger.error('Meetings:index#register --> ERROR, Unable to register, SDK cannot authorize');

        return _promise.default.reject(new Error('SDK cannot authorize'));
      }

      if (this.registered) {
        _loggerProxy.default.logger.info('Meetings:index#register --> INFO, Meetings plugin already registered');

        return _promise.default.resolve();
      }

      return _promise.default.all([this.getGeoHint(), this.startReachability().catch(function (error) {
        _loggerProxy.default.logger.error("Meetings:index#register --> GDM error, ".concat(error.message));
      }), this.webex.internal.device.register().then(function () {
        return _loggerProxy.default.logger.info("Meetings:index#register --> INFO, Device registered ".concat(_this5.webex.internal.device.url));
      }).then(function () {
        return _this5.webex.internal.mercury.connect();
      }), _util2.default.checkH264Support.call(this)]).then(function () {
        _this5.listenForEvents();

        _triggerProxy.default.trigger(_this5, {
          file: 'meetings',
          function: 'register'
        }, _constants.EVENT_TRIGGERS.MEETINGS_REGISTERED);

        _this5.registered = true;
      }).catch(function (error) {
        _loggerProxy.default.logger.error("Meetings:index#register --> ERROR, Unable to register, ".concat(error.message));

        return _promise.default.reject(error);
      });
    }
    /**
     * Explicitly tears down the meetings plugin by deregistering
     * the device, disconnecting from mercury, and stops listening to locus events
     *
     * @returns {Promise}
     * @public
     * @memberof Meetings
     */

  }, {
    key: "unregister",
    value: function unregister() {
      var _this6 = this;

      if (!this.registered) {
        _loggerProxy.default.logger.info('Meetings:index#unregister --> INFO, Meetings plugin already unregistered');

        return _promise.default.resolve();
      }

      this.stopListeningForEvents();
      return this.webex.internal.mercury.disconnect().then(function () {
        return _this6.webex.internal.device.unregister();
      }).then(function () {
        _triggerProxy.default.trigger(_this6, {
          file: 'meetings',
          function: 'unregister'
        }, _constants.EVENT_TRIGGERS.MEETINGS_UNREGISTERED);

        _this6.registered = false;
      });
    }
    /**
     * Uploads logs to the webex services for tracking
     * @param {Object} [options={}]
     * @param {String} [options.callStart] Call Start Time
     * @param {String} [options.feedbackId] ID used for tracking
     * @param {String} [options.locusId]
     * @param {String} [options.correlationId]
     * @param {String} [options.meetingId] webex meeting ID
     * @param {String} [options.userId] userId
     * @param {String} [options.orgId] org id
     * @returns {String} feedback ID logs were submitted under
     */

  }, {
    key: "uploadLogs",
    value: function uploadLogs() {
      var _this7 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _loggerProxy.default.logger.info('Meetings:index#uploadLogs --> uploading logs');

      return this.loggerRequest.uploadLogs(options).then(function (uploadResult) {
        _loggerProxy.default.logger.info('Meetings:index#uploadLogs --> Upload logs for meeting completed.', uploadResult);

        _triggerProxy.default.trigger(_this7, {
          file: 'meetings',
          function: 'uploadLogs'
        }, _constants.EVENT_TRIGGERS.MEETING_LOG_UPLOAD_SUCCESS, {
          meetingId: options.meetingId,
          details: uploadResult
        });
      }).catch(function (uploadError) {
        _loggerProxy.default.logger.error('Meetings:index#uploadLogs --> Unable to upload logs for meeting', uploadError);

        _triggerProxy.default.trigger(_this7, {
          file: 'meetings',
          function: 'uploadLogs'
        }, _constants.EVENT_TRIGGERS.MEETING_LOG_UPLOAD_FAILURE, {
          meetingId: options.meetingId,
          reason: uploadError
        });

        _metrics.default.sendOperationalMetric(_constants.METRICS_OPERATIONAL_MEASURES.UPLOAD_LOGS_FAILURE, {
          meetingId: options.meetingsId,
          reason: uploadError.message,
          stack: uploadError.stack,
          code: uploadError.code
        });
      });
    }
    /**
     * initializes the reachability instance for Meetings
     * @returns {undefined}
     * @public
     * @memberof Meetings
     */

  }, {
    key: "setReachability",
    value: function setReachability() {
      this.reachability = new _reachability.default(this.webex);
    }
    /**
     * gets the reachability instance for Meetings
     * @returns {Reachability}
     * @public
     * @memberof Meetings
     */

  }, {
    key: "getReachability",
    value: function getReachability() {
      return this.reachability;
    }
    /**
     * initializes and starts gathering reachability for Meetings
     * @returns {Promise}
     * @public
     * @memberof Meetings
     */

  }, {
    key: "startReachability",
    value: function startReachability() {
      if (!this.reachability) {
        this.setReachability();
      }

      return this.getReachability().gatherReachability();
    }
    /**
     * Get geoHint for info for meetings
     * @returns {Promise}
     * @private
     * @memberof Meetings
     */

  }, {
    key: "getGeoHint",
    value: function getGeoHint() {
      var _this8 = this;

      return this.request.fetchGeoHint().then(function (res) {
        _this8.geoHintInfo = res;
      });
    }
    /**
     * gets the personal meeting room instance, for saved PMR values for this user
     * @returns {PersonalMeetingRoom}
     * @public
     * @memberof Meetings
     */

  }, {
    key: "getPersonalMeetingRoom",
    value: function getPersonalMeetingRoom() {
      return this.personalMeetingRoom;
    }
    /**
     * @param {Meeting} meeting
     * @param {Object} reason
     * @param {String} type
     * @returns {Undefined}
     * @private
     * @memberof Meetings
     */

  }, {
    key: "destroy",
    value: function destroy(meeting, reason) {
      _util.default.cleanUp(meeting);

      this.meetingCollection.delete(meeting.id);

      _triggerProxy.default.trigger(this, {
        file: 'meetings',
        function: 'destroy'
      }, _constants.EVENT_TRIGGERS.MEETING_REMOVED, {
        meetingId: meeting.id,
        reason: reason
      });
    }
    /**
     * Create a meeting.
     * @param {string} destination - sipURL, spaceId, phonenumber, or locus object}
     * @param {string} [type] - the optional specified type, such as locusId
     * @returns {Promise<Meeting>} A new Meeting.
     * @public
     * @memberof Meetings
     */

  }, {
    key: "create",
    value: function create(destination) {
      var _this9 = this;

      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      // TODO: type should be from a dictionary
      // Validate meeting information based on the provided destination and
      // type. This must be performed prior to determining if the meeting is
      // found in the collection, as we mutate the destination for hydra person
      // id values.
      return this.meetingInfo.fetchInfoOptions(destination, type) // Catch a failure to fetch info options.
      .catch(function (error) {
        _loggerProxy.default.logger.info("Meetings:index#create --> INFO, unable to determine info options: ".concat(error.message));
      }).then(function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        // Normalize the destination.
        var targetDest = options.destination || destination; // check for the conversation URL then sip Url

        var meeting = null;

        if (type === _constants._CONVERSATION_URL_ || options.type === _constants._CONVERSATION_URL_) {
          meeting = _this9.meetingCollection.getByKey(_constants.CONVERSATION_URL, targetDest);
        } // Attempt to collect the meeting if it exists.


        if (!meeting) {
          meeting = _this9.meetingCollection.getByKey(_constants.SIP_URI, targetDest);
        } // Validate if a meeting was found.


        if (!meeting) {
          // Create a meeting based on the normalized destination and type.
          return _this9.createMeeting(targetDest, type).then(function (createdMeeting) {
            // If the meeting was successfully created.
            if (createdMeeting && createdMeeting.on) {
              // Create a destruction event for the meeting.
              createdMeeting.on(_constants.EVENTS.DESTROY_MEETING, function (payload) {
                if (_this9.config.autoUploadLogs) {
                  var _createdMeeting$locus, _createdMeeting$locus2, _createdMeeting$locus3, _createdMeeting$locus4;

                  _this9.uploadLogs({
                    callStart: (_createdMeeting$locus = createdMeeting.locusInfo) === null || _createdMeeting$locus === void 0 ? void 0 : (_createdMeeting$locus2 = _createdMeeting$locus.fullState) === null || _createdMeeting$locus2 === void 0 ? void 0 : _createdMeeting$locus2.lastActive,
                    correlationId: createdMeeting.correlationId,
                    feedbackId: createdMeeting.correlationId,
                    locusId: createdMeeting.locusId,
                    meetingId: (_createdMeeting$locus3 = createdMeeting.locusInfo) === null || _createdMeeting$locus3 === void 0 ? void 0 : (_createdMeeting$locus4 = _createdMeeting$locus3.info) === null || _createdMeeting$locus4 === void 0 ? void 0 : _createdMeeting$locus4.webExMeetingId
                  }).then(function () {
                    return _this9.destroy(createdMeeting, payload.reason);
                  });
                } else {
                  _this9.destroy(createdMeeting, payload.reason);
                }
              });
              createdMeeting.on(_constants.EVENTS.REQUEST_UPLOAD_LOGS, function (meetingInstance) {
                if (_this9.config.autoUploadLogs) {
                  var _meetingInstance$locu, _meetingInstance$locu2, _meetingInstance$locu3, _meetingInstance$locu4;

                  _this9.uploadLogs({
                    callStart: meetingInstance === null || meetingInstance === void 0 ? void 0 : (_meetingInstance$locu = meetingInstance.locusInfo) === null || _meetingInstance$locu === void 0 ? void 0 : (_meetingInstance$locu2 = _meetingInstance$locu.fullState) === null || _meetingInstance$locu2 === void 0 ? void 0 : _meetingInstance$locu2.lastActive,
                    correlationId: meetingInstance.correlationId,
                    feedbackId: meetingInstance.correlationId,
                    locusId: meetingInstance.locusId,
                    meetingId: (_meetingInstance$locu3 = meetingInstance.locusInfo) === null || _meetingInstance$locu3 === void 0 ? void 0 : (_meetingInstance$locu4 = _meetingInstance$locu3.info) === null || _meetingInstance$locu4 === void 0 ? void 0 : _meetingInstance$locu4.webExMeetingId
                  });
                }
              });
            } else {
              _loggerProxy.default.logger.error("Meetings:index#create --> ERROR, meeting does not have on method, will not be destroyed, meeting cleanup impossible for meeting: ".concat(meeting));
            } // Return the newly created meeting.


            return _promise.default.resolve(createdMeeting);
          });
        } // Return the existing meeting.


        return _promise.default.resolve(meeting);
      });
    }
    /**
     * @param {String} destination see create()
     * @param {String} type see create()
     * @returns {Promise} a new meeting instance complete with meeting info and destination
     * @private
     * @memberof Meetings
     */

  }, {
    key: "createMeeting",
    value: function () {
      var _createMeeting = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(destination) {
        var type,
            meeting,
            info,
            meetingAddedType,
            _args = arguments;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                type = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
                meeting = new _meeting.default({
                  userId: this.webex.internal.device.userId,
                  deviceUrl: this.webex.internal.device.url,
                  orgId: this.webex.internal.device.orgId,
                  roapSeq: 0,
                  locus: type === _constants._LOCUS_ID_ ? destination : null // pass the locus object if present

                }, {
                  parent: this.webex
                });
                this.meetingCollection.set(meeting);
                _context.prev = 3;
                _context.next = 6;
                return this.meetingInfo.fetchMeetingInfo(_util2.default.extractDestination(destination, type), type);

              case 6:
                info = _context.sent;
                meeting.parseMeetingInfo(info);
                meeting.meetingInfo = info ? info.body : null;
                _context.next = 17;
                break;

              case 11:
                _context.prev = 11;
                _context.t0 = _context["catch"](3);

                // if there is no meeting info we assume its a 1:1 call or wireless share
                _loggerProxy.default.logger.info("Meetings:index#createMeeting --> Info Unable to fetch meeting info for ".concat(destination, "."));

                _loggerProxy.default.logger.info('Meetings:index#createMeeting --> Info assuming this destination is a 1:1 or wireless share');

                _loggerProxy.default.logger.debug("Meetings:index#createMeeting --> Debug ".concat(_context.t0, " fetching /meetingInfo for creation.")); // We need to save this info for future reference


                meeting.destination = destination;

              case 17:
                _context.prev = 17;

                // For type LOCUS_ID we need to parse the locus object to get the information
                // about the caller and callee
                // Meeting Added event will be created in `handleLocusEvent`
                if (type !== _constants._LOCUS_ID_) {
                  if (!meeting.sipUri) {
                    meeting.setSipUri(destination);
                  } // TODO: check if we have to move this to parser


                  meetingAddedType = _util2.default.getMeetingAddedType(type); // We typically shouldn't need to trigger both and event and return a promise.
                  // Is this a special case? We want to make the public API usage as simple as possible.

                  _triggerProxy.default.trigger(this, {
                    file: 'meetings',
                    function: 'createMeeting'
                  }, _constants.EVENT_TRIGGERS.MEETING_ADDED, {
                    meeting: meeting,
                    type: meetingAddedType
                  });
                }

                return _context.finish(17);

              case 20:
                return _context.abrupt("return", meeting);

              case 21:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[3, 11, 17, 20]]);
      }));

      function createMeeting(_x) {
        return _createMeeting.apply(this, arguments);
      }

      return createMeeting;
    }()
    /**
     * get a specifc meeting given it's type matched to the value, i.e., locus url
     * @param {String} type
     * @param {Object} value
     * @returns {Meeting}
     * @public
     * @memberof Meetings
     */

  }, {
    key: "getMeetingByType",
    value: function getMeetingByType(type, value) {
      return this.meetingCollection.getByKey(type, value);
    }
    /**
     * Get all meetings.
     * @param {object} options
     * @param {object} options.startDate - get meetings after this start date
     * @param {object} options.endDate - get meetings before this end date
     * @returns {Object} All currently active meetings.
     * @public
     * @memberof Meetings
     */

  }, {
    key: "getAllMeetings",
    value: function getAllMeetings() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // Options may include other parameters to filter this collection
      // of meetings.
      return this.meetingCollection.getAll(options);
    }
    /**
     * syncs all the meeting from server
     * @returns {undefined}
     * @public
     * @memberof Meetings
     */

  }, {
    key: "syncMeetings",
    value: function syncMeetings() {
      var _this10 = this;

      return this.request.getActiveMeetings().then(function (locusArray) {
        var activeLocusUrl = [];

        if (locusArray !== null && locusArray !== void 0 && locusArray.loci && locusArray.loci.length > 0) {
          locusArray.loci.forEach(function (locus) {
            activeLocusUrl.push(locus.url);

            _this10.handleLocusEvent({
              locus: locus,
              locusUrl: locus.url
            });
          });
        }

        var meetingsCollection = _this10.meetingCollection.getAll();

        if ((0, _keys.default)(meetingsCollection).length > 0) {
          // Some time the mercury event is missed after mercury reconnect
          // if sync returns no locus then clear all the meetings
          for (var _i = 0, _Object$values = (0, _values.default)(meetingsCollection); _i < _Object$values.length; _i++) {
            var meeting = _Object$values[_i];

            if (!activeLocusUrl.includes(meeting.locusUrl)) {
              // destroy function also uploads logs
              _this10.destroy(meeting, _constants.MEETING_REMOVED_REASON.NO_MEETINGS_TO_SYNC);
            }
          }
        }
      });
    }
    /**
     * Get all scheduled meetings.
     * @param {object} options
     * @param {object} options.startDate - get meetings after this start date
     * @param {object} options.endDate - get meetings before this end date
     * @returns {Object} All scheduled meetings.
     * @memberof Meetings
     */

  }, {
    key: "getScheduledMeetings",
    value: function getScheduledMeetings() {
      return this.meetingCollection.getAll({
        scheduled: true
      });
    }
    /**
     * Get the logger instance for plugin-meetings
     * @returns {Logger}
     */

  }, {
    key: "getLogger",
    value: function getLogger() {
      return _loggerProxy.default.get();
    }
    /**
     * Get the Stats Analyzer singleton
     * @returns {StatsAnalyzer}
     * @public
     * @memberof Meetings
     */

  }, {
    key: "getAnalyzer",
    value: function getAnalyzer() {
      return _analyzer.default;
    }
    /**
     * Get the Stats Calculator singleton
     * @returns {StatsCalculator}
     * @public
     * @memberof Meetings
     */

  }, {
    key: "getCalculator",
    value: function getCalculator() {
      return _calculator.default;
    }
  }]);
  return Meetings;
}(_webexCore.WebexPlugin);

exports.default = Meetings;
//# sourceMappingURL=index.js.map
