{"version":3,"sources":["util.js"],"names":["MeetingsUtil","extractDestination","destination","type","dest","_LOCUS_ID_","url","ParameterError","getMeetingAddedType","_INCOMING_","_CREATED_","handleRoapMercury","envelope","meetingCollection","data","eventType","LOCUSEVENT","MESSAGE_ROAP","meeting","getByKey","CORRELATION_ID","correlationId","roap","roapEvent","checkForCorrelationId","deviceUrl","locus","devices","self","foundDevice","find","device","hasH264Codec","hasCodec","pc","window","RTCPeerConnection","createOffer","offerToReceiveVideo","offer","sdp","match","close","LoggerProxy","logger","error","checkH264Support","options","firstChecked","disableNotifications","delay","maxDuration","shouldTrigger","undefined","shouldStopChecking","Trigger","trigger","file","function","EVENT_TRIGGERS","MEDIA_CODEC_LOADED","log","MEDIA_CODEC_MISSING","setTimeout","timestamp","call"],"mappings":";;;;;;;;;;;;;;;;;;AAEA;;AAQA;;AACA;;AACA;;AAZA;;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAMA,YAAY,GAAG,EAArB;;AAEAA,YAAY,CAACC,kBAAb,GAAkC,UAACC,WAAD,EAAcC,IAAd,EAAuB;AACvD,MAAIC,IAAI,GAAGF,WAAX;;AAEA,MAAIC,IAAI,KAAKE,qBAAb,EAAyB;AACvB,QAAI,EAAEH,WAAW,IAAIA,WAAW,CAACI,GAA7B,CAAJ,EAAuC;AACrC,YAAM,IAAIC,kBAAJ,CAAmB,kEAAnB,CAAN;AACD;;AACDH,IAAAA,IAAI,GAAGF,WAAW,CAACI,GAAnB;AACD;;AAED,SAAOF,IAAP;AACD,CAXD;;AAaAJ,YAAY,CAACQ,mBAAb,GAAmC,UAACL,IAAD;AAAA,SAAWA,IAAI,KAAKE,qBAAT,GAAsBI,qBAAtB,GAAmCC,oBAA9C;AAAA,CAAnC;;AAEAV,YAAY,CAACW,iBAAb,GAAiC,UAACC,QAAD,EAAWC,iBAAX,EAAiC;AAAA,MACzDC,IADyD,GACjDF,QADiD,CACzDE,IADyD;AAAA,MAEzDC,SAFyD,GAE5CD,IAF4C,CAEzDC,SAFyD;;AAIhE,MAAIA,SAAS,KAAKC,sBAAWC,YAA7B,EAA2C;AACzC,QAAMC,OAAO,GAAGL,iBAAiB,CAACM,QAAlB,CAA2BC,yBAA3B,EAA2CN,IAAI,CAACO,aAAhD,CAAhB;;AAEA,QAAIH,OAAJ,EAAa;AACXA,MAAAA,OAAO,CAACI,IAAR,CAAaC,SAAb,CAAuBT,IAAvB;AACD;AACF;AACF,CAXD;;AAaAd,YAAY,CAACwB,qBAAb,GAAqC,UAACC,SAAD,EAAYC,KAAZ,EAAsB;AACzD,MAAIC,OAAO,GAAG,EAAd;;AAEA,MAAID,KAAJ,EAAW;AACT,QAAIA,KAAK,IAAIA,KAAK,CAACE,IAAf,IAAuBF,KAAK,CAACE,IAAN,CAAWD,OAAtC,EAA+C;AAC7CA,MAAAA,OAAO,GAAGD,KAAK,CAACE,IAAN,CAAWD,OAArB;AACD;;AAED,QAAME,WAAW,GAAGF,OAAO,CAACG,IAAR,CAAa,UAACC,MAAD;AAAA,aAAYA,MAAM,CAACzB,GAAP,KAAemB,SAA3B;AAAA,KAAb,CAApB;;AAEA,QAAII,WAAW,IAAIA,WAAW,CAACR,aAA/B,EAA8C;AAC5C,aAAOQ,WAAW,CAACR,aAAnB;AACD;AACF;;AAED,SAAO,KAAP;AACD,CAhBD;AAmBA;AACA;AACA;AACA;AACA;AACA;;;AACArB,YAAY,CAACgC,YAAb,wFAA4B;AAAA;AAAA;AAAA;AAAA;AAAA;AACtBC,UAAAA,QADsB,GACX,KADW;AAAA;AAIlBC,UAAAA,EAJkB,GAIb,IAAIC,MAAM,CAACC,iBAAX,EAJa;AAAA;AAAA,iBAKJF,EAAE,CAACG,WAAH,CAAe;AAACC,YAAAA,mBAAmB,EAAE;AAAtB,WAAf,CALI;;AAAA;AAKlBC,UAAAA,KALkB;;AAOxB,cAAIA,KAAK,CAACC,GAAN,CAAUC,KAAV,CAAgB,4BAAhB,CAAJ,EAAmD;AACjDR,YAAAA,QAAQ,GAAG,IAAX;AACD;;AACDC,UAAAA,EAAE,CAACQ,KAAH;AAVwB;AAAA;;AAAA;AAAA;AAAA;;AAaxBC,+BAAYC,MAAZ,CAAmBC,KAAnB,CAAyB,8EAAzB;;AAbwB;AAAA,2CAgBnBZ,QAhBmB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAA5B;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAjC,YAAY,CAAC8C,gBAAb;AAAA,kGAAgC,kBAAgCC,OAAhC;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AACvBf,YAAAA,YADuB,GACPhC,YADO,CACvBgC,YADuB;AAAA,oBAEee,OAAO,IAAI,EAF1B,EAEvBC,YAFuB,SAEvBA,YAFuB,EAETC,oBAFS,SAETA,oBAFS;AAGxBC,YAAAA,KAHwB,GAGhB,GAHgB,EAGX;;AACbC,YAAAA,WAJwB,GAIV,GAJU,EAIL;;AACnBC,YAAAA,aALwB,GAKPJ,YAAY,KAAKK,SALV;AAMxBC,YAAAA,kBANwB,GAMHN,YAAY,IAAK,sBAAaA,YAAd,IAA+BG,WAN5C,EAQ9B;;AAR8B,iBAS1BF,oBAT0B;AAAA;AAAA;AAAA;;AAU5BjB,YAAAA,YAAY;AAVgB;;AAAA;AAAA;AAAA,mBAgBpBA,YAAY,EAhBQ;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAiB5BuB,kCAAQC,OAAR,CACE,IADF,EAEE;AACEC,cAAAA,IAAI,EAAE,eADR;AAEEC,cAAAA,QAAQ,EAAE;AAFZ,aAFF,EAMEC,0BAAeC,kBANjB;;AAQAjB,iCAAYC,MAAZ,CAAmBiB,GAAnB,CAAuB,oEAAvB;;AAzB4B;;AAAA;AAAA,iBA+B1BP,kBA/B0B;AAAA;AAAA;AAAA;;AAgC5BX,iCAAYC,MAAZ,CAAmBC,KAAnB,CAAyB,8EAAzB;;AAhC4B;;AAAA;AAqC9B;AACA,gBAAIO,aAAJ,EAAmB;AACjBG,oCAAQC,OAAR,CACE,IADF,EAEE;AACEC,gBAAAA,IAAI,EAAE,eADR;AAEEC,gBAAAA,QAAQ,EAAE;AAFZ,eAFF,EAMEC,0BAAeG,mBANjB;;AAQAnB,mCAAYC,MAAZ,CAAmBiB,GAAnB,CAAuB,2DAAvB;AACD,aAhD6B,CAkD9B;;;AACA1B,YAAAA,MAAM,CAAC4B,UAAP,CAAkB,YAAM;AACtB,kBAAMC,SAAS,GAAGhB,YAAY,IAAI,mBAAlC;AAEAhD,cAAAA,YAAY,CAAC8C,gBAAb,CAA8BmB,IAA9B,CAAmC,KAAnC,EAAyC;AAACjB,gBAAAA,YAAY,EAAEgB;AAAf,eAAzC;AACD,aAJD,EAIGd,KAJH;;AAnD8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAhC;;AAAA,WAA+CJ,gBAA/C;AAAA;AAAA;;AAAA,SAA+CA,gBAA/C;AAAA;;eA0De9C,Y","sourcesContent":["/* globals window */\n\nimport {\n  _LOCUS_ID_,\n  _INCOMING_,\n  _CREATED_,\n  LOCUSEVENT,\n  CORRELATION_ID,\n  EVENT_TRIGGERS\n} from '../constants';\nimport ParameterError from '../common/errors/parameter';\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport Trigger from '../common/events/trigger-proxy';\n\n/**\n  * Meetings Media Codec Missing Event\n  * Emitted when H.264 codec is not\n  * found in the browser.\n  * @event media:codec:missing\n  * @instance\n  * @memberof MeetingsUtil\n  */\n\n/**\n  * Meetings Media Codec Loaded Event\n  * Emitted when H.264 codec has been\n  * loaded in the browser.\n  * @event media:codec:loaded\n  * @instance\n  * @memberof MeetingsUtil\n  */\n\nconst MeetingsUtil = {};\n\nMeetingsUtil.extractDestination = (destination, type) => {\n  let dest = destination;\n\n  if (type === _LOCUS_ID_) {\n    if (!(destination && destination.url)) {\n      throw new ParameterError('You cannot create a meeting by locus without a locus.url defined');\n    }\n    dest = destination.url;\n  }\n\n  return dest;\n};\n\nMeetingsUtil.getMeetingAddedType = (type) => (type === _LOCUS_ID_ ? _INCOMING_ : _CREATED_);\n\nMeetingsUtil.handleRoapMercury = (envelope, meetingCollection) => {\n  const {data} = envelope;\n  const {eventType} = data;\n\n  if (eventType === LOCUSEVENT.MESSAGE_ROAP) {\n    const meeting = meetingCollection.getByKey(CORRELATION_ID, data.correlationId);\n\n    if (meeting) {\n      meeting.roap.roapEvent(data);\n    }\n  }\n};\n\nMeetingsUtil.checkForCorrelationId = (deviceUrl, locus) => {\n  let devices = [];\n\n  if (locus) {\n    if (locus && locus.self && locus.self.devices) {\n      devices = locus.self.devices;\n    }\n\n    const foundDevice = devices.find((device) => device.url === deviceUrl);\n\n    if (foundDevice && foundDevice.correlationId) {\n      return foundDevice.correlationId;\n    }\n  }\n\n  return false;\n};\n\n\n/**\n * Will check to see if the H.264 media codec is supported.\n * @async\n * @private\n * @returns {Promise<boolean>}\n */\nMeetingsUtil.hasH264Codec = async () => {\n  let hasCodec = false;\n\n  try {\n    const pc = new window.RTCPeerConnection();\n    const offer = await pc.createOffer({offerToReceiveVideo: true});\n\n    if (offer.sdp.match(/^a=rtpmap:\\d+\\s+H264\\/\\d+/m)) {\n      hasCodec = true;\n    }\n    pc.close();\n  }\n  catch (error) {\n    LoggerProxy.logger.error('Meetings:util#hasH264Codec --> Error creating peerConnection for H.264 test.');\n  }\n\n  return hasCodec;\n};\n\n\n/**\n * Notifies the user whether or not the H.264\n * codec is present. Will continuously check\n * until max duration.\n * @async\n * @private\n * @param {object} options\n * @param {Number} options.firstChecked Timestamp in milliseconds\n * @param {boolean} options.disableNotifications Default is false. Boolean to enable/disable notification and events\n * @returns {undefined}\n */\nMeetingsUtil.checkH264Support = async function checkH264Support(options) {\n  const {hasH264Codec} = MeetingsUtil;\n  const {firstChecked, disableNotifications} = options || {};\n  const delay = 5e3; // ms\n  const maxDuration = 3e5; // ms\n  const shouldTrigger = (firstChecked === undefined);\n  const shouldStopChecking = firstChecked && (Date.now() - firstChecked) >= maxDuration;\n\n  // Disable notifications and start H.264 download only\n  if (disableNotifications) {\n    hasH264Codec();\n\n    return;\n  }\n\n  // Codec loaded trigger event notification\n  if (await hasH264Codec()) {\n    Trigger.trigger(\n      this,\n      {\n        file: 'meetings/util',\n        function: 'checkH264Support'\n      },\n      EVENT_TRIGGERS.MEDIA_CODEC_LOADED\n    );\n    LoggerProxy.logger.log('Meetings:util#checkH264Support --> H264 codec loaded successfully.');\n\n    return;\n  }\n\n  // Stop checking if past the timelimit\n  if (shouldStopChecking) {\n    LoggerProxy.logger.error('Meetings:util#checkH264Support --> Timed out waiting for H264 codec to load.');\n\n    return;\n  }\n\n  // Trigger only once\n  if (shouldTrigger) {\n    Trigger.trigger(\n      this,\n      {\n        file: 'meetings/util',\n        function: 'checkH264Support'\n      },\n      EVENT_TRIGGERS.MEDIA_CODEC_MISSING\n    );\n    LoggerProxy.logger.log('Meetings:util#checkH264Support --> H264 codec is missing.');\n  }\n\n  // Keep checking in intervals to see if codec loaded\n  window.setTimeout(() => {\n    const timestamp = firstChecked || Date.now();\n\n    MeetingsUtil.checkH264Support.call(this, {firstChecked: timestamp});\n  }, delay);\n};\n\nexport default MeetingsUtil;\n"]}