"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _now = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/date/now"));

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _constants = require("../constants");

var _parameter = _interopRequireDefault(require("../common/errors/parameter"));

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _triggerProxy = _interopRequireDefault(require("../common/events/trigger-proxy"));

/* globals window */

/**
  * Meetings Media Codec Missing Event
  * Emitted when H.264 codec is not
  * found in the browser.
  * @event media:codec:missing
  * @instance
  * @memberof MeetingsUtil
  */

/**
  * Meetings Media Codec Loaded Event
  * Emitted when H.264 codec has been
  * loaded in the browser.
  * @event media:codec:loaded
  * @instance
  * @memberof MeetingsUtil
  */
var MeetingsUtil = {};

MeetingsUtil.extractDestination = function (destination, type) {
  var dest = destination;

  if (type === _constants._LOCUS_ID_) {
    if (!(destination && destination.url)) {
      throw new _parameter.default('You cannot create a meeting by locus without a locus.url defined');
    }

    dest = destination.url;
  }

  return dest;
};

MeetingsUtil.getMeetingAddedType = function (type) {
  return type === _constants._LOCUS_ID_ ? _constants._INCOMING_ : _constants._CREATED_;
};

MeetingsUtil.handleRoapMercury = function (envelope, meetingCollection) {
  var data = envelope.data;
  var eventType = data.eventType;

  if (eventType === _constants.LOCUSEVENT.MESSAGE_ROAP) {
    var meeting = meetingCollection.getByKey(_constants.CORRELATION_ID, data.correlationId);

    if (meeting) {
      meeting.roap.roapEvent(data);
    }
  }
};

MeetingsUtil.checkForCorrelationId = function (deviceUrl, locus) {
  var devices = [];

  if (locus) {
    if (locus && locus.self && locus.self.devices) {
      devices = locus.self.devices;
    }

    var foundDevice = devices.find(function (device) {
      return device.url === deviceUrl;
    });

    if (foundDevice && foundDevice.correlationId) {
      return foundDevice.correlationId;
    }
  }

  return false;
};
/**
 * Will check to see if the H.264 media codec is supported.
 * @async
 * @private
 * @returns {Promise<boolean>}
 */


MeetingsUtil.hasH264Codec = /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
  var hasCodec, pc, offer;
  return _regenerator.default.wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          hasCodec = false;
          _context.prev = 1;
          pc = new window.RTCPeerConnection();
          _context.next = 5;
          return pc.createOffer({
            offerToReceiveVideo: true
          });

        case 5:
          offer = _context.sent;

          if (offer.sdp.match(/^a=rtpmap:\d+\s+H264\/\d+/m)) {
            hasCodec = true;
          }

          pc.close();
          _context.next = 13;
          break;

        case 10:
          _context.prev = 10;
          _context.t0 = _context["catch"](1);

          _loggerProxy.default.logger.error('Meetings:util#hasH264Codec --> Error creating peerConnection for H.264 test.');

        case 13:
          return _context.abrupt("return", hasCodec);

        case 14:
        case "end":
          return _context.stop();
      }
    }
  }, _callee, null, [[1, 10]]);
}));
/**
 * Notifies the user whether or not the H.264
 * codec is present. Will continuously check
 * until max duration.
 * @async
 * @private
 * @param {object} options
 * @param {Number} options.firstChecked Timestamp in milliseconds
 * @param {boolean} options.disableNotifications Default is false. Boolean to enable/disable notification and events
 * @returns {undefined}
 */

MeetingsUtil.checkH264Support = /*#__PURE__*/function () {
  var _checkH264Support = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(options) {
    var _this = this;

    var hasH264Codec, _ref2, firstChecked, disableNotifications, delay, maxDuration, shouldTrigger, shouldStopChecking;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            hasH264Codec = MeetingsUtil.hasH264Codec;
            _ref2 = options || {}, firstChecked = _ref2.firstChecked, disableNotifications = _ref2.disableNotifications;
            delay = 5e3; // ms

            maxDuration = 3e5; // ms

            shouldTrigger = firstChecked === undefined;
            shouldStopChecking = firstChecked && (0, _now.default)() - firstChecked >= maxDuration; // Disable notifications and start H.264 download only

            if (!disableNotifications) {
              _context2.next = 9;
              break;
            }

            hasH264Codec();
            return _context2.abrupt("return");

          case 9:
            _context2.next = 11;
            return hasH264Codec();

          case 11:
            if (!_context2.sent) {
              _context2.next = 15;
              break;
            }

            _triggerProxy.default.trigger(this, {
              file: 'meetings/util',
              function: 'checkH264Support'
            }, _constants.EVENT_TRIGGERS.MEDIA_CODEC_LOADED);

            _loggerProxy.default.logger.log('Meetings:util#checkH264Support --> H264 codec loaded successfully.');

            return _context2.abrupt("return");

          case 15:
            if (!shouldStopChecking) {
              _context2.next = 18;
              break;
            }

            _loggerProxy.default.logger.error('Meetings:util#checkH264Support --> Timed out waiting for H264 codec to load.');

            return _context2.abrupt("return");

          case 18:
            // Trigger only once
            if (shouldTrigger) {
              _triggerProxy.default.trigger(this, {
                file: 'meetings/util',
                function: 'checkH264Support'
              }, _constants.EVENT_TRIGGERS.MEDIA_CODEC_MISSING);

              _loggerProxy.default.logger.log('Meetings:util#checkH264Support --> H264 codec is missing.');
            } // Keep checking in intervals to see if codec loaded


            window.setTimeout(function () {
              var timestamp = firstChecked || (0, _now.default)();
              MeetingsUtil.checkH264Support.call(_this, {
                firstChecked: timestamp
              });
            }, delay);

          case 20:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  function checkH264Support(_x) {
    return _checkH264Support.apply(this, arguments);
  }

  return checkH264Support;
}();

var _default = MeetingsUtil;
exports.default = _default;
//# sourceMappingURL=util.js.map
