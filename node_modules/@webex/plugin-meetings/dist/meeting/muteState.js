"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _parameter = _interopRequireDefault(require("../common/errors/parameter"));

var _permission = _interopRequireDefault(require("../common/errors/permission"));

var _media = _interopRequireDefault(require("../media"));

var _util = _interopRequireDefault(require("../meeting/util"));

var _constants = require("../constants");

/* Certain aspects of server interaction for video muting are not implemented as we currently don't support remote muting of video.
   If we ever need to support it, search for REMOTE_MUTE_VIDEO_MISSING_IMPLEMENTATION string to find the places that need updating
*/
var createMuteState = function createMuteState(type, meeting, mediaDirection) {
  if (type === _constants.AUDIO && !mediaDirection.sendAudio) {
    return null;
  }

  if (type === _constants.VIDEO && !mediaDirection.sendVideo) {
    return null;
  }

  _loggerProxy.default.logger.info("Meeting:muteState#createMuteState --> ".concat(type, ": creating MuteState for meeting id ").concat(meeting === null || meeting === void 0 ? void 0 : meeting.id));

  return new MuteState(type, meeting);
};
/* The purpose of this class is to manage the local and remote mute state and make sure that the server state always matches
   the last requested state by the client.

   More info about Locus muting API: https://sqbu-github.cisco.com/pages/WebExSquared/locus/guides/mute.html#
*/


var MuteState = /*#__PURE__*/function () {
  function MuteState(type, meeting) {
    (0, _classCallCheck2.default)(this, MuteState);

    if (type !== _constants.AUDIO && type !== _constants.VIDEO) {
      throw new _parameter.default('Mute state is designed for handling audio or video only');
    }

    this.type = type;
    this.state = {
      client: {
        localMute: false
      },
      server: {
        localMute: false,
        // initial values available only for audio (REMOTE_MUTE_VIDEO_MISSING_IMPLEMENTATION)
        remoteMute: type === _constants.AUDIO ? meeting.remoteMuted : false,
        unmuteAllowed: type === _constants.AUDIO ? meeting.unmuteAllowed : true
      },
      syncToServerInProgress: false
    }; // these 2 hold the resolve, reject methods for the promise we returned to the client in last handleClientRequest() call

    this.pendingPromiseResolve = null;
    this.pendingPromiseReject = null;
  }
  /**
   * Handles mute/unmute request from the client/user. Returns a promise that's resolved once the server update is completed or
   * at the point that this request becomese superseded by another client request.
   *
   * The client doesn't have to wait for the returned promise to resolve before calling handleClientRequest() again. If
   * handleClientRequest() is called again before the previous one resolved, the MuteState class will make sure that eventually
   * the server state will match the last requested state from the client.
   *
   * @public
   * @memberof MuteState
   * @param {Object} [meeting] the meeting object
   * @param {Boolean} [mute] true for muting, false for unmuting request
   * @returns {Promise}
   */


  (0, _createClass2.default)(MuteState, [{
    key: "handleClientRequest",
    value: function handleClientRequest(meeting, mute) {
      var _this = this;

      _loggerProxy.default.logger.info("Meeting:muteState#handleClientRequest --> ".concat(this.type, ": user requesting new mute state: ").concat(mute));

      if (!mute && !this.state.server.unmuteAllowed) {
        return _promise.default.reject(new _permission.default('User is not allowed to unmute self (hard mute feature is being used)'));
      } // we don't check if we're already in the same state, because even if we were, we would still have to apply the mute state locally,
      // because the client may have changed the audio/vidoe tracks


      this.state.client.localMute = mute;
      this.applyClientStateLocally(meeting);
      return new _promise.default(function (resolve, reject) {
        if (_this.pendingPromiseResolve) {
          // resolve the last promise we returned to the client as the client has issued a new request that has superseded the previous one
          _this.pendingPromiseResolve();
        }

        _this.pendingPromiseResolve = resolve;
        _this.pendingPromiseReject = reject;

        _this.applyClientStateToServer(meeting);
      });
    }
    /**
     * Applies the current mute state to the local track (by enabling or disabling it accordingly)
     *
     * @public
     * @param {Object} [meeting] the meeting object
     * @memberof MuteState
     * @returns {void}
     */

  }, {
    key: "applyClientStateLocally",
    value: function applyClientStateLocally(meeting) {
      _media.default.setLocalTrack(!this.state.client.localMute, this.type === _constants.AUDIO ? meeting.mediaProperties.audioTrack : meeting.mediaProperties.videoTrack);
    }
    /**
     * Updates the server local and remote mute values so that they match the current client desired state.
     *
     * @private
     * @param {Object} [meeting] the meeting object
     * @memberof MuteState
     * @returns {void}
     */

  }, {
    key: "applyClientStateToServer",
    value: function applyClientStateToServer(meeting) {
      var _this2 = this;

      if (this.state.syncToServerInProgress) {
        _loggerProxy.default.logger.info("Meeting:muteState#applyClientStateToServer --> ".concat(this.type, ": request to server in progress, we need to wait for it to complete"));

        return;
      }

      var localMuteRequiresSync = this.state.client.localMute !== this.state.server.localMute;
      var remoteMuteRequiresSync = !this.state.client.localMute && this.state.server.remoteMute;

      _loggerProxy.default.logger.info("Meeting:muteState#applyClientStateToServer --> ".concat(this.type, ": localMuteRequiresSync: ").concat(localMuteRequiresSync, " (").concat(this.state.client.localMute, " ?= ").concat(this.state.server.localMute, ")"));

      _loggerProxy.default.logger.info("Meeting:muteState#applyClientStateToServer --> ".concat(this.type, ": remoteMuteRequiresSync: ").concat(remoteMuteRequiresSync));

      if (!localMuteRequiresSync && !remoteMuteRequiresSync) {
        _loggerProxy.default.logger.info("Meeting:muteState#applyClientStateToServer --> ".concat(this.type, ": client state already matching server state, nothing to do"));

        if (this.pendingPromiseResolve) {
          this.pendingPromiseResolve();
        }

        this.pendingPromiseResolve = null;
        this.pendingPromiseReject = null;
        return;
      }

      this.state.syncToServerInProgress = true; // first sync local mute with server

      var localMuteSyncPromise = localMuteRequiresSync ? this.sendLocalMuteRequestToServer(meeting) : _promise.default.resolve();
      localMuteSyncPromise.then(function () {
        return (// then follow it up with remote mute sync
          remoteMuteRequiresSync ? _this2.sendRemoteMuteRequestToServer(meeting) : _promise.default.resolve()
        );
      }).then(function () {
        _this2.state.syncToServerInProgress = false;

        _loggerProxy.default.logger.info("Meeting:muteState#applyClientStateToServer --> ".concat(_this2.type, ": sync with server completed")); // need to check if a new sync is required, because this.state.client may have changed while we were doing the current sync


        _this2.applyClientStateToServer(meeting);
      }).catch(function (e) {
        _this2.state.syncToServerInProgress = false;

        if (_this2.pendingPromiseReject) {
          _this2.pendingPromiseReject(e);
        }

        _this2.pendingPromiseResolve = null;
        _this2.pendingPromiseReject = null;
      });
    }
    /**
     * Sets the local mute value in the server
     *
     * @private
     * @param {Object} [meeting] the meeting object
     * @memberof MuteState
     * @returns {Promise}
     */

  }, {
    key: "sendLocalMuteRequestToServer",
    value: function sendLocalMuteRequestToServer(meeting) {
      var _meeting$audio,
          _meeting$video,
          _this3 = this;

      var audioMuted = this.type === _constants.AUDIO ? this.state.client.localMute : (_meeting$audio = meeting.audio) === null || _meeting$audio === void 0 ? void 0 : _meeting$audio.state.client.localMute;
      var videoMuted = this.type === _constants.VIDEO ? this.state.client.localMute : (_meeting$video = meeting.video) === null || _meeting$video === void 0 ? void 0 : _meeting$video.state.client.localMute;

      _loggerProxy.default.logger.info("Meeting:muteState#sendLocalMuteRequestToServer --> ".concat(this.type, ": sending local mute (audio=").concat(audioMuted, ", video=").concat(videoMuted, ") to server"));

      return _util.default.remoteUpdateAudioVideo(audioMuted, videoMuted, meeting).then(function (locus) {
        _loggerProxy.default.logger.info("Meeting:muteState#sendLocalMuteRequestToServer --> ".concat(_this3.type, ": local mute (audio=").concat(audioMuted, ", video=").concat(videoMuted, ") applied to server"));

        _this3.state.server.localMute = _this3.type === _constants.AUDIO ? audioMuted : videoMuted;
        meeting.locusInfo.onFullLocus(locus);
        return locus;
      }).catch(function (remoteUpdateError) {
        _loggerProxy.default.logger.warn("Meeting:muteState#sendLocalMuteRequestToServer --> ".concat(_this3.type, ": failed to apply local mute (audio=").concat(audioMuted, ", video=").concat(videoMuted, ") to server: ").concat(remoteUpdateError));

        return _promise.default.reject(remoteUpdateError);
      });
    }
    /**
     * Sets the remote mute value in the server
     *
     * @private
     * @param {Object} [meeting] the meeting object
     * @memberof MuteState
     * @returns {Promise}
     */

  }, {
    key: "sendRemoteMuteRequestToServer",
    value: function sendRemoteMuteRequestToServer(meeting) {
      var _this4 = this;

      if (this.type === _constants.AUDIO) {
        var remoteMute = this.state.client.localMute;

        _loggerProxy.default.logger.info("Meeting:muteState#sendRemoteMuteRequestToServer --> ".concat(this.type, ": sending remote mute:").concat(remoteMute, " to server"));

        return meeting.members.muteMember(meeting.members.selfId, remoteMute).then(function () {
          _loggerProxy.default.logger.info("Meeting:muteState#sendRemoteMuteRequestToServer --> ".concat(_this4.type, ": remote mute:").concat(remoteMute, " applied to server"));

          _this4.state.server.remoteMute = remoteMute;
        }).catch(function (remoteUpdateError) {
          _loggerProxy.default.logger.warn("Meeting:muteState#sendRemoteMuteRequestToServer --> ".concat(_this4.type, ": failed to apply remote mute ").concat(remoteMute, " to server: ").concat(remoteUpdateError));

          return _promise.default.reject(remoteUpdateError);
        });
      } // for now we don't need to support remote muting of video (REMOTE_MUTE_VIDEO_MISSING_IMPLEMENTATION)


      this.state.server.remoteMute = this.state.client.localMute;
      return _promise.default.resolve();
    }
    /**
     * This method should be called whenever the server remote mute state is changed
     *
     * @public
     * @memberof MuteState
     * @param {Boolean} [muted] true if user is remotely muted, false otherwise
     * @param {Boolean} [unmuteAllowed] indicates if user is allowed to unmute self (false when "hard mute" feature is used)
     * @returns {undefined}
     */

  }, {
    key: "handleServerRemoteMuteUpdate",
    value: function handleServerRemoteMuteUpdate(muted, unmuteAllowed) {
      _loggerProxy.default.logger.info("Meeting:muteState#handleServerRemoteMuteUpdate --> ".concat(this.type, ": updating server remoteMute to (").concat(muted, ")"));

      this.state.server.remoteMute = muted;
      this.state.server.unmuteAllowed = unmuteAllowed;
    }
    /**
     * This method should be called whenever we receive from the server a requirement to locally unmute
     *
     * @public
     * @memberof MuteState
     * @param {Object} [meeting] the meeting object
     * @returns {undefined}
     */

  }, {
    key: "handleServerLocalUnmuteRequired",
    value: function handleServerLocalUnmuteRequired(meeting) {
      _loggerProxy.default.logger.info("Meeting:muteState#handleServerLocalUnmuteRequired --> ".concat(this.type, ": localAudioUnmuteRequired received -> doing local unmute"));

      this.state.server.remoteMute = false;
      this.state.client.localMute = false;

      if (this.pendingPromiseReject) {
        this.pendingPromiseReject(new Error('Server requested local unmute - this overrides any client request in progress'));
        this.pendingPromiseResolve = null;
        this.pendingPromiseReject = null;
      }

      this.applyClientStateLocally(meeting);
      this.applyClientStateToServer(meeting);
    }
    /**
     * Returns true if the user is locally or remotely muted
     *
     * @public
     * @memberof MuteState
     * @returns {Boolean}
     */

  }, {
    key: "isMuted",
    value: function isMuted() {
      return this.state.client.localMute || this.state.server.localMute || this.state.server.remoteMute;
    }
    /**
     * Returns true if the user is muted as a result of the client request (and not remotely muted)
     *
     * @public
     * @memberof MuteState
     * @returns {Boolean}
     */

  }, {
    key: "isSelf",
    value: function isSelf() {
      return this.state.client.localMute && !this.state.server.remoteMute;
    } // defined for backwards compatibility with the old AudioStateMachine/VideoStateMachine classes

  }, {
    key: "muted",
    get: function get() {
      return this.isMuted();
    } // defined for backwards compatibility with the old AudioStateMachine/VideoStateMachine classes

  }, {
    key: "self",
    get: function get() {
      return this.isSelf();
    }
  }]);
  return MuteState;
}();

var _default = createMuteState;
exports.default = _default;
//# sourceMappingURL=muteState.js.map
