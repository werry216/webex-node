"use strict";

var _Reflect$construct = require("@babel/runtime-corejs2/core-js/reflect/construct");

var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");

var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _debounce2 = _interopRequireDefault(require("lodash/debounce"));

var _uuid = _interopRequireDefault(require("uuid"));

var _webexCore = require("@webex/webex-core");

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _constants = require("../constants");

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class MeetingRequest
 */
var MeetingRequest = /*#__PURE__*/function (_StatelessWebexPlugin) {
  (0, _inherits2.default)(MeetingRequest, _StatelessWebexPlugin);

  var _super = _createSuper(MeetingRequest);

  function MeetingRequest(attrs, options) {
    var _this;

    (0, _classCallCheck2.default)(this, MeetingRequest);
    _this = _super.call(this, attrs, options);
    _this.changeVideoLayoutDebounced = (0, _debounce2.default)(_this.changeVideoLayout, 2000, {
      leading: true,
      trailing: true
    });
    return _this;
  }
  /**
   * Make a network request to join a meeting
   * @param {Object} options
   * @param {String} options.sipUri
   * @param {String} options.deviceUrl
   * @param {String} options.locusUrl
   * @param {String} options.resourceId,
   * @param {String} options.correlationId
   * @param {boolean} options.ensureConversation
   * @param {boolean} options.moderator
   * @param {boolean} options.pin
   * @param {boolean} options.moveToResource
   * @param {Object} options.roapMessage
   * @returns {Promise}
   */


  (0, _createClass2.default)(MeetingRequest, [{
    key: "joinMeeting",
    value: function () {
      var _joinMeeting = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(options) {
        var sipUri, deviceUrl, locusUrl, resourceId, correlationId, ensureConversation, moderator, pin, moveToResource, roapMessage, preferTranscoding, url, body;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                sipUri = options.sipUri, deviceUrl = options.deviceUrl, locusUrl = options.locusUrl, resourceId = options.resourceId, correlationId = options.correlationId, ensureConversation = options.ensureConversation, moderator = options.moderator, pin = options.pin, moveToResource = options.moveToResource, roapMessage = options.roapMessage, preferTranscoding = options.preferTranscoding;

                _loggerProxy.default.logger.info('Meeting:request#joinMeeting --> Joining a meeting', correlationId);

                url = '';
                body = {
                  device: {
                    url: deviceUrl,
                    deviceType: this.config.meetings.deviceType
                  },
                  usingResource: resourceId || null,
                  moveMediaToResource: resourceId && moveToResource || false,
                  correlationId: correlationId,
                  respOnlySdp: true,
                  allowMultiDevice: true,
                  ensureConversation: ensureConversation || false,
                  supportsNativeLobby: 1,
                  clientMediaPreferences: {
                    preferTranscoding: preferTranscoding !== null && preferTranscoding !== void 0 ? preferTranscoding : true
                  }
                };

                if (this.webex.meetings.clientRegion) {
                  body.device.countryCode = this.webex.meetings.clientRegion.countryCode;
                  body.device.regionCode = this.webex.meetings.clientRegion.regionCode;
                }

                if (moderator !== undefined) {
                  body.moderator = moderator;
                }

                if (pin !== undefined) {
                  body.pin = pin;
                }

                if (!locusUrl) {
                  _context.next = 11;
                  break;
                }

                url = "".concat(locusUrl, "/").concat(_constants.PARTICIPANT);
                _context.next = 23;
                break;

              case 11:
                if (!sipUri) {
                  _context.next = 23;
                  break;
                }

                _context.prev = 12;
                _context.next = 15;
                return this.webex.internal.services.waitForCatalog('postauth');

              case 15:
                url = "".concat(this.webex.internal.services.get('locus'), "/").concat(_constants.LOCI, "/").concat(_constants.CALL);
                body.invitee = {
                  address: sipUri
                };
                _context.next = 23;
                break;

              case 19:
                _context.prev = 19;
                _context.t0 = _context["catch"](12);

                _loggerProxy.default.logger.error("Meeting:request#joinMeeting --> ".concat(_context.t0));

                throw _context.t0;

              case 23:
                // TODO: -- this will be resolved in SDK request
                url = url.concat("?".concat(_constants.ALTERNATE_REDIRECT_TRUE));

                if (resourceId === sipUri) {
                  body.callPreferences = {
                    requestedMedia: [_constants._SLIDES_]
                  };
                }

                if (roapMessage) {
                  body.localMedias = roapMessage.localMedias;
                }

                return _context.abrupt("return", this.request({
                  method: _constants.HTTP_VERBS.POST,
                  uri: url,
                  body: body
                }));

              case 27:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[12, 19]]);
      }));

      function joinMeeting(_x) {
        return _joinMeeting.apply(this, arguments);
      }

      return joinMeeting;
    }()
    /**
     * Syns the missed delta event
     * @param {Object} options
     * @param {boolen} options.desync flag to get partial or whole locus object
     * @param {String} options.syncUrl sync url to get ht elatest locus delta
     * @returns {Promise}
     */

  }, {
    key: "syncMeeting",
    value: function syncMeeting(options) {
      /* eslint-disable no-else-return */
      var desync = options.desync;
      var syncUrl = options.syncUrl;
      /* istanbul ignore else */

      if (desync) {
        // check for existing URL parameters
        syncUrl = syncUrl.concat(syncUrl.split('?')[1] ? '&' : '?').concat("".concat(_constants.LOCUS.SYNCDEBUG, "=").concat(desync));
      }

      return this.request({
        method: _constants.HTTP_VERBS.GET,
        uri: syncUrl
      }) // TODO: Handle if delta sync failed . Get the full locus object
      .catch(function (err) {
        _loggerProxy.default.logger.error("Meeting:request#syncMeeting --> Error syncing meeting, error ".concat(err));

        return err;
      });
    }
    /**
     * Request to get the complete locus object
     * @param {Object} options
     * @param {boolen} options.desync flag to get partial or whole locus object
     * @param {String} options.locusUrl sync url to get ht elatest locus delta
     * @returns {Promise}
     */

  }, {
    key: "getFullLocus",
    value: function getFullLocus(options) {
      var locusUrl = options.locusUrl;
      var desync = options.desync;

      if (locusUrl) {
        if (desync) {
          locusUrl += "?".concat(_constants.LOCUS.SYNCDEBUG, "=").concat(desync);
        }

        return this.request({
          method: _constants.HTTP_VERBS.GET,
          uri: locusUrl
        }).catch(function (err) {
          _loggerProxy.default.logger.error("Meeting:request#getFullLocus --> Error getting full locus, error ".concat(err));

          return err;
        });
      }

      return _promise.default.reject();
    }
    /**
     * Make a network request to leave a meeting
     * @param {Object} options
     * @param {Url} options.locusUrl
     * @param {String} options.selfId
     * @param {Url} options.deviceUrl
     * @param {String} options.resourceId,
     * @param {String} options.correlationId
     * @returns {Promise}
     */

  }, {
    key: "leaveMeeting",
    value: function leaveMeeting(_ref) {
      var locusUrl = _ref.locusUrl,
          selfId = _ref.selfId,
          url = _ref.deviceUrl,
          resourceId = _ref.resourceId,
          correlationId = _ref.correlationId;

      _loggerProxy.default.logger.info('Meeting:request#leaveMeeting --> Leaving a meeting', correlationId);

      var uri = "".concat(locusUrl, "/").concat(_constants.PARTICIPANT, "/").concat(selfId, "/").concat(_constants.LEAVE);
      var body = {
        device: {
          deviceType: this.config.meetings.deviceType,
          url: url
        },
        usingResource: resourceId || null,
        correlationId: correlationId
      };
      return this.request({
        method: _constants.HTTP_VERBS.PUT,
        uri: uri,
        body: body
      });
    }
    /**
     * Make a network request to acknowledge a meeting
     * @param {Object} options
     * @param {String} options.locusUrl
     * @param {String} options.deviceUrl
     * @param {String} options.correlationId
     * @returns {Promise}
     */

  }, {
    key: "acknowledgeMeeting",
    value: function acknowledgeMeeting(options) {
      var uri = "".concat(options.locusUrl, "/").concat(_constants.PARTICIPANT, "/").concat(_constants.ALERT);
      var body = {
        device: {
          deviceType: this.config.meetings.deviceType,
          url: options.deviceUrl
        },
        correlationId: options.correlationId
      };
      return this.request({
        method: _constants.HTTP_VERBS.PUT,
        uri: uri,
        body: body
      });
    }
    /**
     * Make a network request to acknowledge a meeting
     * @param {Object} options
     * @param {String} options.locusUrl
     * @param {String} options.deviceUrl
     * @param {String} options.id
     * @returns {Promise}
     */

  }, {
    key: "recordMeeting",
    value: function recordMeeting(options) {
      var uri = "".concat(options.locusUrl, "/").concat(_constants.CONTROLS);
      var body = {
        record: {
          recording: options.recording,
          paused: options.paused
        }
      };
      return this.request({
        method: _constants.HTTP_VERBS.PATCH,
        uri: uri,
        body: body
      });
    }
  }, {
    key: "lockMeeting",
    value: function lockMeeting(options) {
      var uri = "".concat(options.locusUrl, "/").concat(_constants.CONTROLS);
      var body = {
        lock: {
          locked: options.lock
        }
      };
      return this.request({
        method: _constants.HTTP_VERBS.PATCH,
        uri: uri,
        body: body
      });
    }
    /**
     * Make a network request to decline a meeting
     * @param {Object} options
     * @param {String} options.locusUrl
     * @param {String} options.deviceUrl
     * @param {String} options.reason
     * @returns {Promise}
     */

  }, {
    key: "declineMeeting",
    value: function declineMeeting(options) {
      var uri = "".concat(options.locusUrl, "/").concat(_constants.PARTICIPANT, "/").concat(_constants.DECLINE);

      var body = _objectSpread({
        device: {
          deviceType: this.config.meetings.deviceType,
          url: options.deviceUrl
        }
      }, options.reason && {
        reason: options.reason
      });

      return this.request({
        method: _constants.HTTP_VERBS.PUT,
        uri: uri,
        body: body
      });
    }
    /**
     * Toggle remote audio and/or video
     * @param {Object} options options for toggling
     * @param {String} options.selfId Locus self id??
     * @param {String} options.locusUrl Locus url
     * @param {String} options.deviceUrl Url of a device
     * @param {String} options.resourceId Populated if you are paired to a device
     * @param {String} options.localMedias local sdps
     * @returns {Promise}
     */

  }, {
    key: "remoteAudioVideoToggle",
    value: function remoteAudioVideoToggle(options) {
      var _options$preferTransc;

      var uri = "".concat(options.locusUrl, "/").concat(_constants.PARTICIPANT, "/").concat(options.selfId, "/").concat(_constants.MEDIA);
      var body = {
        device: {
          deviceType: this.config.meetings.deviceType,
          url: options.deviceUrl
        },
        usingResource: options.resourceId || null,
        correlationId: options.correlationId,
        respOnlySdp: true,
        localMedias: options.localMedias,
        clientMediaPreferences: {
          preferTranscoding: (_options$preferTransc = options.preferTranscoding) !== null && _options$preferTransc !== void 0 ? _options$preferTransc : true
        }
      };
      return this.request({
        method: _constants.HTTP_VERBS.PUT,
        uri: uri,
        body: body
      });
    }
    /**
     * change the content floor grant
     * @param {Object} options options for floor grant
     * @param {String} options.disposition floor action (granted/released)
     * @param {String} options.personUrl personUrl who is requesting floor
     * @param {String} options.deviceUrl Url of a device
     * @param {String} options.resourceId Populated if you are paired to a device
     * @param {String} options.uri floor grant uri
     * @returns {Promise}
     */

  }, {
    key: "changeMeetingFloor",
    value: function changeMeetingFloor(options) {
      var floorReq = {
        disposition: options.disposition
      };
      /* istanbul ignore else */

      if (options.disposition === _constants.FLOOR_ACTION.GRANTED) {
        floorReq = {
          beneficiary: {
            url: options.personUrl,
            devices: [{
              deviceType: this.config.meetings.deviceType,
              url: options.deviceUrl
            }]
          },
          disposition: options.disposition,
          requester: {
            url: options.personUrl
          }
        };
      }

      return this.request({
        uri: options.uri,
        method: _constants.HTTP_VERBS.PUT,
        body: {
          floor: floorReq,
          resourceUrl: options.resourceUrl
        }
      });
    }
    /**
     * Sends a request to the DTMF endpoint to send tones
     * @param {Object} options
     * @param {String} options.locusUrl
     * @param {String} options.deviceUrl
     * @param {String} options.tones a string of one or more DTMF tones to send
     * @returns {Promise}
     */

  }, {
    key: "sendDTMF",
    value: function sendDTMF(_ref2) {
      var locusUrl = _ref2.locusUrl,
          deviceUrl = _ref2.deviceUrl,
          tones = _ref2.tones;
      return this.request({
        method: _constants.HTTP_VERBS.POST,
        uri: "".concat(locusUrl, "/").concat(_constants.SEND_DTMF_ENDPOINT),
        body: {
          deviceUrl: deviceUrl,
          dtmf: {
            correlationId: _uuid.default.v4(),
            tones: tones
          }
        }
      });
    }
    /**
     * Sends a request to the controls endpoint to set the video layout
     * @param {Object} options
     * @param {String} options.locusUrl
     * @param {String} options.deviceUrl
     * @param {String} options.layoutType a layout type that should be available in meeting constants LAYOUT_TYPES
     * @param {Object} options.main preferred dimensions for the remote main video stream
     * @param {Number} options.main.width preferred width of main video stream
     * @param {Number} options.main.height preferred height of main video stream
     * @param {Object} options.content preferred dimensions for the remote content share stream
     * @param {Number} options.content.width preferred width of content share stream
     * @param {Number} options.content.height preferred height of content share stream
     * @returns {Promise}
     */

  }, {
    key: "changeVideoLayout",
    value: function changeVideoLayout(_ref3) {
      var locusUrl = _ref3.locusUrl,
          deviceUrl = _ref3.deviceUrl,
          layoutType = _ref3.layoutType,
          main = _ref3.main,
          content = _ref3.content;

      // send main/content renderInfo only if both width and height are specified
      if (main && (!main.width || !main.height)) {
        return _promise.default.reject(new Error("Both width and height must be specified. One of them is missing for main: ".concat((0, _stringify.default)(main))));
      }

      if (content && (!content.width || !content.height)) {
        return _promise.default.reject(new Error("Both width and height must be specified. One of them is missing for content: ".concat((0, _stringify.default)(content))));
      }

      var renderInfoMain = main ? {
        width: main.width,
        height: main.height
      } : undefined;
      var renderInfoContent = content ? {
        width: content.width,
        height: content.height
      } : undefined;
      var layoutParams = renderInfoMain || renderInfoContent ? {
        renderInfo: {
          main: renderInfoMain,
          content: renderInfoContent
        }
      } : undefined;
      return this.request({
        method: _constants.HTTP_VERBS.PUT,
        uri: "".concat(locusUrl, "/").concat(_constants.CONTROLS),
        body: {
          layout: {
            deviceUrl: deviceUrl,
            type: layoutType,
            layoutParams: layoutParams
          }
        }
      });
    }
  }]);
  return MeetingRequest;
}(_webexCore.StatelessWebexPlugin);

exports.default = MeetingRequest;
//# sourceMappingURL=request.js.map
