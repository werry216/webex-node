"use strict";

var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");

var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _constants = require("../constants");

var _config = _interopRequireDefault(require("../config"));

var _peerConnectionManager = _interopRequireDefault(require("../peer-connection-manager"));

var _reconnection = _interopRequireDefault(require("../common/errors/reconnection"));

var _media = _interopRequireDefault(require("../common/errors/media"));

var _browserDetection = _interopRequireDefault(require("../common/browser-detection"));

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

var _BrowserDetection = (0, _browserDetection.default)(),
    isBrowser = _BrowserDetection.isBrowser;
/**
 * MediaDirection
 * @typedef {Object} MediaDirection
 * @property {boolean} sendAudio
 * @property {boolean} receiveAudio
 * @property {boolean} sendVideo
 * @property {boolean} receiveVideo
 * @property {boolean} sendShare
 * @property {boolean} receiveShare
 */

/**
 * SendOptions
 * @typedef {Object} SendOptions
 * @property sendAudio
 * @property sendVideo
 * @property sendShare
 * @property isSharing
 * @property {Object} sharePreferences
 */

/**
 *
 * @public
 * @export
 * Mimic browser APIs as "the ultimate browser".
 * Handles the quirks of each browser.
 * Extends and enhances adapter.js, i.e., the "media" file from the web client.
 */


var Media = {};
/**
 * @param {boolean} enabled
 * @param {MediaStreamTrack} track
 * @returns {Boolean}
 * @public
 */

Media.setLocalTrack = function (enabled, track) {
  if (track) {
    track.enabled = enabled;
    return true;
  }

  return false;
};
/**
 * @param {RTCPeerConnection} peerConnection
 * @param {Object} meetingProperties
 * @param {string} meetingProperties.meetingId
 * @param {string} meetingProperties.remoteQualityLevel LOW|MEDIUM|HIGH
 * @returns {Promise}
 */


Media.reconnectMedia = function (peerConnection, _ref) {
  var meetingId = _ref.meetingId,
      remoteQualityLevel = _ref.remoteQualityLevel,
      enableRtx = _ref.enableRtx;

  if (peerConnection.connectionState === _constants.PEER_CONNECTION_STATE.CLOSED || peerConnection.connectionState === _constants.PEER_CONNECTION_STATE.FAILED) {
    return _promise.default.reject(new _reconnection.default('Reinitiate peerconnection'));
  }

  return _peerConnectionManager.default.createOffer(peerConnection, {
    meetingId: meetingId,
    remoteQualityLevel: remoteQualityLevel,
    enableRtx: enableRtx
  });
};
/**
 * format the media array for send
 * @param {String} mediaId
 * @param {Boolean} audioMuted
 * @param {Boolean} videoMuted
 * @returns {Array} medias
 */


Media.generateLocalMedias = function (mediaId, audioMuted, videoMuted) {
  if (mediaId) {
    return [{
      localSdp: (0, _stringify.default)({
        audioMuted: audioMuted,
        videoMuted: videoMuted
      }),
      mediaId: mediaId
    }];
  }

  return [];
};
/**
 * make a browser call to get the media
 * @param {SendOptions} options
 * @param {Object} config SDK Configuration for meetings plugin
 * @returns {Promise}
 */


Media.getLocalMedia = function (options, config) {
  var sendAudio = options.sendAudio,
      sendVideo = options.sendVideo,
      sendShare = options.sendShare,
      sharePreferences = options.sharePreferences,
      isSharing = options.isSharing;

  if (sendAudio || sendVideo) {
    return Media.getMedia(sendAudio, sendVideo, config);
  }

  if (sendShare && !isSharing) {
    return Media.getDisplayMedia({
      sendAudio: false,
      sendShare: true,
      sharePreferences: sharePreferences
    }, config);
  }

  return _promise.default.resolve(undefined);
};
/**
 * Returns the direction and tracks
 * @param {string} trackType type of track (audio/video)
 * @param {object}  track  tracks passed
 * @param {boolean} receiveTracks do you want to receive tracks from the remote side
 * @returns {Object} returns direction tracks to be added in transceiver
 */


Media.checkTracks = function (trackType, track, receiveTracks) {
  var getDirection = function getDirection(sendTracks, receiveTracks) {
    if (sendTracks && receiveTracks) {
      return 'sendrecv';
    }

    if (sendTracks && !receiveTracks) {
      return 'sendonly';
    }

    if (!sendTracks && receiveTracks) {
      return 'recvonly';
    }

    return 'inactive';
  };

  if (track) {
    return {
      track: track,
      direction: getDirection(!!track, receiveTracks)
    };
  }

  return {
    track: trackType,
    direction: getDirection(!!track, receiveTracks)
  };
};
/**
 * creates peerconnection and attaches streams
 * @param {MediaDirection} mediaProperties
 * @param {Object} meetingProperties
 * @param {string} meetingProperties.meetingId
 * @param {string} meetingProperties.remoteQualityLevel LOW|MEDIUM|HIGH
 * @returns {Array} [peerConnection, ]
 */


Media.attachMedia = function (mediaProperties, _ref2) {
  var meetingId = _ref2.meetingId,
      remoteQualityLevel = _ref2.remoteQualityLevel,
      enableRtx = _ref2.enableRtx;
  var mediaDirection = mediaProperties.mediaDirection,
      audioTrack = mediaProperties.audioTrack,
      videoTrack = mediaProperties.videoTrack,
      shareTrack = mediaProperties.shareTrack,
      peerConnection = mediaProperties.peerConnection;
  var result = null; // Add Transceiver for audio

  result = Media.checkTracks('audio', mediaDirection.sendAudio && audioTrack, mediaDirection.receiveAudio);
  peerConnection.audioTransceiver = peerConnection.addTransceiver(result.track, {
    direction: result.direction
  }); // Add Transceiver for video

  result = Media.checkTracks('video', mediaDirection.sendVideo && videoTrack, mediaDirection.receiveVideo);
  peerConnection.videoTransceiver = peerConnection.addTransceiver(result.track, {
    direction: result.direction
  }); // Add Transceiver for share

  result = Media.checkTracks('video', mediaDirection.sendShare && shareTrack, mediaDirection.receiveShare);
  peerConnection.shareTransceiver = peerConnection.addTransceiver(result.track, {
    direction: result.direction
  });

  peerConnection.onnegotiationneeded = function (event) {
    _loggerProxy.default.logger.info("Media:index#attachMedia --> onnegotiationneeded#PeerConnection: ".concat(event));
  };

  return _peerConnectionManager.default.createOffer(peerConnection, {
    meetingId: meetingId,
    remoteQualityLevel: remoteQualityLevel,
    enableRtx: enableRtx
  });
};
/**
 * updates all the media streams and creates a new media offer
 * @param {MediaDirection} mediaProperties
 * @param {Object} meetingProperties
 * @param {string} meetingProperties.meetingId
 * @param {string} meetingProperties.remoteQualityLevel LOW|MEDIUM|HIGH
 * @returns {Promise}
 */


Media.updateMedia = function (mediaProperties, _ref3) {
  var meetingId = _ref3.meetingId,
      remoteQualityLevel = _ref3.remoteQualityLevel,
      enableRtx = _ref3.enableRtx;
  var mediaDirection = mediaProperties.mediaDirection,
      audioTrack = mediaProperties.audioTrack,
      videoTrack = mediaProperties.videoTrack,
      shareTrack = mediaProperties.shareTrack,
      peerConnection = mediaProperties.peerConnection; // update audio transceiver

  Media.setTrackOnTransceiver(peerConnection.audioTransceiver, {
    type: 'audio',
    track: audioTrack,
    sendTrack: mediaDirection.sendAudio && audioTrack,
    receiveTrack: mediaDirection.receiveAudio
  }); // update video transceiver

  Media.setTrackOnTransceiver(peerConnection.videoTransceiver, {
    type: 'video',
    track: videoTrack,
    sendTrack: mediaDirection.sendVideo && videoTrack,
    receiveTrack: mediaDirection.receiveVideo
  }); // update content transceiver

  Media.setTrackOnTransceiver(peerConnection.shareTransceiver, {
    type: 'video',
    track: shareTrack,
    sendTrack: mediaDirection.sendShare && shareTrack,
    receiveTrack: mediaDirection.receiveShare
  });

  peerConnection.onnegotiationneeded = function (event) {
    _loggerProxy.default.logger.info("Media:index#updateMedia --> onnegotiationneeded#PeerConnection: ".concat(event));
  };

  return _peerConnectionManager.default.createOffer(peerConnection, {
    meetingId: meetingId,
    remoteQualityLevel: remoteQualityLevel,
    enableRtx: enableRtx
  });
};
/**
 * @param {RTCRtpTransceiver} transceiver
 * @param {Object} options
 * @param {MediaStreamTrack} options.track
 * @returns {undefined}
 */


Media.setTrackOnTransceiver = function (transceiver, options) {
  var type = options.type,
      track = options.track,
      sendTrack = options.sendTrack,
      receiveTrack = options.receiveTrack;

  try {
    var result = Media.checkTracks(type, sendTrack && track, receiveTrack);
    transceiver.direction = result.direction;

    if (options.track) {
      transceiver.sender.replaceTrack(track);
    }
  } catch (e) {
    _loggerProxy.default.logger.error("Media:index#setTrackOnTransceiver --> ".concat(e));

    throw e;
  }
};
/**
 * creates a new offer
 * @param {Object} meetingProperties
 * @param {string} meetingProperties.meetingId
 * @param {string} meetingProperties.remoteQualityLevel LOW|MEDIUM|HIGH
 * @param {RTCPeerConnection} peerConnection
 * @param {RTCRtpTransceiver} transceiver
 * @param {Object} options see #Media.setTrackOnTransceiver
 * @returns {Promise}
 */


Media.updateTransceiver = function (_ref4, peerConnection, transceiver, options) {
  var meetingId = _ref4.meetingId,
      remoteQualityLevel = _ref4.remoteQualityLevel,
      enableRtx = _ref4.enableRtx;
  Media.setTrackOnTransceiver(transceiver, options);
  return _peerConnectionManager.default.createOffer(peerConnection, {
    meetingId: meetingId,
    remoteQualityLevel: remoteQualityLevel,
    enableRtx: enableRtx
  });
};
/**
 * generates share streams
 * @param {Object} options parameter
 * @param {Boolean} options.sendAudio send audio from the display share
 * @param {Boolean} options.sendShare send video from the display share
 * @param {Object} options.sharePreferences
 * @param {MediaTrackConstraints} options.sharePreferences.shareConstraints constraints to apply to video
 *   @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints}
 * @param {Boolean} options.sharePreferences.highFrameRate if shareConstraints isn't provided, set default values based off of this boolean
 * @param {Object} config SDK Configuration for meetings plugin
 * @returns {Promise.<MediaStream>}
 */


Media.getDisplayMedia = function (options) {
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  // SDK screen share resolution settings from Webex.init
  var customResolution = config.screenResolution || {}; // user defined screen share frame rate

  var customShareFrameRate = config.screenFrameRate || null; // user defined share preferences

  var hasSharePreferences = options.sharePreferences;
  var hasCustomConstraints = hasSharePreferences && hasSharePreferences.shareConstraints;
  var hasHighFrameRate = hasSharePreferences && hasSharePreferences.highFrameRate;
  var _Config$meetings = _config.default.meetings,
      screenResolution = _Config$meetings.screenResolution,
      resolution = _Config$meetings.resolution,
      videoShareFrameRate = _Config$meetings.videoShareFrameRate,
      screenFrameRate = _Config$meetings.screenFrameRate,
      aspectRatio = _Config$meetings.aspectRatio;
  var shareConstraints = {
    cursor: _constants.MEDIA_TRACK_CONSTRAINT.CURSOR.AWLAYS,
    aspectRatio: aspectRatio
  };

  if (hasCustomConstraints) {
    shareConstraints = hasSharePreferences.shareConstraints;
  } else if (hasHighFrameRate) {
    shareConstraints = _objectSpread(_objectSpread({}, shareConstraints), {}, {
      frameRate: videoShareFrameRate,
      height: resolution.idealHeight,
      width: resolution.idealWidth
    }, config.resolution);
  } else {
    shareConstraints = _objectSpread(_objectSpread({}, shareConstraints), {}, {
      frameRate: customShareFrameRate || screenFrameRate,
      height: customResolution.idealHeight || screenResolution.idealHeight,
      width: customResolution.idealWidth || screenResolution.idealWidth
    }, config.screenResolution);
  } // chrome and webkit based browsers (edge, safari) automatically adjust everything
  // and we have noticed higher quality with those browser types
  // firefox specifically has some issues with resolution and frame rate decision making
  // so we are making it optional and configurable (with defaults) for firefox
  // to have higher quality, and for developers to control the values
  // eventually we may have to add the same functionality to chrome, OR conversely, get to with firefox


  if (isBrowser('firefox')) {
    var mediaConfig = {
      audio: options.sendAudio,
      video: options.sendShare
    };
    return navigator.mediaDevices.getDisplayMedia({
      audio: options.sendAudio,
      video: mediaConfig
    }).then(function (stream) {
      if (options.sendShare && stream.getVideoTracks().length > 0) {
        // Firefox has a bug with the spec where changing in the height and width only happens
        // after we get the inital tracks
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1321221
        stream.getVideoTracks()[0].applyConstraints(shareConstraints);
      }

      return stream;
    });
  }

  var getDisplayMediaParams = {
    video: options.sendShare ? shareConstraints : false
  }; // safari doesn't support sending screen share audio
  // https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia

  if (options.sendAudio && isBrowser('safari')) {
    getDisplayMediaParams.audio = options.sendAudio;
  }

  return navigator.mediaDevices.getDisplayMedia(getDisplayMediaParams);
};
/**
 * generates audio and video using constraints (often called after getSupportedDevices)
 * @param {Object|Boolean} audio gum constraints
 * @param {Object|Boolean} video gum constraints
 * @param {Object} config SDK Configuration for meetings plugin
 * @returns {Object} {streams}
 */


Media.getMedia = function (audio, video, config) {
  var defaultWidth = {
    ideal: config.resolution.idealWidth,
    max: config.resolution.maxWidth
  };
  var defaultHeight = {
    ideal: config.resolution.idealHeight,
    max: config.resolution.maxHeight
  };
  var mediaConfig = {
    audio: audio,
    // TODO: Remove temporary workaround once Firefox fixes low constraint issues
    // eslint-disable-next-line no-nested-ternary
    video: video ? isBrowser('firefox') && video.width && video.width.max === 320 ? {
      deviceId: video.deviceId ? video.deviceId : undefined,
      width: 320,
      height: 180
    } : {
      deviceId: video.deviceId ? video.deviceId : undefined,
      width: video.width ? video.width : defaultWidth,
      height: video.height ? video.height : defaultHeight
    } : false,
    fake: process.env.NODE_ENV === 'test' // Special case to get fake media for Firefox browser for testing

  };
  return navigator.mediaDevices.getUserMedia(mediaConfig).catch(function (err) {
    var logPath = 'Media:index#getMedia --> navigator.mediaDevices.getUserMedia';

    _loggerProxy.default.logger.error("".concat(logPath, " failed - ").concat(err, " (").concat(err.constraint, ")"));

    throw err;
  });
};
/**
 * Checks if the machine has at least one audio or video device (Dont use this for screen share)
 * @param {object} [options]
 * {
 *    sendAudio: true/false,
 *    sendVideo: true/false
 * }
 * @returns {Object} {
 *    sendAudio: true/false,
 *    sendVideo: true/false
 *}
 */


Media.getSupportedDevice = function (_ref5) {
  var sendAudio = _ref5.sendAudio,
      sendVideo = _ref5.sendVideo;
  return _promise.default.resolve().then(function () {
    if (!navigator.mediaDevices || navigator.mediaDevices.enumerateDevices === undefined) {
      return {
        sendAudio: false,
        sendVideo: false
      };
    }

    return navigator.mediaDevices.enumerateDevices().then(function (devices) {
      var supported = {
        audio: devices.filter(function (device) {
          return device.kind === _constants.AUDIO_INPUT;
        }).length > 0,
        video: devices.filter(function (device) {
          return device.kind === _constants.VIDEO_INPUT;
        }).length > 0
      };
      return {
        sendAudio: supported.audio && sendAudio,
        sendVideo: supported.video && sendVideo
      };
    });
  });
};
/**
 * proxy to browser navigator.mediaDevices.enumerateDevices()
 * @returns {Promise}
 */


Media.getDevices = function () {
  if (navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
    return navigator.mediaDevices.enumerateDevices();
  }

  return _promise.default.reject(new _media.default('enumerateDevices not supported.'));
};
/**
 *
 * Toggle a specific stream
 * noop as of now, does nothing
 * @returns {null}
 */


Media.toggleStream = function () {};
/**
 * Stop input stream
 * @param {MediaTrack} track A media stream
 * @returns {null}
 */


Media.stopTracks = function (track) {
  if (!track) {
    return _promise.default.resolve();
  }

  return _promise.default.resolve().then(function () {
    if (track && track.stop) {
      try {
        track.stop();
      } catch (e) {
        _loggerProxy.default.logger.error("Media:index#stopTracks --> Unable to stop the track with state ".concat(track.readyState, ", error: ").concat(e));
      }
    }
  });
};
/**
 *
 * Stop input stream
 * @param {Stream} stream A media stream
 * @returns {null}
 * @deprecated after v1.89.3
 */


Media.stopStream = function (stream) {
  _loggerProxy.default.logger.warn('Media:index#stopStream --> [DEPRECATION WARNING]: stopStream has been deprecated after v1.89.3');

  if (!stream) {
    return _promise.default.resolve();
  }
  /*
   * To release local media
   * 1) Chrome requires all tracks to be stopped (stream.stop got deprecated)
   * 2) Firefox requires the stream to be stopped
   */


  return _promise.default.resolve().then(function () {
    if (stream.getTracks) {
      stream.getTracks().forEach(function (track) {
        track.stop();
      });
    } else if (stream.stop) {
      stream.stop();
    }
  });
};
/**
 * generates streams for audio video and share
 * @param {object} mediaSetting parameter
 * @param {Object} mediaSetting.sendAudio sendAudio: {Boolean} sendAudio constraints
 * @param {Object} mediaSetting.sendVideo sendVideo: {Boolean} sendVideo constraints
 * @param {Object} mediaSetting.sendShare sendShare: {Boolean} sendShare constraints
 * @param {Object} mediaSetting.isSharing isSharing: {Boolean} isSharing constraints
 * @param {Object} audioVideo parameter
 * @param {Object} audioVideo.audio {deviceId: {String}}
 * @param {Object} audioVideo.video {deviceId: {String}}
 * @param {Object} sharePreferences parameter
 * @param {Object} sharePreferences.shareConstraints parameter
 * @param {Boolean} sharePreferences.highFrameRate parameter
 * @param {Object} config SDK Config
 * @returns {Array} [localStream, shareStream]
 */


Media.getUserMedia = function (mediaSetting, audioVideo, sharePreferences, config) {
  return Media.getLocalMedia({
    sendAudio: mediaSetting.sendAudio ? audioVideo.audio || mediaSetting.sendAudio : false,
    sendVideo: mediaSetting.sendVideo ? audioVideo.video || mediaSetting.sendVideo : false
  }, config).then(function (localStream) {
    return Media.getLocalMedia({
      sendShare: mediaSetting.sendShare,
      isSharing: mediaSetting.isSharing,
      sharePreferences: sharePreferences
    }, config).then(function (shareStream) {
      return [localStream, shareStream];
    });
  });
};

var _default = Media;
exports.default = _default;
//# sourceMappingURL=index.js.map
