"use strict";

var _Reflect$construct = require("@babel/runtime-corejs2/core-js/reflect/construct");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _cloneDeep2 = _interopRequireDefault(require("lodash/cloneDeep"));

var _eventsScope = _interopRequireDefault(require("../common/events/events-scope"));

var _constants = require("../constants");

var _config = _interopRequireDefault(require("../mediaQualityMetrics/config"));

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _global = _interopRequireDefault(require("./global"));

var _mqaUtil = require("./mqaUtil");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
  * Meeting High Packet Loss Event
  * Emitted when ever there is high packet loss detected
  * @event meeting:highPacketLoss
  * @type {Object}
  * @property {String} mediaType Type of media experiencing packet loss
  * @property {Number} packetLossRatio current packet loss ratio
  * @memberof StatsAnalyzer
  */

/**
 * Stats Analyzer class that will emit events based on detected quality
 *
 * @export
 * @class StatsAnalyzer
 * @extends {EventsScope}
 */
var StatsAnalyzer = /*#__PURE__*/function (_EventsScope) {
  (0, _inherits2.default)(StatsAnalyzer, _EventsScope);

  var _super = _createSuper(StatsAnalyzer);

  /**
   * Creates a new instance of StatsAnalyzer
   * @constructor
   * @public
   * @param {Object} config SDK Configuration Object
   * @param {Object} statsResults Default properties for stats
   */
  function StatsAnalyzer(config) {
    var _this;

    var statsResults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _global.default;
    (0, _classCallCheck2.default)(this, StatsAnalyzer);
    _this = _super.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "parseCandidate", function (result, type, isSender, isRemote) {
      if (!result || !result.id) {
        return;
      }

      var RemoteCandidateType = {};
      var RemoteTransport = {};
      var RemoteIpAddress = {};
      var RemoteNetworkType = {};
      if (!result.id) return;
      var sendRecvType = isSender ? _constants.STATS.SEND_DIRECTION : _constants.STATS.RECEIVE_DIRECTION;
      var ipType = isRemote ? _constants.STATS.REMOTE : _constants.STATS.LOCAL;

      if (!RemoteCandidateType[result.id]) {
        RemoteCandidateType[result.id] = [];
      }

      if (!RemoteTransport[result.id]) {
        RemoteTransport[result.id] = [];
      }

      if (!RemoteIpAddress[result.id]) {
        RemoteIpAddress[result.id] = [];
      }

      if (!RemoteNetworkType[result.id]) {
        RemoteNetworkType[result.id] = [];
      }

      if (result.candidateType && RemoteCandidateType[result.id].indexOf(result.candidateType) === -1) {
        RemoteCandidateType[result.id].push(result.candidateType);
      }

      if (result.protocol && RemoteTransport[result.id].indexOf(result.protocol) === -1) {
        RemoteTransport[result.id].push(result.protocol.toUpperCase());
      }

      if (result.ip && RemoteIpAddress[result.id].indexOf("".concat(result.ip, ":").concat(result.portNumber)) === -1) {
        RemoteIpAddress[result.id].push("".concat(result.ip)); // TODO: Add ports
      }

      if (result.networkType && RemoteNetworkType[result.id].indexOf(result.networkType) === -1) {
        RemoteNetworkType[result.id].push(result.networkType);
      }

      _this.statsResults.internal.candidates[result.id] = {
        candidateType: RemoteCandidateType[result.id],
        ipAddress: RemoteIpAddress[result.id],
        portNumber: result.port,
        networkType: RemoteNetworkType[result.id],
        priority: result.priority,
        transport: RemoteTransport[result.id],
        timestamp: result.time,
        id: result.id,
        type: result.type
      };
      _this.statsResults.connectionType[ipType].candidateType = RemoteCandidateType[result.id];
      _this.statsResults.connectionType[ipType].ipAddress = RemoteIpAddress[result.id];
      _this.statsResults.connectionType[ipType].networkType = RemoteNetworkType[result.id][0] === _constants.NETWORK_TYPE.VPN ? _constants.NETWORK_TYPE.UNKNOWN : RemoteNetworkType[result.id][0];
      _this.statsResults.connectionType[ipType].transport = RemoteTransport[result.id];
      _this.statsResults[type][sendRecvType].totalRoundTripTime = result.totalRoundTripTime;
    });
    _this.statsStarted = false;
    _this.statsResults = statsResults;
    _this.lastStatsResults = null;
    _this.config = config;
    _this.correlationId = config.correlationId;
    _this.mqaSentCount = -1;
    _this.lastMqaDataSent = {
      resolutions: {
        video: {
          send: {},
          recv: {}
        },
        audio: {
          send: {},
          recv: {}
        },
        share: {
          send: {},
          recv: {}
        }
      },
      video: {
        send: {},
        recv: {}
      },
      audio: {
        send: {},
        recv: {}
      },
      share: {
        send: {},
        recv: {}
      }
    };
    _this.localMQEStats = {
      audio: {
        RX: {
          packetsLost: [],
          jitter: [],
          latency: [],
          bitRate: []
        },
        TX: {
          packetsLost: [],
          jitter: [],
          latency: [],
          bitRate: []
        }
      },
      video: {
        RX: {
          packetsLost: [],
          jitter: [],
          latency: [],
          bitRate: [],
          frameRate: [],
          resolutionWidth: [],
          resolutionHeight: [],
          requestedKeyFrame: [],
          receivedKeyFrame: []
        },
        TX: {
          packetsLost: [],
          jitter: [],
          latency: [],
          bitRate: [],
          frameRate: [],
          resolutionWidth: [],
          resolutionHeight: [],
          requestedKeyFrame: [],
          receivedKeyFrame: []
        }
      }
    };
    return _this;
  }

  (0, _createClass2.default)(StatsAnalyzer, [{
    key: "populateResults",
    value: function populateResults(lastMqa) {
      // Audio
      this.localMQEStats.audio.RX.packetsLost.push(lastMqa.audioReceive[0].common.mediaHopByHopLost);
      this.localMQEStats.audio.RX.jitter.push(lastMqa.audioReceive[0].streams[0].common.rtpJitter);
      this.localMQEStats.audio.RX.latency.push(lastMqa.audioReceive[0].common.roundTripTime);
      this.localMQEStats.audio.RX.bitRate.push(lastMqa.audioReceive[0].streams[0].common.receivedBitrate);
      this.localMQEStats.audio.TX.packetsLost.push(lastMqa.audioTransmit[0].common.remoteLossRate);
      this.localMQEStats.audio.TX.jitter.push(lastMqa.audioTransmit[0].common.remoteJitter);
      this.localMQEStats.audio.TX.latency.push(lastMqa.audioTransmit[0].common.roundTripTime);
      this.localMQEStats.audio.TX.bitRate.push(lastMqa.audioTransmit[0].streams[0].common.transmittedBitrate); // Video

      this.localMQEStats.video.RX.packetsLost.push(lastMqa.videoReceive[0].common.mediaHopByHopLost);
      this.localMQEStats.video.RX.jitter.push(lastMqa.videoReceive[0].streams[0].common.rtpJitter);
      this.localMQEStats.video.RX.latency.push(lastMqa.videoReceive[0].streams[0].common.roundTripTime);
      this.localMQEStats.video.RX.bitRate.push(lastMqa.videoReceive[0].streams[0].common.receivedBitrate);
      this.localMQEStats.video.RX.frameRate.push(lastMqa.videoReceive[0].streams[0].common.receivedFrameRate);
      this.localMQEStats.video.RX.resolutionWidth.push(lastMqa.videoReceive[0].streams[0].receivedWidth);
      this.localMQEStats.video.RX.resolutionHeight.push(lastMqa.videoReceive[0].streams[0].receivedHeight);
      this.localMQEStats.video.RX.requestedKeyFrame.push();
      this.localMQEStats.video.RX.receivedKeyFrame.push();
      this.localMQEStats.video.TX.packetsLost.push(lastMqa.videoTransmit[0].common.remoteLossRate);
      this.localMQEStats.video.TX.jitter.push(lastMqa.videoTransmit[0].common.remoteJitter);
      this.localMQEStats.video.TX.latency.push(lastMqa.videoTransmit[0].common.roundTripTime);
      this.localMQEStats.video.TX.bitRate.push(lastMqa.videoTransmit[0].streams[0].common.transmittedBitrate);
      this.localMQEStats.video.TX.frameRate.push(lastMqa.videoTransmit[0].streams[0].common.transmittedFrameRate);
      this.localMQEStats.video.TX.resolutionWidth.push(lastMqa.videoTransmit[0].streams[0].transmittedWidth);
      this.localMQEStats.video.TX.resolutionHeight.push(lastMqa.videoTransmit[0].streams[0].transmittedHeight);
      this.localMQEStats.video.TX.requestedKeyFrame.push(lastMqa.videoTransmit[0].streams[0].requestedKeyFrames);
      this.localMQEStats.video.TX.receivedKeyFrame.push();
    }
  }, {
    key: "resetStatsResults",
    value: function resetStatsResults() {
      this.statsResults.audio.send.meanRemoteJitter = [];
      this.statsResults.video.send.meanRemoteJitter = [];
      this.statsResults.share.send.meanRemoteJitter = [];
      this.statsResults.audio.recv.meanRtpJitter = []; // TODO: currently no values are present

      this.statsResults.video.recv.meanRtpJitter = [];
      this.statsResults.share.recv.meanRtpJitter = []; // Reset the roundTripTime

      this.statsResults.audio.send.meanRoundTripTime = [];
      this.statsResults.video.send.meanRoundTripTime = [];
      this.statsResults.share.send.meanRoundTripTime = [];
    }
    /**
     * sets mediaStatus status for analyzing metrics
     *
     * @public
     * @param {Object} status for the audio and video
     * @memberof StatsAnalyzer
     * @returns {void}
     */

  }, {
    key: "updateMediaStatus",
    value: function updateMediaStatus(status) {
      this.meetingMediaStatus = status;
    }
    /**
     * captures MQA data from peerconnection
     *
     * @public
     * @memberof StatsAnalyzer
     * @returns {void}
     */

  }, {
    key: "sendMqaData",
    value: function sendMqaData() {
      var _this$peerConnection, _this$peerConnection$, _this$peerConnection$2, _this$peerConnection$3, _this$peerConnection2, _this$peerConnection3, _this$peerConnection4, _this$peerConnection5;

      var audioReceiver = _config.default.intervals[0].audioReceive[0];
      var audioSender = _config.default.intervals[0].audioTransmit[0];
      var videoReceiver = _config.default.intervals[0].videoReceive[0];
      var videoSender = _config.default.intervals[0].videoTransmit[0];
      var shareSender = _config.default.intervals[0].videoTransmit[1];
      var shareReceiver = _config.default.intervals[0].videoReceive[1];
      (0, _mqaUtil.getAudioSenderMqa)({
        audioSender: audioSender,
        statsResults: this.statsResults,
        lastMqaDataSent: this.lastMqaDataSent
      });
      (0, _mqaUtil.getAudioReceiverMqa)({
        audioReceiver: audioReceiver,
        statsResults: this.statsResults,
        lastMqaDataSent: this.lastMqaDataSent
      });
      (0, _mqaUtil.getVideoReceiverMqa)({
        videoReceiver: videoReceiver,
        statsResults: this.statsResults,
        lastMqaDataSent: this.lastMqaDataSent
      });
      (0, _mqaUtil.getVideoSenderMqa)({
        videoSender: videoSender,
        statsResults: this.statsResults,
        lastMqaDataSent: this.lastMqaDataSent
      }); // Capture mqa for share scenario

      (0, _mqaUtil.getVideoSenderMqa)({
        videoSender: shareSender,
        statsResults: this.statsResults,
        lastMqaDataSent: this.lastMqaDataSent,
        isShareStream: true
      });
      (0, _mqaUtil.getVideoReceiverMqa)({
        videoReceiver: shareReceiver,
        statsResults: this.statsResults,
        lastMqaDataSent: this.lastMqaDataSent,
        isShareStream: true
      });
      _config.default.intervals[0].intervalMetadata.peerReflexiveIP = this.statsResults.connectionType.local.ipAddress[0]; // Adding peripheral information

      _config.default.intervals[0].intervalMetadata.peripherals = [];

      _config.default.intervals[0].intervalMetadata.peripherals.push({
        information: _constants._UNKNOWN_,
        name: _constants.MEDIA_DEVICES.SPEAKER
      });

      _config.default.intervals[0].intervalMetadata.peripherals.push({
        information: ((_this$peerConnection = this.peerConnection) === null || _this$peerConnection === void 0 ? void 0 : (_this$peerConnection$ = _this$peerConnection.audioTransceiver) === null || _this$peerConnection$ === void 0 ? void 0 : (_this$peerConnection$2 = _this$peerConnection$.sender) === null || _this$peerConnection$2 === void 0 ? void 0 : (_this$peerConnection$3 = _this$peerConnection$2.track) === null || _this$peerConnection$3 === void 0 ? void 0 : _this$peerConnection$3.label) || _constants._UNKNOWN_,
        name: _constants.MEDIA_DEVICES.MICROPHONE
      });

      _config.default.intervals[0].intervalMetadata.peripherals.push({
        information: ((_this$peerConnection2 = this.peerConnection) === null || _this$peerConnection2 === void 0 ? void 0 : (_this$peerConnection3 = _this$peerConnection2.videoTransceiver) === null || _this$peerConnection3 === void 0 ? void 0 : (_this$peerConnection4 = _this$peerConnection3.sender) === null || _this$peerConnection4 === void 0 ? void 0 : (_this$peerConnection5 = _this$peerConnection4.track) === null || _this$peerConnection5 === void 0 ? void 0 : _this$peerConnection5.label) || _constants._UNKNOWN_,
        name: _constants.MEDIA_DEVICES.CAMERA
      });

      _config.default.networkType = this.statsResults.connectionType.local.networkType;
      this.mqaSentCount = this.mqaSentCount + 1;
      _config.default.intervals[0].intervalNumber = this.mqaSentCount; // DO Deep copy, for some reason it takes the reference all the time rather then old value set

      this.lastMqaDataSent = (0, _cloneDeep2.default)(this.statsResults);
      this.populateResults(_config.default.intervals[0]);
      this.resetStatsResults();
      this.emit({
        file: 'statsAnalyzer',
        function: 'sendMqaData'
      }, _constants.EVENT_TRIGGERS.MEDIA_QUALITY, {
        data: _config.default.intervals[0],
        networkType: _config.default.networkType
      });
    }
    /**
     * updated the peerconnection when changed
     *
     * @private
     * @memberof updatePeerconnection
     * @param {PeerConnection} peerConnection
     * @returns {void}
     */

  }, {
    key: "updatePeerconnection",
    value: function updatePeerconnection(peerConnection) {
      this.peerConnection = peerConnection;
    }
    /**
     * Starts the stats analyzer on interval
     *
     * @public
     * @memberof StatsAnalyzer
     * @param {PeerConnection} peerConnection
     * @returns {void}
     */

  }, {
    key: "startAnalyzer",
    value: function startAnalyzer(peerConnection) {
      var _this2 = this;

      if (!this.statsStarted) {
        this.statsStarted = true;
        this.peerConnection = peerConnection;
        this.getStatsAndParse();
        this.statsInterval = setInterval(function () {
          _this2.getStatsAndParse();
        }, this.config.analyzerInterval); // Trigger initial fetch

        this.sendMqaData();
        this.mqaInterval = setInterval(function () {
          _this2.sendMqaData();
        }, _constants.MQA_INTEVAL);
      }
    }
    /**
     * Cleans up the analyzer when done
     *
     * @public
     * @memberof StatsAnalyzer
     * @returns {void}
     */

  }, {
    key: "stopAnalyzer",
    value: function stopAnalyzer() {
      if (this.statsInterval) {
        this.getStatsAndParse();
        clearInterval(this.statsInterval);
        this.statsInterva = undefined;
      }

      if (this.mqaInterval) {
        this.sendMqaData();
        clearInterval(this.mqaInterval);
        this.statsInterva = undefined;
      }

      this.peerConnection = null;
    }
    /**
     * Parse a single result of get stats
     *
     * @private
     * @param {*} getStatsResult
     * @param {String} type
     * @param {boolean} isSender
     * @returns {void}
     * @memberof StatsAnalyzer
     */

  }, {
    key: "parseGetStatsResult",
    value: function parseGetStatsResult(getStatsResult, type, isSender) {
      if (!getStatsResult) {
        return;
      }

      switch (getStatsResult.type) {
        case 'outbound-rtp':
          this.processOutboundRTPResult(getStatsResult, type);
          break;

        case 'inbound-rtp':
          this.processInboundRTPResult(getStatsResult, type);
          break;

        case 'track':
          this.processTrackResult(getStatsResult, type);
          break;

        case 'remote-inbound-rtp':
        case 'remote-outbound-rtp':
          this.compareSentAndReceived(getStatsResult, type, isSender);
          break;

        case 'remotecandidate':
        case 'remote-candidate':
          this.parseCandidate(getStatsResult, type, isSender, true);
          break;

        case 'local-candidate':
          this.parseCandidate(getStatsResult, type, isSender, false);
          break;

        case 'media-source':
          this.parseAudioSource(getStatsResult, type);
          break;

        default:
          break;
      }
    }
    /**
     * Filters the get stats results for types
     * @private
     * @param {Array} getStatsResults
     * @param {String} type
     * @param {boolean} isSender
     * @returns {void}
     */

  }, {
    key: "filterAndParseGetStatsResults",
    value: function filterAndParseGetStatsResults(getStatsResults, type, isSender) {
      var _this3 = this;

      var types = _constants.DEFAULT_GET_STATS_FILTER.types;
      getStatsResults.forEach(function (result) {
        if (types.includes(result.type)) {
          _this3.parseGetStatsResult(result, type, isSender);
        }
      });
    }
    /**
     * parse the audio
     * @param {String} result
     * @param {boolean} type
     * @returns {void}
     */

  }, {
    key: "parseAudioSource",
    value: function parseAudioSource(result, type) {
      if (!result) {
        return;
      }

      if (type === _constants.STATS.AUDIO_CORRELATE) {
        this.statsResults[type].send.audioLevel = result.audioLevel;
        this.statsResults[type].send.totalAudioEnergy = result.totalAudioEnergy;
      }
    }
    /**
     * compares current and previous stats to check if packets are not sent
     *
     * @private
     * @memberof StatsAnalyzer
     * @returns {void}
     */

  }, {
    key: "compareLastStatsResult",
    value: function compareLastStatsResult() {
      if (this.lastStatsResults !== null && this.meetingMediaStatus) {
        // compare audio stats sent
        var mediaType = _constants.STATS.AUDIO_CORRELATE;
        var currentStats = null;
        var previousStats = null;

        if (this.meetingMediaStatus.expected.sendAudio) {
          currentStats = this.statsResults[mediaType].send;
          previousStats = this.lastStatsResults[mediaType].send;

          if (currentStats.totalPacketsSent === previousStats.totalPacketsSent || currentStats.totalPacketsSent === 0) {
            _loggerProxy.default.logger.info("StatsAnalyzer:index#compareLastStatsResult --> No ".concat(mediaType, " RTP packets sent"));
          } else {
            if (currentStats.totalAudioEnergy === previousStats.totalAudioEnergy || currentStats.totalAudioEnergy === 0) {
              _loggerProxy.default.logger.info("StatsAnalyzer:index#compareLastStatsResult --> No ".concat(mediaType, " Energy present"));
            }

            if (currentStats.audioLevel === 0) {
              _loggerProxy.default.logger.info("StatsAnalyzer:index#compareLastStatsResult --> ".concat(mediaType, " level is 0 for the user"));
            }
          }

          if (previousStats.totalPacketsSent === 0 && currentStats.totalPacketsSent > 0) {
            this.emit({
              file: 'statsAnalyzer/index',
              function: 'compareLastStatsResult'
            }, _constants.EVENT_TRIGGERS.MEETING_MEDIA_LOCAL_STARTED, {
              type: mediaType.AUDIO
            });
          }
        }

        if (this.meetingMediaStatus.expected.receiveAudio) {
          // compare audio stats received
          currentStats = this.statsResults[mediaType].recv;
          previousStats = this.lastStatsResults[mediaType].recv;

          if (currentStats.totalPacketsReceived === previousStats.totalPacketsReceived || currentStats.totalPacketsReceived === 0) {
            _loggerProxy.default.logger.info("StatsAnalyzer:index#compareLastStatsResult --> No ".concat(mediaType, " RTP packets received"));
          } else if (currentStats.totalSamplesReceived === previousStats.totalSamplesReceived || currentStats.totalSamplesReceived === 0) {
            _loggerProxy.default.logger.info("StatsAnalyzer:index#compareLastStatsResult --> No ".concat(mediaType, " samples received"));
          }
        }

        mediaType = _constants.STATS.VIDEO_CORRELATE;

        if (this.meetingMediaStatus.expected.sendVideo) {
          // compare video stats sent
          currentStats = this.statsResults[mediaType].send;
          previousStats = this.lastStatsResults[mediaType].send;

          if (currentStats.totalPacketsSent === previousStats.totalPacketsSent || currentStats.totalPacketsSent === 0) {
            _loggerProxy.default.logger.info("StatsAnalyzer:index#compareLastStatsResult --> No ".concat(mediaType, " RTP packets sent"));
          } else {
            if (currentStats.framesEncoded === previousStats.framesEncoded || currentStats.framesEncoded === 0) {
              _loggerProxy.default.logger.info("StatsAnalyzer:index#compareLastStatsResult --> No ".concat(mediaType, " Frames Encoded"));
            }

            if (this.statsResults.resolutions[mediaType].send.framesSent === this.lastStatsResults.resolutions[mediaType].send.framesSent || this.statsResults.resolutions[mediaType].send.framesSent === 0) {
              _loggerProxy.default.logger.info("StatsAnalyzer:index#compareLastStatsResult --> No ".concat(mediaType, " Frames sent"));
            }
          }

          if (previousStats.framesSent === 0 && currentStats.framesSent > 0) {
            this.emit({
              file: 'statsAnalyzer/index',
              function: 'compareLastStatsResult'
            }, _constants.EVENT_TRIGGERS.MEETING_MEDIA_LOCAL_STARTED, {
              type: mediaType.VIDEO
            });
          }
        }

        if (this.meetingMediaStatus.expected.receiveVideo) {
          // compare video stats reveived
          currentStats = this.statsResults[mediaType].recv;
          previousStats = this.lastStatsResults[mediaType].recv;

          if (currentStats.totalPacketsReceived === previousStats.totalPacketsReceived || currentStats.totalPacketsReceived === 0) {
            _loggerProxy.default.logger.info("StatsAnalyzer:index#compareLastStatsResult --> No ".concat(mediaType, " RTP packets received"));
          } else {
            if (this.statsResults.resolutions[mediaType].recv.framesReceived === this.lastStatsResults.resolutions[mediaType].recv.framesReceived || this.statsResults.resolutions[mediaType].recv.framesReceived === 0) {
              _loggerProxy.default.logger.info("StatsAnalyzer:index#compareLastStatsResult --> No ".concat(mediaType, " frames received"));
            }

            if (this.statsResults.resolutions[mediaType].recv.framesDecoded === this.lastStatsResults.resolutions[mediaType].recv.framesDecoded || this.statsResults.resolutions[mediaType].send.framesDecoded === 0) {
              _loggerProxy.default.logger.info("StatsAnalyzer:index#compareLastStatsResult --> No ".concat(mediaType, " frames decoded"));
            }

            if (this.statsResults.resolutions[mediaType].recv.framesDropped - this.lastStatsResults.resolutions[mediaType].recv.framesDropped > 10) {
              _loggerProxy.default.logger.info("StatsAnalyzer:index#compareLastStatsResult --> ".concat(mediaType, " frames are getting dropped"));
            }
          }
        }

        mediaType = _constants.STATS.SHARE_CORRELATE;

        if (this.meetingMediaStatus.expected.sendShare) {
          // compare share stats sent
          currentStats = this.statsResults[mediaType].send;
          previousStats = this.lastStatsResults[mediaType].send;

          if (currentStats.totalPacketsSent === previousStats.totalPacketsSent || currentStats.totalPacketsSent === 0) {
            _loggerProxy.default.logger.info("StatsAnalyzer:index#compareLastStatsResult --> No ".concat(mediaType, " RTP packets sent"));
          } else {
            if (currentStats.framesEncoded === previousStats.framesEncoded || currentStats.framesEncoded === 0) {
              _loggerProxy.default.logger.info("StatsAnalyzer:index#compareLastStatsResult --> No ".concat(mediaType, " frames getting encoded"));
            }

            if (this.statsResults.resolutions[mediaType].send.framesSent === this.lastStatsResults.resolutions[mediaType].send.framesSent || this.statsResults.resolutions[mediaType].send.framesSent === 0) {
              _loggerProxy.default.logger.info("StatsAnalyzer:index#compareLastStatsResult --> No ".concat(mediaType, " frames sent"));
            }
          }

          if (previousStats.framesSent === 0 && currentStats.framesSent > 0) {
            this.emit({
              file: 'statsAnalyzer/index',
              function: 'compareLastStatsResult'
            }, _constants.EVENT_TRIGGERS.MEETING_MEDIA_LOCAL_STARTED, {
              type: mediaType.VIDEO
            });
          } // TODO:need to check receive share value
          // compare share stats reveived


          currentStats = this.statsResults[mediaType].recv;
          previousStats = this.lastStatsResults[mediaType].recv;

          if (currentStats.totalPacketsReceived === previousStats.totalPacketsReceived || currentStats.totalPacketsSent === 0) {
            _loggerProxy.default.logger.info("StatsAnalyzer:index#compareLastStatsResult --> No ".concat(mediaType, " RTP packets received"));
          } else {
            if (this.statsResults.resolutions[mediaType].recv.framesReceived === this.lastStatsResults.resolutions[mediaType].recv.framesReceived || this.statsResults.resolutions[mediaType].recv.framesReceived === 0) {
              _loggerProxy.default.logger.info("StatsAnalyzer:index#compareLastStatsResult --> No ".concat(mediaType, " frames received"));
            }

            if (this.statsResults.resolutions[mediaType].recv.framesDecoded === this.lastStatsResults.resolutions[mediaType].recv.framesDecoded || this.statsResults.resolutions[mediaType].send.framesDecoded === 0) {
              _loggerProxy.default.logger.info("StatsAnalyzer:index#compareLastStatsResult --> No ".concat(mediaType, " frames decoded"));
            }

            if (this.statsResults.resolutions[mediaType].recv.framesDropped - this.lastStatsResults.resolutions[mediaType].recv.framesDropped > 10) {
              _loggerProxy.default.logger.info("StatsAnalyzer:index#compareLastStatsResult --> ".concat(mediaType, " frames are getting dropped"));
            }
          }
        }
      }
    }
    /**
     * Does a `getStats` on all the transceivers and parses the results
     *
     * @private
     * @memberof StatsAnalyzer
     * @returns {void}
     */

  }, {
    key: "getStatsAndParse",
    value: function getStatsAndParse() {
      var _this4 = this;

      if (!this.peerConnection) {
        return;
      }

      if (this.peerConnection && this.peerConnection.connectionState === _constants.CONNECTION_STATE.FAILED) {
        _loggerProxy.default.logger.trace('StatsAnalyzer:index#getStatsAndParse --> PeerConnection is in failed state');

        return;
      }

      _loggerProxy.default.logger.trace('StatsAnalyzer:index#getStatsAndParse --> Collecting Stats');

      this.peerConnection.videoTransceiver.sender.getStats().then(function (res) {
        _this4.filterAndParseGetStatsResults(res, _constants.STATS.VIDEO_CORRELATE, true);
      });
      this.peerConnection.videoTransceiver.receiver.getStats().then(function (res) {
        _this4.filterAndParseGetStatsResults(res, _constants.STATS.VIDEO_CORRELATE, false);
      });
      this.peerConnection.audioTransceiver.sender.getStats().then(function (res) {
        _this4.filterAndParseGetStatsResults(res, _constants.STATS.AUDIO_CORRELATE, true);
      });
      this.peerConnection.audioTransceiver.receiver.getStats().then(function (res) {
        _this4.filterAndParseGetStatsResults(res, _constants.STATS.AUDIO_CORRELATE, false);
      }); // TODO: add checks for screen share

      this.peerConnection.shareTransceiver.sender.getStats().then(function (res) {
        _this4.filterAndParseGetStatsResults(res, _constants.STATS.SHARE_CORRELATE, true);
      });
      this.peerConnection.shareTransceiver.receiver.getStats().then(function (res) {
        _this4.filterAndParseGetStatsResults(res, _constants.STATS.SHARE_CORRELATE, false);
      }); // updates the current direction of media

      this.statsResults[_constants.STATS.AUDIO_CORRELATE].direction = this.peerConnection.audioTransceiver.currentDirection;
      this.statsResults[_constants.STATS.VIDEO_CORRELATE].direction = this.peerConnection.videoTransceiver.currentDirection;
      this.statsResults[_constants.STATS.SHARE_CORRELATE].direction = this.peerConnection.shareTransceiver.currentDirection; // Process Stats results every 5 seconds

      this.compareLastStatsResult(); // Save the last results to compare with the current
      // DO Deep copy, for some reason it takes the reference all the time rather then old value set

      this.lastStatsResults = JSON.parse((0, _stringify.default)(this.statsResults));

      _loggerProxy.default.logger.trace('StatsAnalyzer:index#getStatsAndParse --> Finished Collecting Stats');
    }
    /**
     * Processes OutboundRTP stats result and stores
     * @private
     * @param {*} result
     * @param {*} type
     * @returns {void}
     */

  }, {
    key: "processOutboundRTPResult",
    value: function processOutboundRTPResult(result, type) {
      var mediaType = type || _constants.STATS.AUDIO_CORRELATE;
      var sendrecvType = _constants.STATS.SEND_DIRECTION;

      if (result.bytesSent) {
        var kilobytes = 0;

        if (!this.statsResults.internal[mediaType][sendrecvType].prevBytesSent) {
          this.statsResults.internal[mediaType][sendrecvType].prevBytesSent = result.bytesSent;
        }

        if (!this.statsResults.internal[mediaType][sendrecvType].framesEncoded) {
          this.statsResults.internal[mediaType][sendrecvType].framesEncoded = result.framesEncoded;
        }

        if (!this.statsResults.internal[mediaType][sendrecvType].keyFramesEncoded) {
          this.statsResults.internal[mediaType][sendrecvType].keyFramesEncoded = result.keyFramesEncoded;
        }

        var bytes = result.bytesSent - this.statsResults.internal[mediaType][sendrecvType].prevBytesSent;
        this.statsResults.internal[mediaType][sendrecvType].prevBytesSent = result.bytesSent;
        kilobytes = bytes / 1024;
        this.statsResults[mediaType][sendrecvType].availableBandwidth = kilobytes.toFixed(1);
        this.statsResults[mediaType].bytesSent = kilobytes;
        this.statsResults[mediaType][sendrecvType].framesEncoded = result.framesEncoded - this.statsResults.internal[mediaType][sendrecvType].framesEncoded;
        this.statsResults[mediaType][sendrecvType].keyFramesEncoded = result.keyFramesEncoded - this.statsResults.internal[mediaType][sendrecvType].keyFramesEncoded;
        this.statsResults.internal[mediaType].outboundRtpId = result.id;

        if (!this.statsResults.internal[mediaType][sendrecvType].packetsSent) {
          this.statsResults.internal[mediaType][sendrecvType].packetsSent = result.packetsSent;
        }

        this.statsResults[mediaType][sendrecvType].packetsSent = result.packetsSent - this.statsResults.internal[mediaType][sendrecvType].packetsSent;
        this.statsResults.internal[mediaType][sendrecvType].packetsSent = result.packetsSent; // Data saved to send MQA metrics

        this.statsResults[mediaType][sendrecvType].totalKeyFramesEncoded = result.keyFramesEncoded;
        this.statsResults[mediaType][sendrecvType].totalNackCount = result.nackCount;
        this.statsResults[mediaType][sendrecvType].totalPliCount = result.pliCount;
        this.statsResults[mediaType][sendrecvType].totalPacketsSent = result.packetsSent;
        this.statsResults[mediaType][sendrecvType].totalFirCount = result.firCount;
        this.statsResults[mediaType][sendrecvType].framesEncoded = result.framesEncoded;
        this.statsResults[mediaType][sendrecvType].encoderImplementation = result.encoderImplementation;
        this.statsResults[mediaType][sendrecvType].qualityLimitationReason = result.qualityLimitationReason;
        this.statsResults[mediaType][sendrecvType].qualityLimitationResolutionChanges = result.qualityLimitationResolutionChanges;
        this.statsResults[mediaType][sendrecvType].retransmittedPacketsSent = result.retransmittedPacketsSent;
        this.statsResults[mediaType][sendrecvType].totalBytesSent = result.bytesSent;
        this.statsResults[mediaType][sendrecvType].headerBytesSent = result.headerBytesSent;
        this.statsResults[mediaType][sendrecvType].retransmittedBytesSent = result.retransmittedBytesSent;
      }
    }
    /**
     * Processes InboundRTP stats result and stores
     * @private
     * @param {*} result
     * @param {*} type
     * @returns {void}
     */

  }, {
    key: "processInboundRTPResult",
    value: function processInboundRTPResult(result, type) {
      var mediaType = type || _constants.STATS.AUDIO_CORRELATE;
      var sendrecvType = _constants.STATS.RECEIVE_DIRECTION;

      if (result.bytesReceived) {
        var kilobytes = 0;

        if (!this.statsResults.internal[mediaType][sendrecvType].prevBytesReceived) {
          this.statsResults.internal[mediaType][sendrecvType].prevBytesReceived = result.bytesReceived;
        }

        if (!this.statsResults.internal[mediaType][sendrecvType].pliCount) {
          this.statsResults.internal[mediaType][sendrecvType].pliCount = result.pliCount;
        }

        if (!this.statsResults.internal[mediaType][sendrecvType].packetsLost) {
          this.statsResults.internal[mediaType][sendrecvType].packetsLost = result.packetsLost;
        }

        if (!this.statsResults.internal[mediaType][sendrecvType].totalPacketsReceived) {
          this.statsResults.internal[mediaType][sendrecvType].totalPacketsReceived = result.packetsReceived;
        }

        if (!this.statsResults.internal[mediaType][sendrecvType].lastPacketReceivedTimestamp) {
          this.statsResults.internal[mediaType][sendrecvType].lastPacketReceivedTimestamp = result.lastPacketReceivedTimestamp;
        }

        var bytes = result.bytesReceived - this.statsResults.internal[mediaType][sendrecvType].prevBytesReceived;
        this.statsResults.internal[mediaType][sendrecvType].prevBytesReceived = result.bytesReceived;
        kilobytes = bytes / 1024;
        this.statsResults[mediaType][sendrecvType].availableBandwidth = kilobytes.toFixed(1);
        this.statsResults[mediaType].bytesReceived = kilobytes.toFixed(1);
        this.statsResults[mediaType][sendrecvType].pliCount = result.pliCount - this.statsResults.internal[mediaType][sendrecvType].pliCount;
        this.statsResults[mediaType][sendrecvType].currentPacketsLost = result.packetsLost - this.statsResults.internal[mediaType][sendrecvType].packetsLost;

        if (this.statsResults[mediaType][sendrecvType].currentPacketsLost < 0) {
          this.statsResults[mediaType][sendrecvType].currentPacketsLost = 0;
        }

        this.statsResults[mediaType][sendrecvType].packetsReceived = result.packetsReceived - this.statsResults.internal[mediaType][sendrecvType].totalPacketsReceived;
        this.statsResults.internal[mediaType][sendrecvType].totalPacketsReceived = result.packetsReceived;

        if (this.statsResults[mediaType][sendrecvType].packetsReceived === 0) {
          _loggerProxy.default.logger.info("StatsAnalyzer:index#processInboundRTPResult --> No packets received for ".concat(mediaType, " "), this.statsResults[mediaType][sendrecvType].packetsReceived);
        } //  Check the over all packet Lost ratio


        this.statsResults[mediaType][sendrecvType].currentPacketLossRatio = this.statsResults[mediaType][sendrecvType].currentPacketsLost > 0 ? this.statsResults[mediaType][sendrecvType].currentPacketsLost / (this.statsResults[mediaType][sendrecvType].packetsReceived + this.statsResults[mediaType][sendrecvType].currentPacketsLost) : 0;

        if (this.statsResults[mediaType][sendrecvType].currentPacketLossRatio > 3) {
          _loggerProxy.default.logger.info('StatsAnalyzer:index#processInboundRTPResult --> Packets getting lost from the receiver ', this.statsResults[mediaType][sendrecvType].currentPacketLossRatio);
        } // TODO: check the packet loss value is negative values here


        if (result.packetsLost) {
          this.statsResults[mediaType][sendrecvType].totalPacketsLost = result.packetsLost > 0 ? result.packetsLost : -result.packetsLost;
        } else {
          this.statsResults[mediaType][sendrecvType].totalPacketsLost = 0;
        }

        this.statsResults[mediaType][sendrecvType].lastPacketReceivedTimestamp = result.lastPacketReceivedTimestamp; // From Thin

        this.statsResults[mediaType][sendrecvType].totalNackCount = result.nackCount;
        this.statsResults[mediaType][sendrecvType].totalPliCount = result.pliCount;
        this.statsResults[mediaType][sendrecvType].framesDecoded = result.framesDecoded;
        this.statsResults[mediaType][sendrecvType].keyFramesDecoded = result.keyFramesDecoded;
        this.statsResults[mediaType][sendrecvType].decoderImplementation = result.decoderImplementation;
        this.statsResults[mediaType][sendrecvType].totalPacketsReceived = result.packetsReceived;
        this.statsResults[mediaType][sendrecvType].fecPacketsDiscarded = result.fecPacketsDiscarded;
        this.statsResults[mediaType][sendrecvType].fecPacketsReceived = result.fecPacketsReceived;
        this.statsResults[mediaType][sendrecvType].totalBytesReceived = result.bytesReceived;
        this.statsResults[mediaType][sendrecvType].headerBytesReceived = result.headerBytesReceived;
        this.statsResults[mediaType][sendrecvType].meanRtpJitter.push(result.jitter); // Audio stats

        this.statsResults[mediaType][sendrecvType].audioLevel = result.audioLevel;
        this.statsResults[mediaType][sendrecvType].totalAudioEnergy = result.totalAudioEnergy;
        this.statsResults[mediaType][sendrecvType].totalSamplesReceived = result.totalSamplesReceived || 0;
        this.statsResults[mediaType][sendrecvType].totalSamplesDecoded = result.totalSamplesDecoded || 0;
        this.statsResults[mediaType][sendrecvType].concealedSamples = result.concealedSamples || 0;
      }
    }
    /**
     * Processes remote and local candidate result and stores
     * @private
     * @param {*} result
     * @param {*} type
     * @param {boolean} isSender
     * @param {boolean} isRemote
     *
     * @returns {void}
     */

  }, {
    key: "processTrackResult",
    value:
    /**
     * Process Track results
     *
     * @private
     * @param {*} result
     * @param {*} mediaType
     * @returns {void}
     * @memberof StatsAnalyzer
     */
    function processTrackResult(result, mediaType) {
      if (!result || result.type !== 'track') {
        return;
      }

      if (result.type !== 'track') return;
      var sendrecvType = result.remoteSource === true ? _constants.STATS.RECEIVE_DIRECTION : _constants.STATS.SEND_DIRECTION;

      if (result.frameWidth && result.frameHeight) {
        this.statsResults.resolutions[mediaType][sendrecvType].width = result.frameWidth;
        this.statsResults.resolutions[mediaType][sendrecvType].height = result.frameHeight;
        this.statsResults.resolutions[mediaType][sendrecvType].framesSent = result.framesSent;
        this.statsResults.resolutions[mediaType][sendrecvType].hugeFramesSent = result.hugeFramesSent;
      }

      if (sendrecvType === _constants.STATS.RECEIVE_DIRECTION) {
        this.statsResults.resolutions[mediaType][sendrecvType].framesReceived = result.framesReceived;
        this.statsResults.resolutions[mediaType][sendrecvType].framesDecoded = result.framesDecoded;
        this.statsResults.resolutions[mediaType][sendrecvType].framesDropped = result.framesDropped;
      }

      if (result.trackIdentifier && mediaType !== _constants.STATS.AUDIO_CORRELATE) {
        this.statsResults.resolutions[mediaType][sendrecvType].trackIdentifier = result.trackIdentifier;
        var jitterBufferDelay = result && result.jitterBufferDelay;
        var jitterBufferEmittedCount = result && result.jitterBufferEmittedCount;
        this.statsResults.resolutions[mediaType][sendrecvType].avgJitterDelay = jitterBufferEmittedCount && +jitterBufferDelay / +jitterBufferEmittedCount; // Used to calculate the jitter

        this.statsResults.resolutions[mediaType][sendrecvType].jitterBufferDelay = result.jitterBufferDelay;
        this.statsResults.resolutions[mediaType][sendrecvType].jitterBufferEmittedCount = result.jitterBufferEmittedCount;
      }
    }
    /**
     *
     * @private
     * @param {*} result
     * @param {*} type
     * @returns {void}
     * @memberof StatsAnalyzer
     */

  }, {
    key: "compareSentAndReceived",
    value: function compareSentAndReceived(result, type) {
      if (!type) {
        return;
      }

      var mediaType = type;

      if (!this.statsResults.internal[mediaType].send.totalPacketsLostOnReceiver) {
        this.statsResults.internal[mediaType].send.totalPacketsLostOnReceiver = result.packetsLost;
      }

      var currentPacketLoss = result.packetsLost - this.statsResults.internal[mediaType].send.totalPacketsLostOnReceiver;
      this.statsResults.internal[mediaType].send.totalPacketsLostOnReceiver = result.packetsLost;
      this.statsResults[mediaType].send.packetsLostOnReceiver = currentPacketLoss;
      this.statsResults[mediaType].send.totalPacketsLostOnReceiver = result.packetsLost;
      this.statsResults[mediaType].send.meanRemoteJitter.push(result.jitter);
      this.statsResults[mediaType].send.meanRoundTripTime.push(result.roundTripTime);
      this.statsResults[mediaType].send.timestamp = result.timestamp;
      this.statsResults[mediaType].send.ssrc = result.ssrc;
      this.statsResults[mediaType].send.reportsReceived = result.reportsReceived; // Total packloss ratio on this video section of the call

      this.statsResults[mediaType].send.overAllPacketLossRatio = this.statsResults[mediaType].send.totalPacketsLostOnReceiver > 0 ? this.statsResults[mediaType].send.totalPacketsLostOnReceiver / this.statsResults[mediaType].send.totalPacketsSent : 0;
      this.statsResults[mediaType].send.currentPacketLossRatio = this.statsResults[mediaType].send.packetsLostOnReceiver > 0 ? this.statsResults[mediaType].send.packetsLostOnReceiver * 100 / (this.statsResults[mediaType].send.packetsSent + this.statsResults[mediaType].send.packetsLostOnReceiver) : 0;

      if (this.statsResults[mediaType].send.maxPacketLossRatio < this.statsResults[mediaType].send.currentPacketLossRatio) {
        this.statsResults[mediaType].send.maxPacketLossRatio = this.statsResults[mediaType].send.currentPacketLossRatio;
      }

      if (this.statsResults[mediaType].send.currentPacketLossRatio > this.config.videoPacketLossRatioThreshold && mediaType === _constants.STATS.VIDEO_CORRELATE) {
        // Trigger downgrade video callback
        _loggerProxy.default.logger.log('StatsAnalyzer:index#compareSentAndReceived -->  Packet Loss is high ', this.statsResults[mediaType].send.currentPacketLossRatio);

        this.emit({
          file: 'statsAnalyzer',
          function: 'compareSentAndReceived'
        }, _constants.EVENT_TRIGGERS.MEETING_HIGH_PACKETLOSS, {
          mediaType: mediaType,
          packetLossRatio: this.statsResults[mediaType].send.currentPacketLossRatio
        });
      }
    }
  }]);
  return StatsAnalyzer;
}(_eventsScope.default);

exports.default = StatsAnalyzer;
//# sourceMappingURL=index.js.map
