"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _isFinite2 = _interopRequireDefault(require("lodash/isFinite"));

var _keys2 = _interopRequireDefault(require("lodash/keys"));

var _constants = require("../constants");

var StatsCalculator = {};
/**
 * Calculate an interval of values between 2 data points, using updated as the "latest" so updated - previous = interval
 * @param {WebRTCData} previous
 * @param {WebRTCData} updated
 * @returns {Object} interval: {StringKey: IntervalValue, ..., n}
 * @public
 */

StatsCalculator.difference = function (previous, updated) {
  // if there was no previous, just take the updated
  if (!previous || !previous.data || !previous.data.getData || (0, _keys2.default)(previous.data.getData()).length === 0) {
    return updated;
  }

  var interval = {}; // get inside the data from the filtered report

  (0, _keys2.default)(updated.data.getData()).forEach(function (key) {
    interval[key] = interval[key] ? interval[key] : {};
    (0, _keys2.default)(updated.data.getData()[key]).forEach(function (stat) {
      var value = updated.data.getData()[key][stat]; // only use some simple data points that are numbers and aren't silly things like timestamp

      if ((0, _isFinite2.default)(value) && !(_constants.DEFAULT_EXCLUDED_STATS.includes(stat) && value !== 0)) {
        // if there was nothing there before, just return the updated data
        if (!previous.data.getData()[key] || !previous.data.getData()[key][stat]) {
          interval[key][stat] = value;
        } // subract and store
        else {
            value -= previous.data.getData()[key][stat];
            interval[key][stat] = value;
          }
      }
    });
  });
  return interval;
};
/**
 * Calculate an aggregate of values between an old summary and a new data point, using summary as the base to add to so aggregate = summary + data
 * @param {WebRTCData} data
 * @param {Object} summary
 * @returns {Object} aggregate {StringKey: SummedValue, ..., n}
 * @public
 */


StatsCalculator.sum = function (data, summary) {
  var aggregate = summary; // get inside the data from the filtered report

  (0, _keys2.default)(data.data.getData()).forEach(function (key) {
    (0, _keys2.default)(data.data.getData()[key]).forEach(function (stat) {
      var value = data.data.getData()[key][stat]; // only use some simple data points that are numbers and aren't silly things like timestamp

      if ((0, _isFinite2.default)(value) && !(_constants.DEFAULT_EXCLUDED_STATS.includes(stat) && value !== 0)) {
        // if there was something there before, add to that value
        if (aggregate[key][stat]) {
          aggregate[key][stat] += value;
        } // set up the value as the new data point
        else {
            aggregate[key][stat] = value;
          }
      }
    });
  });
  return aggregate;
};

var _default = StatsCalculator;
exports.default = _default;
//# sourceMappingURL=calculator.js.map
