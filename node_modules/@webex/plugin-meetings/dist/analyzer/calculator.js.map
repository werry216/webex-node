{"version":3,"sources":["calculator.js"],"names":["StatsCalculator","difference","previous","updated","data","getData","length","interval","forEach","key","stat","value","DEFAULT_EXCLUDED_STATS","includes","sum","summary","aggregate"],"mappings":"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","sourcesContent":["import {keys, isFinite} from 'lodash';\n\nimport {DEFAULT_EXCLUDED_STATS} from '../constants';\n\nconst StatsCalculator = {};\n\n/**\n * Calculate an interval of values between 2 data points, using updated as the \"latest\" so updated - previous = interval\n * @param {WebRTCData} previous\n * @param {WebRTCData} updated\n * @returns {Object} interval: {StringKey: IntervalValue, ..., n}\n * @public\n */\nStatsCalculator.difference = (previous, updated) => {\n  // if there was no previous, just take the updated\n  if (!previous || !previous.data || !previous.data.getData || keys(previous.data.getData()).length === 0) {\n    return updated;\n  }\n  const interval = {};\n\n  // get inside the data from the filtered report\n  keys(updated.data.getData()).forEach((key) => {\n    interval[key] = interval[key] ? interval[key] : {};\n    keys(updated.data.getData()[key]).forEach((stat) => {\n      let value = updated.data.getData()[key][stat];\n\n      // only use some simple data points that are numbers and aren't silly things like timestamp\n      if (isFinite(value) && !(DEFAULT_EXCLUDED_STATS.includes(stat) && value !== 0)) {\n        // if there was nothing there before, just return the updated data\n        if (!previous.data.getData()[key] || !previous.data.getData()[key][stat]) {\n          interval[key][stat] = value;\n        }\n        // subract and store\n        else {\n          value -= previous.data.getData()[key][stat];\n          interval[key][stat] = value;\n        }\n      }\n    });\n  });\n\n  return interval;\n};\n\n/**\n * Calculate an aggregate of values between an old summary and a new data point, using summary as the base to add to so aggregate = summary + data\n * @param {WebRTCData} data\n * @param {Object} summary\n * @returns {Object} aggregate {StringKey: SummedValue, ..., n}\n * @public\n */\nStatsCalculator.sum = (data, summary) => {\n  const aggregate = summary;\n\n  // get inside the data from the filtered report\n  keys(data.data.getData()).forEach((key) => {\n    keys(data.data.getData()[key]).forEach((stat) => {\n      const value = data.data.getData()[key][stat];\n\n      // only use some simple data points that are numbers and aren't silly things like timestamp\n      if (isFinite(value) && !(DEFAULT_EXCLUDED_STATS.includes(stat) && value !== 0)) {\n        // if there was something there before, add to that value\n        if (aggregate[key][stat]) {\n          aggregate[key][stat] += value;\n        }\n        // set up the value as the new data point\n        else {\n          aggregate[key][stat] = value;\n        }\n      }\n    });\n  });\n\n  return aggregate;\n};\n\nexport default StatsCalculator;\n"]}