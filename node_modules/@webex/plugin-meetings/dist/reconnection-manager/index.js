"use strict";

var _Reflect$construct = require("@babel/runtime-corejs2/core-js/reflect/construct");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/wrapNativeSuper"));

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _triggerProxy = _interopRequireDefault(require("../common/events/trigger-proxy"));

var _constants = require("../constants");

var _reconnection = _interopRequireDefault(require("../common/errors/reconnection"));

var _reconnectionInProgress = _interopRequireDefault(require("../common/errors/reconnection-in-progress"));

var _peerConnectionManager = _interopRequireDefault(require("../peer-connection-manager"));

var _config = require("../metrics/config");

var _media = _interopRequireDefault(require("../media"));

var _metrics = _interopRequireDefault(require("../metrics"));

var _collection = _interopRequireDefault(require("../roap/collection"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Used to indicate that the reconnect logic needs to be retried.
 *
 * @class NeedsRetryError
 * @extends {Error}
 */
var NeedsRetryError = /*#__PURE__*/function (_Error) {
  (0, _inherits2.default)(NeedsRetryError, _Error);

  var _super = _createSuper(NeedsRetryError);

  function NeedsRetryError() {
    (0, _classCallCheck2.default)(this, NeedsRetryError);
    return _super.apply(this, arguments);
  }

  return NeedsRetryError;
}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Error));
/**
 * Used to indicate that the meeting needs to be rejoined, not just media reconnected
 *
 * @class NeedsRejoinError
 * @extends {Error}
 */


var NeedsRejoinError = /*#__PURE__*/function (_Error2) {
  (0, _inherits2.default)(NeedsRejoinError, _Error2);

  var _super2 = _createSuper(NeedsRejoinError);

  /**
   * Creates an instance of NeedsRejoinError.
   * @param {Object} params
   * @param {boolean} params.wasSharing
   * @param {Error} params.error
   * @memberof NeedsRejoinError
   */
  function NeedsRejoinError(_ref) {
    var _this;

    var wasSharing = _ref.wasSharing,
        _ref$error = _ref.error,
        error = _ref$error === void 0 ? new Error('Meeting needs to be rejoined') : _ref$error;
    (0, _classCallCheck2.default)(this, NeedsRejoinError);
    _this = _super2.call(this, error);
    _this.wasSharing = wasSharing;
    return _this;
  }

  return NeedsRejoinError;
}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Error));
/**
 * @export
 * @class ReconnectionManager
*/


var ReconnectionManager = /*#__PURE__*/function () {
  /**
   * @param {Meeting} meeting
   */
  function ReconnectionManager(meeting) {
    (0, _classCallCheck2.default)(this, ReconnectionManager);

    /**
     * Stores ICE reconnection state data.
     *
     * @instance
     * @type {Object}
     * @private
     * @memberof ReconnectionManager
     */
    this.iceState = {
      disconnected: false,
      resolve: function resolve() {},
      timer: undefined,
      timeoutDuration: meeting.config.reconnection.iceReconnectionTimeout
    };
    /**
     * @instance
     * @type {String}
     * @private
     * @memberof ReconnectionManager
    */

    this.status = _constants.RECONNECTION.STATE.DEFAULT_STATUS;
    /**
     * @instance
     * @type {Number}
     * @private
     * @memberof ReconnectionManager
    */

    this.tryCount = _constants.RECONNECTION.STATE.DEFAULT_TRY_COUNT;
    /**
     * @instance
     * @type {Object}
     * @private
     * @memberof ReconnectionManager
    */
    // TODO : change this logic to not save the meeting instance
    // It gets complicated when meeting ends on remote side , We have a old meeting instance which is not up to date

    this.webex = meeting.webex;
    /**
     * @instance
     * @type {Meeting}
     * @private
     * @memberof ReconnectionManager
     */
    // TODO: try removing the circular dependency for meeting and reconnection manager
    // try moving this to meetings collection

    this.meeting = meeting;
    this.maxRejoinAttempts = meeting.config.reconnection.maxRejoinAttempts;
    this.rejoinAttempts = _constants.RECONNECTION.STATE.DEFAULT_TRY_COUNT;
    this.autoRejoinEnabled = meeting.config.reconnection.autoRejoin; // Make sure reconnection state is in default

    this.reset();
  }
  /**
   * Sets the iceState to connected and clears any disconnect timeouts and
   * related timeout data within the iceState.
   *
   * @returns {undefined}
   * @public
   * @memberof ReconnectionManager
   */


  (0, _createClass2.default)(ReconnectionManager, [{
    key: "iceReconnected",
    value: function iceReconnected() {
      if (this.iceState.disconnected) {
        _loggerProxy.default.logger.log('ReconnectionManager:index#iceReconnected --> ice has reconnected');

        this.iceState.resolve();

        this.iceState.resolve = function () {};

        if (this.iceState.timer) {
          clearTimeout(this.iceState.timer);
          delete this.iceState.timer;
        }

        this.iceState.disconnected = false;
      }
    }
    /**
     * Set the iceState to disconnected and generates a timeout that waits for the
     * iceState to reconnect and then resolves. If the ice state is already
     * processing a reconnect, it immediately resolves. Rejects if the timeout
     * duration is reached.
     *
     * @returns {Promise<undefined>}
     * @public
     * @memberof ReconnectionManager
     */

  }, {
    key: "waitForIceReconnect",
    value: function waitForIceReconnect() {
      var _this2 = this;

      if (!this.iceState.disconnected) {
        _loggerProxy.default.logger.log('ReconnectionManager:index#waitForIceReconnect --> waiting for ice reconnect');

        this.iceState.disconnected = true;
        return new _promise.default(function (resolve, reject) {
          _this2.iceState.timer = setTimeout(function () {
            if (_this2.iceState.disconnected === false) {
              resolve();
            } else {
              _this2.iceState.disconnected = false;
              reject(new Error("ice reconnection did not occur in ".concat(_this2.iceState.timeoutDuration, "ms")));
            }
          }, _this2.iceState.timeoutDuration);
          _this2.iceState.resolve = resolve;
        });
      } // return a resolved promise to prevent multiple catch executions of reconnect


      return _promise.default.resolve();
    }
    /**
     * @returns {undefined}
     * @public
     * @memberof ReconnectionManager
     */

  }, {
    key: "reset",
    value: function reset() {
      this.status = _constants.RECONNECTION.STATE.DEFAULT_STATUS;
      this.tryCount = _constants.RECONNECTION.STATE.DEFAULT_TRY_COUNT;
      this.rejoinAttempts = _constants.RECONNECTION.STATE.DEFAULT_TRY_COUNT;
    }
    /**
     * @returns {undefined}
     * @public
     * @memberof ReconnectionManager
     */

  }, {
    key: "cleanUp",
    value: function cleanUp() {
      this.reset();
      this.meeting = null;
    }
    /**
     * @returns {Boolean}
     * @throws {ReconnectionError}
     * @private
     * @memberof ReconnectionManager
     */

  }, {
    key: "validate",
    value: function validate() {
      if (this.meeting.config.reconnection.enabled) {
        if (this.status === _constants.RECONNECTION.STATE.DEFAULT_STATUS || this.status === _constants.RECONNECTION.STATE.COMPLETE) {
          return true;
        }

        _loggerProxy.default.logger.info('ReconnectionManager:index#validate --> Reconnection already in progress.');

        throw new _reconnectionInProgress.default('Reconnection already in progress.');
      }

      _loggerProxy.default.logger.info('ReconnectionManager:index#validate --> Reconnection is not enabled.');

      throw new _reconnection.default('Reconnection is not enabled.');
    }
    /**
     * Initiates a media reconnect for the active meeting
     * @param {Object} reconnectOptions
     * @param {boolean} [reconnectOptions.networkDisconnect=false] indicates if a network disconnect event happened
     * @param {boolean} [reconnectOptions.networkRetry=false] indicates if we are retrying the reconnect
     * @returns {Promise}
     * @public
     * @memberof ReconnectionManager
     */

  }, {
    key: "reconnect",
    value: function () {
      var _reconnect = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        var _this3 = this;

        var _ref2,
            _ref2$networkDisconne,
            networkDisconnect,
            _ref2$networkRetry,
            networkRetry,
            _args = arguments;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _ref2 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, _ref2$networkDisconne = _ref2.networkDisconnect, networkDisconnect = _ref2$networkDisconne === void 0 ? false : _ref2$networkDisconne, _ref2$networkRetry = _ref2.networkRetry, networkRetry = _ref2$networkRetry === void 0 ? false : _ref2$networkRetry;

                _loggerProxy.default.logger.info("ReconnectionManager:index#reconnect --> Reconnection start for meeting ".concat(this.meeting.id, ".")); // First, validate that we can reconnect, if not, it will throw an error


                _context.prev = 2;
                this.validate();
                _context.next = 10;
                break;

              case 6:
                _context.prev = 6;
                _context.t0 = _context["catch"](2);

                _loggerProxy.default.logger.info('ReconnectionManager:index#reconnect --> Reconnection unable to begin.', _context.t0);

                throw _context.t0;

              case 10:
                if (!networkRetry) {
                  // Only log START metrics on the initial reconnect
                  _loggerProxy.default.logger.info('ReconnectionManager:index#reconnect --> Sending reconnect start metric.');

                  _metrics.default.postEvent({
                    event: _config.eventType.MEDIA_RECONNECTING,
                    meeting: this.meeting
                  });
                }

                return _context.abrupt("return", this.executeReconnection({
                  networkDisconnect: networkDisconnect
                }).then(function () {
                  _loggerProxy.default.logger.info('ReconnectionManager:index#reconnect --> Reconnection successful.');

                  _loggerProxy.default.logger.info('ReconnectionManager:index#reconnect --> Sending reconnect success metric.');

                  _metrics.default.postEvent({
                    event: _config.eventType.MEDIA_RECOVERED,
                    meeting: _this3.meeting,
                    data: {
                      recoveredBy: _config.reconnection.RECOVERED_BY_NEW
                    }
                  });
                }).catch(function (reconnectError) {
                  if (reconnectError instanceof NeedsRetryError) {
                    _loggerProxy.default.logger.info('ReconnectionManager:index#reconnect --> Reconnection not successful, retrying.'); // Reset our reconnect status since we are looping back to the beginning


                    _this3.status = _constants.RECONNECTION.STATE.DEFAULT_STATUS; // This is a network retry, so we should not log START metrics again

                    return _this3.reconnect({
                      networkDisconnect: true,
                      networkRetry: true
                    });
                  } // Reconnect has failed


                  _loggerProxy.default.logger.error('ReconnectionManager:index#reconnect --> Reconnection failed.', reconnectError.message);

                  _loggerProxy.default.logger.info('ReconnectionManager:index#reconnect --> Sending reconnect abort metric.');

                  var reconnectMetric = {
                    event: _config.eventType.CALL_ABORTED,
                    meeting: _this3.meeting,
                    data: {
                      errors: [{
                        category: _config.errorObjects.category.expected,
                        errorCode: 2008,
                        fatal: true,
                        name: _config.errorObjects.name.mediaEngine,
                        shownToUser: false
                      }]
                    }
                  };

                  _metrics.default.postEvent(reconnectMetric);

                  if (reconnectError instanceof NeedsRejoinError) {
                    // send call aborded event with catogery as expected as we are trying to rejoin
                    if (_this3.autoRejoinEnabled) {
                      return _this3.rejoinMeeting(reconnectError.wasSharing);
                    }
                  }

                  throw reconnectError;
                }));

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[2, 6]]);
      }));

      function reconnect() {
        return _reconnect.apply(this, arguments);
      }

      return reconnect;
    }()
    /**
     * @param {Object} reconnectOptions
     * @param {boolean} [reconnectOptions.networkDisconnect=false] indicates if a network disconnect event happened
     * @returns {Promise}
     * @throws {NeedsRetryError}
     * @private
     * @memberof ReconnectionManager
     */

  }, {
    key: "executeReconnection",
    value: function () {
      var _executeReconnection = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(_ref3) {
        var _ref3$networkDisconne, networkDisconnect, wasSharing, media;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _ref3$networkDisconne = _ref3.networkDisconnect, networkDisconnect = _ref3$networkDisconne === void 0 ? false : _ref3$networkDisconne;
                this.status = _constants.RECONNECTION.STATE.IN_PROGRESS;

                _loggerProxy.default.logger.info('ReconnectionManager:index#executeReconnection --> Attempting to reconnect to meeting.');

                if (!networkDisconnect) {
                  _context2.next = 15;
                  break;
                }

                _context2.prev = 4;
                _context2.next = 7;
                return this.reconnectMercuryWebSocket();

              case 7:
                _loggerProxy.default.logger.error('ReconnectionManager:index#executeReconnection --> Websocket reconnected.', this.webex.internal.device.url);

                _context2.next = 15;
                break;

              case 10:
                _context2.prev = 10;
                _context2.t0 = _context2["catch"](4);

                _loggerProxy.default.logger.error('ReconnectionManager:index#executeReconnection --> Unable to reconnect to websocket, giving up.');

                this.status = _constants.RECONNECTION.STATE.FAILURE;
                throw _context2.t0;

              case 15:
                wasSharing = this.meeting.shareStatus === _constants.SHARE_STATUS.LOCAL_SHARE_ACTIVE;
                _context2.prev = 16;

                _loggerProxy.default.logger.info('ReconnectionManager:index#executeReconnection --> Updating meeting data from server.');

                _context2.next = 20;
                return this.webex.meetings.syncMeetings();

              case 20:
                _context2.next = 26;
                break;

              case 22:
                _context2.prev = 22;
                _context2.t1 = _context2["catch"](16);

                _loggerProxy.default.logger.info('ReconnectionManager:index#executeReconnection --> Unable to sync meetings, reconnecting.', _context2.t1);

                throw new NeedsRetryError(_context2.t1);

              case 26:
                if (!(!this.meeting || !this.webex.meetings.getMeetingByType(_constants._ID_, this.meeting.id))) {
                  _context2.next = 29;
                  break;
                }

                _loggerProxy.default.logger.info('ReconnectionManager:index#executeReconnection --> Meeting got deleted due to inactivity or ended remotely ');

                throw new Error('Unable to rejoin a meeting already ended or inactive .');

              case 29:
                _loggerProxy.default.logger.info("ReconnectionManager:index#executeReconnection --> Current state of meeting is ".concat(this.meeting.state)); // If the meeting state was left, no longer reconnect media


                if (!(this.meeting.state === _constants._LEFT_)) {
                  _context2.next = 34;
                  break;
                }

                if (!(this.meeting.type === _constants._CALL_)) {
                  _context2.next = 33;
                  break;
                }

                throw new Error('Unable to rejoin a call in LEFT state.');

              case 33:
                throw new NeedsRejoinError({
                  wasSharing: wasSharing
                });

              case 34:
                _context2.prev = 34;
                _context2.next = 37;
                return this.reconnectMedia();

              case 37:
                media = _context2.sent;

                _loggerProxy.default.logger.log('ReconnectionManager:index#executeReconnection --> Media reestablished');

                this.status = _constants.RECONNECTION.STATE.COMPLETE;
                return _context2.abrupt("return", media);

              case 43:
                _context2.prev = 43;
                _context2.t2 = _context2["catch"](34);

                _loggerProxy.default.logger.error('ReconnectionManager:index#executeReconnection --> Media reestablishment failed');

                this.status = _constants.RECONNECTION.STATE.FAILURE;
                throw _context2.t2;

              case 48:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[4, 10], [16, 22], [34, 43]]);
      }));

      function executeReconnection(_x) {
        return _executeReconnection.apply(this, arguments);
      }

      return executeReconnection;
    }()
    /**
     * Rejoins a meeting after detecting the member was in a LEFT state
     *
     * @async
     * @param {boolean} wasSharing
     * @returns {Promise}
     */

  }, {
    key: "rejoinMeeting",
    value: function () {
      var _rejoinMeeting = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
        var wasSharing,
            previousCorrelationId,
            _args3 = arguments;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                wasSharing = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : false;
                _context3.prev = 1;

                _loggerProxy.default.logger.info('ReconnectionManager:index#rejoinMeeting --> attemping meeting rejoin');

                previousCorrelationId = this.meeting.correlationId;
                _context3.next = 6;
                return this.meeting.join({
                  rejoin: true
                });

              case 6:
                _loggerProxy.default.logger.info('ReconnectionManager:index#rejoinMeeting --> meeting rejoined');

                _collection.default.deleteSession(previousCorrelationId);

                if (wasSharing) {
                  // Stop the share streams if user tried to rejoin
                  _media.default.stopTracks(this.meeting.mediaProperties.shareTrack);

                  this.meeting.isSharing = false;

                  if (this.shareStatus === _constants.SHARE_STATUS.LOCAL_SHARE_ACTIVE) {
                    this.meeting.shareStatus = _constants.SHARE_STATUS.NO_SHARE;
                  }

                  this.meeting.mediaProperties.mediaDirection.sendShare = false;

                  _triggerProxy.default.trigger(this.meeting, {
                    file: 'reconnection-manager/index',
                    function: 'rejoinMeeting'
                  }, _constants.EVENT_TRIGGERS.MEETING_STOPPED_SHARING_LOCAL, {
                    reason: _constants.SHARE_STOPPED_REASON.MEETING_REJOIN
                  });
                }

                _context3.next = 23;
                break;

              case 11:
                _context3.prev = 11;
                _context3.t0 = _context3["catch"](1);
                this.rejoinAttempts += 1;

                if (!(this.rejoinAttempts <= this.maxRejoinAttempts)) {
                  _context3.next = 19;
                  break;
                }

                _loggerProxy.default.logger.info("ReconnectionManager:index#rejoinMeeting --> Unable to rejoin meeting, attempt #".concat(this.rejoinAttempts, ", retrying."), _context3.t0);

                this.rejoinMeeting();
                _context3.next = 23;
                break;

              case 19:
                _loggerProxy.default.logger.error('ReconnectionManager:index#rejoinMeeting --> Unable to rejoin meeting after max attempts.', _context3.t0);

                _metrics.default.sendOperationalMetric(_constants.METRICS_OPERATIONAL_MEASURES.MEETING_MAX_REJOIN_FAILURE, {
                  locus_id: this.meeting.locusUrl.split('/').pop(),
                  reason: _context3.t0.message,
                  stack: _context3.t0.stack
                });

                this.status = _constants.RECONNECTION.STATE.FAILURE;
                throw _context3.t0;

              case 23:
                _context3.prev = 23;
                _context3.next = 26;
                return this.reconnectMedia();

              case 26:
                _context3.next = 32;
                break;

              case 28:
                _context3.prev = 28;
                _context3.t1 = _context3["catch"](23);

                _loggerProxy.default.logger.error('ReconnectionManager:index#rejoinMeeting --> Unable to reestablish media after rejoining.', _context3.t1);

                throw _context3.t1;

              case 32:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[1, 11], [23, 28]]);
      }));

      function rejoinMeeting() {
        return _rejoinMeeting.apply(this, arguments);
      }

      return rejoinMeeting;
    }()
    /**
     * @returns {Promise}
     * @private
     * @memberof ReconnectionManager
     */

  }, {
    key: "reconnectMedia",
    value: function reconnectMedia() {
      var _this4 = this;

      _loggerProxy.default.logger.log('ReconnectionManager:index#reconnectMedia --> Begin reestablishment of media');

      ReconnectionManager.setupPeerConnection(this.meeting);
      return _media.default.attachMedia(this.meeting.mediaProperties, {
        meetingId: this.meeting.id,
        remoteQualityLevel: this.meeting.mediaProperties.remoteQualityLevel,
        enableRtx: this.meeting.config.enableRtx
      }).then(function (peerConnection) {
        return _this4.meeting.setRemoteStream(peerConnection);
      }).then(function () {
        _loggerProxy.default.logger.log('ReconnectionManager:index#reconnectMedia --> Sending ROAP media request');

        return _this4.meeting.roap.sendRoapMediaRequest({
          sdp: _this4.meeting.mediaProperties.peerConnection.sdp,
          roapSeq: _this4.meeting.roapSeq,
          meeting: _this4.meeting,
          reconnect: true
        });
      });
    }
    /**
     * Attempt to Reconnect Mercury Websocket
     * @returns {Promise}
     * @private
     * @memberof ReconnectionManager
     */

  }, {
    key: "reconnectMercuryWebSocket",
    value: function () {
      var _reconnectMercuryWebSocket = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _loggerProxy.default.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Reconnecting websocket.'); // First, attempt to disconnect if we think we are already connected.


                if (!this.webex.internal.mercury.connected) {
                  _context4.next = 13;
                  break;
                }

                _loggerProxy.default.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Disconnecting existing websocket.');

                _context4.prev = 3;
                _context4.next = 6;
                return this.webex.internal.mercury.disconnect();

              case 6:
                _loggerProxy.default.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Websocket disconnected successfully.');

                _context4.next = 13;
                break;

              case 9:
                _context4.prev = 9;
                _context4.t0 = _context4["catch"](3);

                // If we can't disconnect, the sdk is in such a bad state that reconnecting is not going to happen.
                _loggerProxy.default.logger.error('ReconnectionManager:index#reconnectMercuryWebSocket --> Unable to disconnect from websocket, giving up.', _context4.t0);

                throw _context4.t0;

              case 13:
                _context4.prev = 13;

                _loggerProxy.default.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Connecting websocket.');

                _context4.next = 17;
                return this.webex.internal.mercury.connect();

              case 17:
                _loggerProxy.default.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Websocket connected successfully.');

                _context4.next = 24;
                break;

              case 20:
                _context4.prev = 20;
                _context4.t1 = _context4["catch"](13);

                _loggerProxy.default.logger.error('ReconnectionManager:index#reconnectMercuryWebSocket --> Unable to connect to websocket, giving up.', _context4.t1);

                throw _context4.t1;

              case 24:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[3, 9], [13, 20]]);
      }));

      function reconnectMercuryWebSocket() {
        return _reconnectMercuryWebSocket.apply(this, arguments);
      }

      return reconnectMercuryWebSocket;
    }()
    /**
     * @param {Meeting} meeting
     * @returns {undefined}
     * @private
     * @memberof ReconnectionManager
     */

  }], [{
    key: "setupPeerConnection",
    value: function setupPeerConnection(meeting) {
      _loggerProxy.default.logger.log('ReconnectionManager:index#setupPeerConnection --> Begin resetting peer connection'); // close pcs, unset to null and create a new one with out closing any streams


      _peerConnectionManager.default.close(meeting.mediaProperties.peerConnection);

      meeting.mediaProperties.unsetPeerConnection();
      meeting.mediaProperties.reInitiatePeerconnection();

      _peerConnectionManager.default.setPeerConnectionEvents(meeting); // update the peerconnection in the stats manager when ever we reconnect


      meeting.statsAnalyzer.updatePeerconnection(meeting.mediaProperties.peerConnection);
    }
  }]);
  return ReconnectionManager;
}();

exports.default = ReconnectionManager;
//# sourceMappingURL=index.js.map
