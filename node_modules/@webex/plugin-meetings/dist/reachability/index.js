"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _now = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/date/now"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/toConsumableArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _uniq2 = _interopRequireDefault(require("lodash/uniq"));

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _constants = require("../constants");

var _request = _interopRequireDefault(require("./request"));

/**
 * @class Reachability
 * @export
 */
var Reachability = /*#__PURE__*/function () {
  /**
   * Creates an instance of Reachability.
   * @param {object} webex
   * @memberof Reachability
   */
  function Reachability(webex) {
    (0, _classCallCheck2.default)(this, Reachability);
    this.webex = webex;
    /**
     * internal request object for the server
     * @instance
     * @type {Array}
     * @private
     * @memberof Reachability
     */

    this.reachabilityRequest = new _request.default(this.webex);
    /**
     * internal object of clusters latency results
     * @instance
     * @type {object}
     * @private
     * @memberof Reachability
     */

    this.clusterLatencyResults = {};
  }
  /**
   * fetches reachability data
   * @returns {Object} reachability data
   * @public
   * @async
   * @memberof Reachability
   */


  (0, _createClass2.default)(Reachability, [{
    key: "gatherReachability",
    value: function () {
      var _gatherReachability = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        var _window, _window$localStorage;

        var clusters, results;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.setup(); // Remove stored reachability results to ensure no stale data

                if (!((_window = window) !== null && _window !== void 0 && (_window$localStorage = _window.localStorage) !== null && _window$localStorage !== void 0 && _window$localStorage.removeItem)) {
                  _context.next = 5;
                  break;
                }

                window.localStorage.removeItem(_constants.REACHABILITY.localStorage);
                _context.next = 7;
                break;

              case 5:
                _loggerProxy.default.logger.error('Reachability:index#gatherReachability --> Error in accessing LocalStorage.');

                return _context.abrupt("return", {});

              case 7:
                _context.prev = 7;
                _context.next = 10;
                return this.reachabilityRequest.getClusters();

              case 10:
                clusters = _context.sent;
                _context.next = 13;
                return this.performReachabilityCheck(clusters);

              case 13:
                results = _context.sent;
                window.localStorage.setItem(_constants.REACHABILITY.localStorage, (0, _stringify.default)(results));
                return _context.abrupt("return", results);

              case 18:
                _context.prev = 18;
                _context.t0 = _context["catch"](7);

                _loggerProxy.default.logger.error("Reachability:index#gatherReachability --> Error in calling getClusters(): ".concat(_context.t0));

                return _context.abrupt("return", {});

              case 22:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[7, 18]]);
      }));

      function gatherReachability() {
        return _gatherReachability.apply(this, arguments);
      }

      return gatherReachability;
    }()
    /**
     * Generate peerConnection config settings
     * @param {object} cluster
     * @returns {object} peerConnectionConfig
     * @private
     * @memberof Reachability
     */

  }, {
    key: "buildPeerConnectionConfig",
    value: function buildPeerConnectionConfig(cluster) {
      var iceServers = (0, _uniq2.default)([].concat((0, _toConsumableArray2.default)(cluster.udp), (0, _toConsumableArray2.default)(cluster.tcp))).map(function (url) {
        return {
          username: '',
          credential: '',
          urls: [url]
        };
      });
      return {
        iceServers: (0, _toConsumableArray2.default)(iceServers),
        iceCandidatePoolSize: '0',
        iceTransportPolicy: 'all'
      };
    }
    /**
     * Creates an RTCPeerConnection
     * @param {object} cluster
     * @returns {RTCPeerConnection} peerConnection
     * @private
     * @memberof Reachability
     */

  }, {
    key: "createPeerConnection",
    value: function createPeerConnection(cluster) {
      var key = cluster.key,
          config = cluster.config;

      try {
        var peerConnection = new window.RTCPeerConnection(config);
        peerConnection.key = key;
        return peerConnection;
      } catch (peerConnectionError) {
        _loggerProxy.default.logger.log("Reachability:index#getLocalSDPForClusters --> Error creating peerConnection: ".concat(peerConnectionError));

        return null;
      }
    }
    /**
     * Gets total elapsed time
     * @param {RTCPeerConnection} peerConnection
     * @returns {Number} Milliseconds
     * @private
     * @memberof Reachability
     */

  }, {
    key: "getElapsedTime",
    value: function getElapsedTime(peerConnection) {
      var startTime = peerConnection.begin;
      delete peerConnection.begin;
      return (0, _now.default)() - startTime;
    }
    /**
     * creates offer and generates localSDP
     * @param {object} clusterList cluster List
     * @returns {Promise} Reachability latency results
     * @private
     * @memberof Reachability
     */

  }, {
    key: "getLocalSDPForClusters",
    value: function getLocalSDPForClusters(clusterList) {
      var _this = this;

      var clusters = (0, _toConsumableArray2.default)((0, _keys.default)(clusterList));
      clusters = clusters.map( /*#__PURE__*/function () {
        var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(key) {
          var cluster, config, peerConnection, description;
          return _regenerator.default.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  cluster = clusterList[key];
                  config = _this.buildPeerConnectionConfig(cluster);
                  peerConnection = _this.createPeerConnection({
                    key: key,
                    config: config
                  });
                  _context2.next = 5;
                  return peerConnection.createOffer({
                    offerToReceiveAudio: true
                  });

                case 5:
                  description = _context2.sent;
                  peerConnection.begin = (0, _now.default)();
                  peerConnection.setLocalDescription(description);
                  return _context2.abrupt("return", _this.iceGatheringState(peerConnection).catch(function (iceGatheringStateError) {
                    _loggerProxy.default.logger.log("Reachability:index#getLocalSDPForClusters --> Error in getLocalSDP : ".concat(iceGatheringStateError));
                  }));

                case 9:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());
      return _promise.default.all(clusters).then(this.parseIceResultsToReachabilityResults).then(function (reachabilityLatencyResults) {
        _this.logUnreachableClusters(); // return results


        return reachabilityLatencyResults;
      });
    }
    /**
     * Get list of all unreachable clusters
     * @returns {array} Unreachable clusters
     * @private
     * @memberof Reachability
     */

  }, {
    key: "getUnreachablClusters",
    value: function getUnreachablClusters() {
      var unreachableList = [];
      var clusters = this.clusterLatencyResults;
      (0, _keys.default)(clusters).forEach(function (key) {
        var cluster = clusters[key];

        if (cluster.unreachable && !cluster.reachable) {
          unreachableList.push(key);
        }
      });
      return unreachableList;
    }
    /**
     * Attach an event handler for the icegatheringstatechange
     * event and measure latency.
     * @param {RTCPeerConnection} peerConnection
     * @returns {undefined}
     * @private
     * @memberof Reachability
     */

  }, {
    key: "handleIceGatheringStateChange",
    value: function handleIceGatheringStateChange(peerConnection) {
      var _this2 = this;

      peerConnection.onicegatheringstatechange = function () {
        var COMPLETE = _constants.ICE_GATHERING_STATE.COMPLETE;

        if (peerConnection.iceConnectionState === COMPLETE) {
          var elapsed = _this2.getElapsedTime(peerConnection);

          _loggerProxy.default.logger.log("Reachability:index#onIceGatheringStateChange --> Successfully pinged ".concat(peerConnection.key, ":"), elapsed);

          _this2.setLatencyAndClose(peerConnection, elapsed);
        }
      };
    }
    /**
     * Attach an event handler for the icecandidate
     * event and measure latency.
     * @param {RTCPeerConnection} peerConnection
     * @returns {undefined}
     * @private
     * @memberof Reachability
     */

  }, {
    key: "handleOnIceCandidate",
    value: function handleOnIceCandidate(peerConnection) {
      var _this3 = this;

      peerConnection.onicecandidate = function (e) {
        var SERVER_REFLEXIVE = 'srflx';

        if (e.candidate && String(e.candidate.type).toLowerCase() === SERVER_REFLEXIVE) {
          var elapsed = _this3.getElapsedTime(peerConnection);

          _loggerProxy.default.logger.log("Reachability:index#onIceCandidate --> Successfully pinged ".concat(peerConnection.key, ":"), elapsed);

          _this3.setLatencyAndClose(peerConnection, elapsed);
        }
      };
    }
    /**
     * An event handler on an RTCPeerConnection when the state of the ICE
     * candidate gathering process changes. Used to measure connection
     * speed.
     * @private
     * @param {RTCPeerConnection} peerConnection
     * @returns {Promise}
     */

  }, {
    key: "iceGatheringState",
    value: function iceGatheringState(peerConnection) {
      var _this4 = this;

      var ELAPSED = 'elapsed';
      var waitTime = 5e3;
      return new _promise.default(function (resolve) {
        var peerConnectionProxy = new window.Proxy(peerConnection, {
          get: function get(target, property) {
            var targetMember = target[property];

            if (typeof targetMember === 'function') {
              return targetMember.bind(target);
            }

            return targetMember;
          },
          set: function set(target, property, value) {
            // only intercept elapsed property
            if (property === ELAPSED) {
              resolve({
                clusterId: peerConnection.key,
                elapsed: value
              });
              return true;
            } // pass thru


            return window.Reflect.set(target, property, value);
          }
        }); // Using peerConnection proxy so handle functions below
        // won't be coupled to our promise implementation

        _this4.handleIceGatheringStateChange(peerConnectionProxy);

        _this4.handleOnIceCandidate(peerConnectionProxy); // Set maximum timeout


        window.setTimeout(function () {
          var CLOSED = {
            CONNECTION_STATE: _constants.CONNECTION_STATE
          }; // Close any open peerConnections

          if (peerConnectionProxy.connectionState !== CLOSED) {
            _this4.setLatencyAndClose(peerConnectionProxy, null);
          }
        }, waitTime);
      });
    }
    /**
     * Make a log of unreachable clusters.
     * @returns {undefined}
     * @private
     * @memberof Reachability
     */

  }, {
    key: "logUnreachableClusters",
    value: function logUnreachableClusters() {
      var list = this.getUnreachablClusters();
      list.forEach(function (cluster) {
        _loggerProxy.default.logger.log("Reachability:index#getLocalSDPForClusters --> No ice candidate for ".concat(cluster, "."));
      });
    }
    /**
     * Calculates time to establish connection
     * @param {array} iceResults iceResults
     * @returns {object} reachabilityMap
     * @private
     * @memberof Reachability
     */

  }, {
    key: "parseIceResultsToReachabilityResults",
    value: function parseIceResultsToReachabilityResults(iceResults) {
      var reachabilityMap = {};
      iceResults.forEach(function (_ref2) {
        var clusterId = _ref2.clusterId,
            elapsed = _ref2.elapsed;
        var latencyResult;

        if (elapsed === null) {
          latencyResult = {
            reachable: 'false'
          };
        } else {
          latencyResult = {
            reachable: 'true',
            latencyInMilliseconds: elapsed.toString()
          };
        }

        reachabilityMap[clusterId] = {
          udp: latencyResult,
          tcp: latencyResult
        };
      });
      return reachabilityMap;
    }
    /**
     * fetches reachability data
     * @param {object} clusterList
     * @returns {Promise<localSDPData>} reachability check results
     * @private
     * @memberof Reachability
     */

  }, {
    key: "performReachabilityCheck",
    value: function performReachabilityCheck(clusterList) {
      var _this5 = this;

      if (!clusterList || !(0, _keys.default)(clusterList).length) {
        return _promise.default.resolve({});
      }

      return new _promise.default(function (resolve) {
        _this5.getLocalSDPForClusters(clusterList).then(function (localSDPData) {
          if (!localSDPData || !(0, _keys.default)(localSDPData).length) {
            // TODO: handle the error condition properly and try retry
            _loggerProxy.default.logger.log('Reachability:index#performReachabilityCheck --> Local SDP is empty or has missing elements..returning');

            resolve({});
          } else {
            resolve(localSDPData);
          }
        }).catch(function (error) {
          _loggerProxy.default.logger.error("Reachability:index#performReachabilityCheck --> Error in getLocalSDPForClusters: ".concat(error));

          resolve({});
        });
      });
    }
    /**
     * Records latency and closes the peerConnection
     * @param {RTCPeerConnection} peerConnection
     * @param {number} elapsed Latency in milliseconds
     * @returns {undefined}
     * @private
     * @memberof Reachability
     */

  }, {
    key: "setLatencyAndClose",
    value: function setLatencyAndClose(peerConnection, elapsed) {
      var _intialState;

      var REACHABLE = 'reachable';
      var UNREACHABLE = 'unreachable';
      var CLOSED = _constants.CONNECTION_STATE.CLOSED;
      var key = peerConnection.key;
      var resultKey = elapsed === null ? UNREACHABLE : REACHABLE;
      var intialState = (_intialState = {}, (0, _defineProperty2.default)(_intialState, REACHABLE, 0), (0, _defineProperty2.default)(_intialState, UNREACHABLE, 0), _intialState);

      if (peerConnection.connectionState === CLOSED) {
        _loggerProxy.default.logger.log("Reachability:index#setLatencyAndClose --> Attempting to set latency of ".concat(elapsed, " on closed peerConnection."));

        return;
      }

      this.clusterLatencyResults[key] = this.clusterLatencyResults[key] || intialState;
      this.clusterLatencyResults[key][resultKey] += 1; // Set to null in case this fired from
      // an event other than onIceCandidate

      peerConnection.onicecandidate = null;
      peerConnection.close();
      peerConnection.elapsed = elapsed;
    }
    /**
     * utility function
     * @returns {undefined}
     * @private
     * @memberof Reachability
     */

  }, {
    key: "setup",
    value: function setup() {
      this.clusterLatencyResults = {};
    }
  }]);
  return Reachability;
}();

exports.default = Reachability;
//# sourceMappingURL=index.js.map
