{"version":3,"sources":["index.js"],"names":["Reachability","webex","reachabilityRequest","ReachabilityRequest","clusterLatencyResults","setup","window","localStorage","removeItem","REACHABILITY","LoggerProxy","logger","error","getClusters","clusters","performReachabilityCheck","results","setItem","cluster","iceServers","udp","tcp","map","url","username","credential","urls","iceCandidatePoolSize","iceTransportPolicy","key","config","peerConnection","RTCPeerConnection","peerConnectionError","log","startTime","begin","clusterList","buildPeerConnectionConfig","createPeerConnection","createOffer","offerToReceiveAudio","description","setLocalDescription","iceGatheringState","catch","iceGatheringStateError","all","then","parseIceResultsToReachabilityResults","reachabilityLatencyResults","logUnreachableClusters","unreachableList","forEach","unreachable","reachable","push","onicegatheringstatechange","COMPLETE","ICE_GATHERING_STATE","iceConnectionState","elapsed","getElapsedTime","setLatencyAndClose","onicecandidate","e","SERVER_REFLEXIVE","candidate","String","type","toLowerCase","ELAPSED","waitTime","resolve","peerConnectionProxy","Proxy","get","target","property","targetMember","bind","set","value","clusterId","Reflect","handleIceGatheringStateChange","handleOnIceCandidate","setTimeout","CLOSED","CONNECTION_STATE","connectionState","list","getUnreachablClusters","iceResults","reachabilityMap","latencyResult","latencyInMilliseconds","toString","length","getLocalSDPForClusters","localSDPData","REACHABLE","UNREACHABLE","resultKey","intialState","close"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* eslint-disable class-methods-use-this */\n/* globals window */\nimport _ from 'lodash';\n\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport {\n  ICE_GATHERING_STATE,\n  CONNECTION_STATE,\n  REACHABILITY\n} from '../constants';\n\nimport ReachabilityRequest from './request';\n\n/**\n * @class Reachability\n * @export\n */\nexport default class Reachability {\n  /**\n   * Creates an instance of Reachability.\n   * @param {object} webex\n   * @memberof Reachability\n   */\n  constructor(webex) {\n    this.webex = webex;\n\n    /**\n     * internal request object for the server\n     * @instance\n     * @type {Array}\n     * @private\n     * @memberof Reachability\n     */\n    this.reachabilityRequest = new ReachabilityRequest(this.webex);\n\n    /**\n     * internal object of clusters latency results\n     * @instance\n     * @type {object}\n     * @private\n     * @memberof Reachability\n     */\n    this.clusterLatencyResults = {};\n  }\n\n\n  /**\n   * fetches reachability data\n   * @returns {Object} reachability data\n   * @public\n   * @async\n   * @memberof Reachability\n   */\n  async gatherReachability() {\n    this.setup();\n\n    // Remove stored reachability results to ensure no stale data\n    if (window?.localStorage?.removeItem) {\n      window.localStorage.removeItem(REACHABILITY.localStorage);\n    }\n    else {\n      LoggerProxy.logger.error('Reachability:index#gatherReachability --> Error in accessing LocalStorage.');\n\n      return {};\n    }\n\n    // Fetch clusters and measure latency\n    try {\n      const clusters = await this.reachabilityRequest.getClusters();\n\n      // Perform Reachability Check\n      const results = await this.performReachabilityCheck(clusters);\n\n      window.localStorage.setItem(REACHABILITY.localStorage, JSON.stringify(results));\n\n      return results;\n    }\n    catch (getClusterError) {\n      LoggerProxy.logger.error(`Reachability:index#gatherReachability --> Error in calling getClusters(): ${getClusterError}`);\n\n      return {};\n    }\n  }\n\n\n  /**\n   * Generate peerConnection config settings\n   * @param {object} cluster\n   * @returns {object} peerConnectionConfig\n   * @private\n   * @memberof Reachability\n   */\n  buildPeerConnectionConfig(cluster) {\n    const iceServers = _.uniq([\n      ...cluster.udp,\n      ...cluster.tcp\n    ]).map((url) => ({\n      username: '',\n      credential: '',\n      urls: [url]\n    }));\n\n    return {\n      iceServers: [\n        ...iceServers\n      ],\n      iceCandidatePoolSize: '0',\n      iceTransportPolicy: 'all'\n    };\n  }\n\n\n  /**\n   * Creates an RTCPeerConnection\n   * @param {object} cluster\n   * @returns {RTCPeerConnection} peerConnection\n   * @private\n   * @memberof Reachability\n   */\n  createPeerConnection(cluster) {\n    const {key, config} = cluster;\n\n    try {\n      const peerConnection = new window.RTCPeerConnection(config);\n\n      peerConnection.key = key;\n\n      return peerConnection;\n    }\n    catch (peerConnectionError) {\n      LoggerProxy.logger.log(`Reachability:index#getLocalSDPForClusters --> Error creating peerConnection: ${peerConnectionError}`);\n\n      return null;\n    }\n  }\n\n\n  /**\n   * Gets total elapsed time\n   * @param {RTCPeerConnection} peerConnection\n   * @returns {Number} Milliseconds\n   * @private\n   * @memberof Reachability\n   */\n  getElapsedTime(peerConnection) {\n    const startTime = peerConnection.begin;\n\n    delete peerConnection.begin;\n\n    return Date.now() - startTime;\n  }\n\n\n  /**\n   * creates offer and generates localSDP\n   * @param {object} clusterList cluster List\n   * @returns {Promise} Reachability latency results\n   * @private\n   * @memberof Reachability\n   */\n  getLocalSDPForClusters(clusterList) {\n    let clusters = [...Object.keys(clusterList)];\n\n    clusters = clusters.map(async (key) => {\n      const cluster = clusterList[key];\n      const config = this.buildPeerConnectionConfig(cluster);\n      const peerConnection = this.createPeerConnection({key, config});\n      const description = await peerConnection.createOffer({offerToReceiveAudio: true});\n\n      peerConnection.begin = Date.now();\n      peerConnection.setLocalDescription(description);\n\n      return this.iceGatheringState(peerConnection)\n        .catch((iceGatheringStateError) => {\n          LoggerProxy.logger.log(`Reachability:index#getLocalSDPForClusters --> Error in getLocalSDP : ${iceGatheringStateError}`);\n        });\n    });\n\n    return Promise.all(clusters)\n      .then(this.parseIceResultsToReachabilityResults)\n      .then((reachabilityLatencyResults) => {\n        this.logUnreachableClusters();\n\n        // return results\n        return reachabilityLatencyResults;\n      });\n  }\n\n\n  /**\n   * Get list of all unreachable clusters\n   * @returns {array} Unreachable clusters\n   * @private\n   * @memberof Reachability\n   */\n  getUnreachablClusters() {\n    const unreachableList = [];\n    const clusters = this.clusterLatencyResults;\n\n    Object.keys(clusters).forEach((key) => {\n      const cluster = clusters[key];\n\n      if (cluster.unreachable && !cluster.reachable) {\n        unreachableList.push(key);\n      }\n    });\n\n    return unreachableList;\n  }\n\n\n  /**\n   * Attach an event handler for the icegatheringstatechange\n   * event and measure latency.\n   * @param {RTCPeerConnection} peerConnection\n   * @returns {undefined}\n   * @private\n   * @memberof Reachability\n   */\n  handleIceGatheringStateChange(peerConnection) {\n    peerConnection.onicegatheringstatechange = () => {\n      const {COMPLETE} = ICE_GATHERING_STATE;\n\n      if (peerConnection.iceConnectionState === COMPLETE) {\n        const elapsed = this.getElapsedTime(peerConnection);\n\n        LoggerProxy.logger.log(`Reachability:index#onIceGatheringStateChange --> Successfully pinged ${peerConnection.key}:`, elapsed);\n        this.setLatencyAndClose(peerConnection, elapsed);\n      }\n    };\n  }\n\n\n  /**\n   * Attach an event handler for the icecandidate\n   * event and measure latency.\n   * @param {RTCPeerConnection} peerConnection\n   * @returns {undefined}\n   * @private\n   * @memberof Reachability\n   */\n  handleOnIceCandidate(peerConnection) {\n    peerConnection.onicecandidate = (e) => {\n      const SERVER_REFLEXIVE = 'srflx';\n\n      if (e.candidate && String(e.candidate.type).toLowerCase() === SERVER_REFLEXIVE) {\n        const elapsed = this.getElapsedTime(peerConnection);\n\n        LoggerProxy.logger.log(`Reachability:index#onIceCandidate --> Successfully pinged ${peerConnection.key}:`, elapsed);\n        this.setLatencyAndClose(peerConnection, elapsed);\n      }\n    };\n  }\n\n\n  /**\n   * An event handler on an RTCPeerConnection when the state of the ICE\n   * candidate gathering process changes. Used to measure connection\n   * speed.\n   * @private\n   * @param {RTCPeerConnection} peerConnection\n   * @returns {Promise}\n   */\n  iceGatheringState(peerConnection) {\n    const ELAPSED = 'elapsed';\n    const waitTime = 5e3;\n\n    return new Promise((resolve) => {\n      const peerConnectionProxy = new window.Proxy(peerConnection, {\n        get(target, property) {\n          const targetMember = target[property];\n\n          if (typeof (targetMember) === 'function') {\n            return targetMember.bind(target);\n          }\n\n          return targetMember;\n        },\n        set: (target, property, value) => {\n          // only intercept elapsed property\n          if (property === ELAPSED) {\n            resolve({clusterId: peerConnection.key, elapsed: value});\n\n            return true;\n          }\n\n          // pass thru\n          return window.Reflect.set(target, property, value);\n        }\n      });\n\n      // Using peerConnection proxy so handle functions below\n      // won't be coupled to our promise implementation\n      this.handleIceGatheringStateChange(peerConnectionProxy);\n      this.handleOnIceCandidate(peerConnectionProxy);\n\n      // Set maximum timeout\n      window.setTimeout(() => {\n        const CLOSED = {CONNECTION_STATE};\n\n        // Close any open peerConnections\n        if (peerConnectionProxy.connectionState !== CLOSED) {\n          this.setLatencyAndClose(peerConnectionProxy, null);\n        }\n      }, waitTime);\n    });\n  }\n\n\n  /**\n   * Make a log of unreachable clusters.\n   * @returns {undefined}\n   * @private\n   * @memberof Reachability\n   */\n  logUnreachableClusters() {\n    const list = this.getUnreachablClusters();\n\n    list.forEach((cluster) => {\n      LoggerProxy.logger.log(`Reachability:index#getLocalSDPForClusters --> No ice candidate for ${cluster}.`);\n    });\n  }\n\n\n  /**\n   * Calculates time to establish connection\n   * @param {array} iceResults iceResults\n   * @returns {object} reachabilityMap\n   * @private\n   * @memberof Reachability\n   */\n  parseIceResultsToReachabilityResults(iceResults) {\n    const reachabilityMap = {};\n\n    iceResults.forEach(({clusterId, elapsed}) => {\n      let latencyResult;\n\n      if (elapsed === null) {\n        latencyResult = {reachable: 'false'};\n      }\n      else {\n        latencyResult = {\n          reachable: 'true',\n          latencyInMilliseconds: (elapsed).toString()\n        };\n      }\n\n      reachabilityMap[clusterId] = {\n        udp: latencyResult,\n        tcp: latencyResult\n      };\n    });\n\n    return reachabilityMap;\n  }\n\n\n  /**\n   * fetches reachability data\n   * @param {object} clusterList\n   * @returns {Promise<localSDPData>} reachability check results\n   * @private\n   * @memberof Reachability\n   */\n  performReachabilityCheck(clusterList) {\n    if (!clusterList || !Object.keys(clusterList).length) {\n      return Promise.resolve({});\n    }\n\n    return new Promise((resolve) => {\n      this.getLocalSDPForClusters(clusterList)\n        .then((localSDPData) => {\n          if (!localSDPData || !Object.keys(localSDPData).length) {\n            // TODO: handle the error condition properly and try retry\n            LoggerProxy.logger.log('Reachability:index#performReachabilityCheck --> Local SDP is empty or has missing elements..returning');\n            resolve({});\n          }\n          else {\n            resolve(localSDPData);\n          }\n        })\n        .catch((error) => {\n          LoggerProxy.logger.error(`Reachability:index#performReachabilityCheck --> Error in getLocalSDPForClusters: ${error}`);\n          resolve({});\n        });\n    });\n  }\n\n\n  /**\n   * Records latency and closes the peerConnection\n   * @param {RTCPeerConnection} peerConnection\n   * @param {number} elapsed Latency in milliseconds\n   * @returns {undefined}\n   * @private\n   * @memberof Reachability\n   */\n  setLatencyAndClose(peerConnection, elapsed) {\n    const REACHABLE = 'reachable';\n    const UNREACHABLE = 'unreachable';\n    const {CLOSED} = CONNECTION_STATE;\n    const {key} = peerConnection;\n    const resultKey = elapsed === null ? UNREACHABLE : REACHABLE;\n    const intialState = {[REACHABLE]: 0, [UNREACHABLE]: 0};\n\n    if (peerConnection.connectionState === CLOSED) {\n      LoggerProxy.logger.log(`Reachability:index#setLatencyAndClose --> Attempting to set latency of ${elapsed} on closed peerConnection.`);\n\n      return;\n    }\n\n    this.clusterLatencyResults[key] = this.clusterLatencyResults[key] || intialState;\n    this.clusterLatencyResults[key][resultKey] += 1;\n\n    // Set to null in case this fired from\n    // an event other than onIceCandidate\n    peerConnection.onicecandidate = null;\n    peerConnection.close();\n    peerConnection.elapsed = elapsed;\n  }\n\n\n  /**\n   * utility function\n   * @returns {undefined}\n   * @private\n   * @memberof Reachability\n   */\n  setup() {\n    this.clusterLatencyResults = {};\n  }\n}\n"]}