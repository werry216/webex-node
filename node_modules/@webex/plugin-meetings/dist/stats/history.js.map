{"version":3,"sources":["history.js"],"names":["StatsHistory","max","history","index","length","getAt","previous","getMostRecent","current","exclusiveEnd","slice","data","removed","pop","unshift"],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;;AACA;AACA;AACA;AACA;IACqBA,Y;AACnB;AACF;AACA;AACA;AACE,wBAAYC,GAAZ,EAAiB;AAAA;;AACf;AACJ;AACA;AACA;AACA;AACA;AACI,SAAKC,OAAL,GAAe,EAAf;AACA;AACJ;AACA;AACA;AACA;AACA;;AACI,SAAKD,GAAL,GAAWA,GAAX;AACD;AAED;AACF;AACA;AACA;AACA;;;;;WACE,eAAM;AACJ,aAAO,KAAKC,OAAZ;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,iBAAQ;AACN,WAAKA,OAAL,GAAe,EAAf;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,eAAMC,KAAN,EAAa;AACX,aAAO,KAAKD,OAAL,CAAaC,KAAb,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,yBAAgB;AACd,aAAO,KAAKD,OAAL,CAAaE,MAAb,GAAsB,CAAtB,GAA0B,KAAKC,KAAL,CAAW,CAAX,CAA1B,GAA0C,IAAjD;AACD;AAED;AACF;AACA;AACA;;;;WACE,yBAAgB;AACd,aAAO;AACLC,QAAAA,QAAQ,EAAE,KAAKC,aAAL,EADL;AAELC,QAAAA,OAAO,EAAE,KAAKN,OAAL,CAAaE,MAAb,GAAsB,CAAtB,GAA0B,KAAKC,KAAL,CAAW,CAAX,CAA1B,GAA0C;AAF9C,OAAP;AAID;AAED;AACF;AACA;AACA;AACA;;;;WACE,kBAASI,YAAT,EAAuB;AACrB,aAAO,KAAKP,OAAL,CAAaQ,KAAb,CAAmB,CAAnB,EAAsBD,YAAtB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,aAAIE,IAAJ,EAAU;AACR,UAAIC,OAAO,GAAG,IAAd;;AAEA,UAAI,KAAKV,OAAL,CAAaE,MAAb,IAAuB,KAAKH,GAAhC,EAAqC;AACnCW,QAAAA,OAAO,GAAG,KAAKV,OAAL,CAAaW,GAAb,EAAV;AACD;;AACD,WAAKX,OAAL,CAAaY,OAAb,CAAqBH,IAArB;AAEA,aAAOC,OAAP;AACD","sourcesContent":["/**\n * stores the last x filtered stream datas\n */\n/**\n * @export\n * @class StatsHistory\n */\nexport default class StatsHistory {\n  /**\n   * instantiate our wrapped history array\n   * @param {Number} max\n   */\n  constructor(max) {\n    /**\n     * @instance\n     * @type {Array}\n     * @public\n     * @memberof StatsHistory\n     */\n    this.history = [];\n    /**\n     * @instance\n     * @type {Number}\n     * @public\n     * @memberof StatsHistory\n     */\n    this.max = max;\n  }\n\n  /**\n   * @returns {Array} the array of stats reports, read from [0] = most recent to [length - 1] = least recent\n   * @public\n   * @memberof StatsHistory\n   */\n  get() {\n    return this.history;\n  }\n\n  /**\n   * deletes the history array and resets it\n   * @returns {undefined}\n   * @public\n   * @memberof StatsHistory\n   */\n  clear() {\n    this.history = [];\n  }\n\n  /**\n   * gets the stored stat\n   * @param {Number} index the location\n   * @returns {Object} the stat at location index\n   * @public\n   * @memberof StatsHistory\n   */\n  getAt(index) {\n    return this.history[index];\n  }\n\n  /**\n   * gets the most recently stored stat\n   * @returns {Object} the most recently added stat to the history recorder\n   * @public\n   * @memberof StatsHistory\n   */\n  getMostRecent() {\n    return this.history.length > 1 ? this.getAt(0) : null;\n  }\n\n  /**\n   * gets the last two values, that can be used to compare\n   * @returns {Object} {previous: WebRTCData, current: WebRTCData}\n   */\n  getComparable() {\n    return {\n      previous: this.getMostRecent(),\n      current: this.history.length > 2 ? this.getAt(1) : null\n    };\n  }\n\n  /**\n   * gets a cut of the n most recent WebRTC datas stored\n   * @param {Number} exclusiveEnd\n   * @returns {Array}\n   */\n  getSlice(exclusiveEnd) {\n    return this.history.slice(0, exclusiveEnd);\n  }\n\n  /**\n   * adds a history entry into tshe array at the head, removes from the tail\n   * if too large, returns the old tail if removed\n   * @param {WebRTCData} data filtered stats report to add to the history array\n   * @returns {Object} the removed stats report at the end if that had to be removed\n   * to make space for the new stats data report to be added to the front\n   */\n  add(data) {\n    let removed = null;\n\n    if (this.history.length >= this.max) {\n      removed = this.history.pop();\n    }\n    this.history.unshift(data);\n\n    return removed;\n  }\n}\n"]}