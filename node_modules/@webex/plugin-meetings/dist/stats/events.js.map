{"version":3,"sources":["events.js"],"names":["operateEvent","operate","type","keys","stat","kind","foundMatch","found","some","key","match","data","StatsEvents","series","callback","MEETINGS","first","sendRemainStopped","recvRemainStopped","getData","operator","EVENT_TYPES","LOCAL","DEFAULT_EVENT_AUDIO_SEND_KEYS","EVENT_STATS_MAP","BYTES_SENT","AUDIO","DEFAULT_EVENT_VIDEO_SEND_KEYS","VIDEO","REMOTE","DEFAULT_EVENT_VIDEO_RECEIVE_KEYS","BYTES_RECEIVED","DEFAULT_EVENT_AUDIO_RECEIVE_KEYS","somethingMatched","find","element","get","length","fiveSecondsData","getSlice","prop","rtpOutAudio","rtpInAudio","rtpInVideo","rtpOutVideo","sendAnalysis","StatsAnalyzer","analyze","analysisKeys","check","ANALYSIS_CHECKS","INCREASING","receiveAnalysis","valid","bytesSent","reports","ret","stop","bytesReceived","start"],"mappings":"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","sourcesContent":["import StatsAnalyzer from '../analyzer/analyzer';\nimport {\n  DEFAULT_EVENT_VIDEO_SEND_KEYS,\n  DEFAULT_EVENT_AUDIO_SEND_KEYS,\n  DEFAULT_EVENT_AUDIO_RECEIVE_KEYS,\n  DEFAULT_EVENT_VIDEO_RECEIVE_KEYS,\n  EVENT_TYPES,\n  EVENT_STATS_MAP,\n  MEETINGS,\n  AUDIO,\n  VIDEO,\n  ANALYSIS_CHECKS\n} from '../constants';\n\n/**\n * @param {Object} operate the filtered, parsed, converted, transformed, simplified data point to check against\n * @param {String} type - local or remote\n * @param {String} keys - the stat keys for types of stats defined by DEFAULT_TRANSFORM_REGEX\n * @param {String} stat - the accessor to get the actual stat\n * @param {String} kind - audio or video\n * @returns {Object} always whatever the first sentFirstVideoBytes were, in the past or if it happened now, or undefined if never\n * @private\n * @memberof StatsEvents\n */\nconst operateEvent = (operate, type, keys, stat, kind) => {\n  const foundMatch = {};\n\n  foundMatch.found = keys.some((key) => {\n    if (operate[key] && operate[key][stat] && operate[key][stat] > 0) {\n      foundMatch.match = {\n        type,\n        key,\n        data: operate[key],\n        stat,\n        kind\n      };\n\n      return true;\n    }\n\n    return false;\n  });\n\n  return foundMatch;\n};\n\n/**\n * @export\n * @class StatsEvents\n */\nexport default class StatsEvents {\n  namespace = MEETINGS;\n\n  /**\n   * constructs an instance\n   * @constructor\n   * @param {StatsHistory} series\n   * @param {Function} callback\n   * @memberof StatsEvents\n   */\n  constructor(series = null, callback = () => {}) {\n    /**\n     * @instance\n     * @type {StatsHistory}\n     * @private\n     * @memberof StatsEvents\n     */\n    this.series = series;\n    /**\n     * @instance\n     * @type {Function}\n     * @private\n     * @memberof StatsEvents\n     */\n    this.callback = callback;\n    /**\n     * @instance\n     * @type {WebRTCData}\n     * @private\n     * @memberof StatsEvents\n     */\n    this.first = null;\n    /**\n     * @instance\n     * @type {Boolean}\n     * @private\n     * @memberof StatsEvents\n     */\n    this.sendRemainStopped = false;\n    /**\n     * @instance\n     * @type {Boolean}\n     * @private\n     * @memberof StatsEvents\n     */\n    this.recvRemainStopped = false;\n  }\n\n  /**\n   * looks for data starting to flow through\n   * @param {WebRTCData} data\n   * @returns {Object}\n   */\n  start(data) {\n    if (data && data.data && data.data.getData()) {\n      const operate = data.data.getData();\n\n      if (operate && !this.first) {\n        const operator = [\n          operateEvent(operate, EVENT_TYPES.LOCAL, DEFAULT_EVENT_AUDIO_SEND_KEYS, EVENT_STATS_MAP.BYTES_SENT, AUDIO),\n          operateEvent(operate, EVENT_TYPES.LOCAL, DEFAULT_EVENT_VIDEO_SEND_KEYS, EVENT_STATS_MAP.BYTES_SENT, VIDEO),\n          operateEvent(operate, EVENT_TYPES.REMOTE, DEFAULT_EVENT_VIDEO_RECEIVE_KEYS, EVENT_STATS_MAP.BYTES_RECEIVED, VIDEO),\n          operateEvent(operate, EVENT_TYPES.REMOTE, DEFAULT_EVENT_AUDIO_RECEIVE_KEYS, EVENT_STATS_MAP.BYTES_RECEIVED, AUDIO)\n        ];\n        const somethingMatched = operator.find((element) => element && element.found && element.match);\n\n        if (somethingMatched) {\n          this.first = somethingMatched.match;\n          this.callback(this.first);\n\n          return somethingMatched;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Looks for data to stop coming through\n   * @returns {Object}\n   */\n  stop() {\n    if (!this.series || this.series.get().length < 5) {\n      return null;\n    }\n    const fiveSecondsData = this.series.getSlice(5);\n    const prop = fiveSecondsData[0] && fiveSecondsData[0].rtpOutAudio || fiveSecondsData[0].rtpInAudio || fiveSecondsData[0].rtpInVideo || fiveSecondsData[0].rtpOutVideo;\n    const sendAnalysis = StatsAnalyzer.analyze(fiveSecondsData, {analysisKeys: [{key: EVENT_STATS_MAP.BYTES_SENT, check: ANALYSIS_CHECKS.INCREASING, prop}]});\n    const receiveAnalysis = StatsAnalyzer.analyze(fiveSecondsData, {analysisKeys: [{key: EVENT_STATS_MAP.BYTES_RECEIVED, check: ANALYSIS_CHECKS.INCREASING, prop}]});\n\n    if (!sendAnalysis.valid && sendAnalysis.data.bytesSent.reports.length > 0) {\n      if (!this.sendRemainStopped) {\n        const ret = {stop: true, stat: EVENT_STATS_MAP.BYTES_SENT};\n\n        this.callback(ret);\n        this.sendRemainStopped = true;\n        this.first = null;\n\n        return ret;\n      }\n    }\n    else if (sendAnalysis.valid && sendAnalysis.data.bytesSent.reports.length > 0) {\n      this.sendRemainStopped = false;\n    }\n    if (!receiveAnalysis.valid && receiveAnalysis.data.bytesReceived.reports.length > 0) {\n      if (!this.recvRemainStopped) {\n        const ret = {stop: true, stat: EVENT_STATS_MAP.BYTES_RECEIVED};\n\n        this.callback(ret);\n        this.recvRemainStopped = true;\n        this.first = null;\n\n        return ret;\n      }\n    }\n    else if (receiveAnalysis.valid && receiveAnalysis.data.bytesReceived.reports.length > 0) {\n      this.recvRemainStopped = false;\n    }\n\n    return null;\n  }\n\n  /**\n   * handles all the types of events that need to be sent when they happen from getStats API\n   * @param {WebRTCData} data\n   * @returns {Object}\n   */\n  event(data) {\n    return {\n      start: this.start(data),\n      stop: this.stop()\n    };\n  }\n}\n"]}