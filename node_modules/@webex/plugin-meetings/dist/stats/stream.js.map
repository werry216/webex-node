{"version":3,"sources":["stream.js"],"names":["pcsByRTCRtpDirection","emittersByRTCRtpDirection","RTCRtpDirectionByEmitter","emittersByStream","timersByEmitter","schedule","emitter","interval","timer","direction","get","pc","getStats","then","stats","emit","STATS","DATA","signalingState","CLOSED","connectionState","catch","err","ERROR","set","StatsStream","config","objectMode","has","rTCRtpDirection","EventEmitter","peerConnection","once","data","isPaused","push","Readable"],"mappings":"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","sourcesContent":["import {EventEmitter} from 'events';\n\nimport {Readable} from 'readable-stream';\nimport {safeSetTimeout} from '@webex/common-timers';\n\nimport {\n  ERROR,\n  STATS\n} from '../constants';\n\nconst pcsByRTCRtpDirection = new WeakMap();\nconst emittersByRTCRtpDirection = new WeakMap();\nconst RTCRtpDirectionByEmitter = new WeakMap();\nconst emittersByStream = new WeakMap();\nconst timersByEmitter = new WeakMap();\n\n/**\n * Helper function that ensures no matter how many stats streams we create, we\n * don't poll the PeerConnection more than once per interval.\n * @param {EventEmitter} emitter\n * @param {Number} interval\n * @private\n * @returns {undefined}\n */\nconst schedule = (emitter, interval) => {\n  const timer = safeSetTimeout(() => {\n    const direction = RTCRtpDirectionByEmitter.get(emitter);\n    const pc = pcsByRTCRtpDirection.get(direction);\n\n    if (direction) {\n      direction.getStats()\n        .then((stats) => {\n          emitter.emit(STATS.DATA, stats);\n          // TODO: Remove on 1.0 spec adoption\n          // \"closed\" is supposed to be part of the {@link RTCPeerConnectionState}\n          // enum according to spec, but at time of writing, was still implemented\n          // in the {@link RTCSignalingState} enum.\n          if (!(pc.signalingState === STATS.CLOSED || pc.connectionState === STATS.CLOSED)) {\n            schedule(emitter, interval);\n          }\n        })\n        .catch((err) => {\n          emitter.emit(ERROR, err);\n        });\n    }\n  }, interval);\n\n  timersByEmitter.set(emitter, timer);\n};\n\n/**\n * Polls an {@link RTCPeerConnection} once per second and emits its {@link RTCStatsReport}\n * {@link RTCStatsReport}\n */\nexport default class StatsStream extends Readable {\n  /**\n   * @private\n   * @param {Object} config\n   * @param {RTCRtpSender|RTCRtpReceiver} config.rTCRtpDirection\n   * @param {RTCPeerConnection} config.peerConnection\n   * @param {Number} config.interval\n   */\n  constructor(config = {}) {\n    super({objectMode: true});\n\n    this.interval = config.interval;\n\n    if (!emittersByRTCRtpDirection.has(config.rTCRtpDirection)) {\n      emittersByRTCRtpDirection.set(config.rTCRtpDirection, new EventEmitter());\n    }\n    const emitter = emittersByRTCRtpDirection.get(config.rTCRtpDirection);\n\n    if (!emittersByStream.has(this)) {\n      emittersByStream.set(this, emitter);\n    }\n    if (!RTCRtpDirectionByEmitter.has(emitter)) {\n      RTCRtpDirectionByEmitter.set(emitter, config.rTCRtpDirection);\n    }\n\n    if (!pcsByRTCRtpDirection.has(config.rTCRtpDirection)) {\n      pcsByRTCRtpDirection.set(config.rTCRtpDirection, config.peerConnection);\n    }\n\n    emitter.once(ERROR, (err) => {\n      this.emit(ERROR, err);\n    });\n  }\n\n  /**\n   * See NodeJS Docs\n   * @private\n   * @returns {undefined}\n   */\n  _read() {\n    const emitter = emittersByStream.get(this);\n\n    emitter.once(STATS.DATA, (data) => {\n      if (!this.isPaused()) {\n        this.push(data);\n      }\n    });\n\n    if (!timersByEmitter.has(emitter)) {\n      schedule(emitter, this.interval);\n    }\n  }\n}\n\n"]}