"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _url = _interopRequireDefault(require("url"));

var _btoa = _interopRequireDefault(require("btoa"));

var _common = require("@webex/common");

var _parameter = _interopRequireDefault(require("../common/errors/parameter"));

var _loggerProxy = _interopRequireDefault(require("../common/logs/logger-proxy"));

var _constants = require("../constants");

var MeetingInfoUtil = {};

MeetingInfoUtil.getParsedUrl = function (link) {
  try {
    var parsedUrl = _url.default.parse(link);

    if (!parsedUrl) {
      return false;
    } // hack for links such as <company>.webex.com/meet/<user> without a protocol


    if (!parsedUrl.protocol) {
      parsedUrl = _url.default.parse("".concat(_constants.HTTPS_PROTOCOL).concat(link));
    }

    return parsedUrl;
  } catch (error) {
    _loggerProxy.default.logger.warn("Meeting-info:util#getParsedUrl --> unable to parse the URL, error: ".concat(error));

    return null;
  }
};
/**
 * Helper function to check if a string matches a known meeting link pattern
 * @param {String} value  string to parse and see if it matches a meeting link
 * @returns {Boolean}
 */


MeetingInfoUtil.isMeetingLink = function (value) {
  var parsedUrl = MeetingInfoUtil.getParsedUrl(value);
  var hostNameBool = parsedUrl.hostname && parsedUrl.hostname.includes(_constants.WEBEX_DOT_COM);
  var pathNameBool = parsedUrl.pathname && (parsedUrl.pathname.includes("/".concat(_constants.MEET)) || parsedUrl.pathname.includes("/".concat(_constants.MEET_M)) || parsedUrl.pathname.includes("/".concat(_constants.JOIN)));
  return hostNameBool && pathNameBool;
};

MeetingInfoUtil.isConversationUrl = function (value, webex) {
  var clusterId = webex.internal.services.getClusterId(value);

  if (clusterId) {
    return clusterId.endsWith(_constants.CONVERSATION_SERVICE);
  }

  return false;
};

MeetingInfoUtil.convertLinkToSip = function (value) {
  var parsedUrl = MeetingInfoUtil.getParsedUrl(value);

  if (!parsedUrl) {
    return null;
  }

  var user;

  if (parsedUrl.pathname) {
    var userIndex = parsedUrl.pathname.lastIndexOf('/');
    user = parsedUrl.pathname.substring(userIndex + 1);
  }

  if (!user) {
    return null;
  }

  var company;

  if (parsedUrl.hostname) {
    var companyIndex = parsedUrl.hostname.lastIndexOf(".".concat(_constants.WEBEX_DOT_COM));
    company = parsedUrl.hostname.substring(0, companyIndex).replace(_constants.WWW_DOT, '');
  }

  if (!company) {
    return null;
  }

  return "".concat(user, "@").concat(company, ".").concat(_constants.WEBEX_DOT_COM);
};

MeetingInfoUtil.isSipUri = function (sipString) {
  // TODO: lets remove regex from this equation and user URI matchers and such
  // have not found a great sip uri parser library as of now
  var sipUri = _constants.DIALER_REGEX.SIP_ADDRESS.exec(sipString);

  return sipUri;
};

MeetingInfoUtil.isPhoneNumber = function (phoneNumber) {
  var isValidNumber = _constants.DIALER_REGEX.PHONE_NUMBER.test(phoneNumber);

  return isValidNumber;
};

MeetingInfoUtil.getHydraId = function (destination) {
  var _deconstructHydraId = (0, _common.deconstructHydraId)(destination),
      type = _deconstructHydraId.type,
      id = _deconstructHydraId.id,
      cluster = _deconstructHydraId.cluster;

  if (id && _constants.UUID_REG.test(id)) {
    if (type === _constants._ROOM_) {
      return {
        room: true,
        destination: id,
        cluster: cluster
      };
    }

    if (type === _constants._PEOPLE_) {
      return {
        people: true,
        destination: id,
        cluster: cluster
      };
    }

    return {};
  }

  return {};
};

MeetingInfoUtil.getSipUriFromHydraPersonId = function (destination, webex) {
  return webex.people.get(destination).then(function (res) {
    if (res.emails && res.emails.length) {
      return res.emails[0];
    }

    throw new _parameter.default('Hydra Id Lookup was an invalid hydra person id.');
  }).catch(function (err) {
    _loggerProxy.default.logger.error("Meeting-info:util#MeetingInfoUtil.getSipUriFromHydraPersonId --> getSipUriFromHydraPersonId ".concat(err, " "));

    throw err;
  });
};

MeetingInfoUtil.generateOptions = /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(from) {
    var destination, type, webex, options, hydraId, conversationUrl;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            destination = from.destination, type = from.type, webex = from.webex;

            if (!type) {
              _context.next = 3;
              break;
            }

            return _context.abrupt("return", {
              destination: destination,
              type: type
            });

          case 3:
            options = {};
            hydraId = MeetingInfoUtil.getHydraId(destination);

            if (!MeetingInfoUtil.isMeetingLink(destination)) {
              _context.next = 11;
              break;
            }

            _loggerProxy.default.logger.warn('Meeting-info:util#generateOptions --> WARN, use of Meeting Link is deprecated, please use a SIP URI instead');

            options.type = _constants._MEETING_LINK_;
            options.destination = destination;
            _context.next = 47;
            break;

          case 11:
            if (!MeetingInfoUtil.isSipUri(destination)) {
              _context.next = 16;
              break;
            }

            options.type = _constants._SIP_URI_;
            options.destination = destination;
            _context.next = 47;
            break;

          case 16:
            if (!MeetingInfoUtil.isPhoneNumber(destination)) {
              _context.next = 21;
              break;
            }

            options.type = _constants._SIP_URI_;
            options.destination = destination;
            _context.next = 47;
            break;

          case 21:
            if (!MeetingInfoUtil.isConversationUrl(destination, webex)) {
              _context.next = 26;
              break;
            }

            options.type = _constants._CONVERSATION_URL_;
            options.destination = destination;
            _context.next = 47;
            break;

          case 26:
            if (!hydraId.people) {
              _context.next = 31;
              break;
            }

            options.type = _constants._SIP_URI_;
            return _context.abrupt("return", MeetingInfoUtil.getSipUriFromHydraPersonId(hydraId.destination, webex).then(function (res) {
              options.destination = res; // Since hydra person ids require a unique case in which they are
              // entirely converted to a SIP URI, we need to set a flag for detecting
              // this type of destination.

              options.wasHydraPerson = true;
              return _promise.default.resolve(options);
            }));

          case 31:
            if (!hydraId.room) {
              _context.next = 46;
              break;
            }

            options.type = _constants._CONVERSATION_URL_;
            _context.prev = 33;
            _context.next = 36;
            return webex.internal.services.waitForCatalog('postauth');

          case 36:
            conversationUrl = webex.internal.conversation.getUrlFromClusterId({
              cluster: hydraId.cluster,
              id: hydraId.destination
            });
            options.destination = conversationUrl;
            _context.next = 44;
            break;

          case 40:
            _context.prev = 40;
            _context.t0 = _context["catch"](33);

            _loggerProxy.default.logger.error("Meeting-info:util#generateOptions --> ".concat(_context.t0));

            throw _context.t0;

          case 44:
            _context.next = 47;
            break;

          case 46:
            throw new _parameter.default('MeetingInfo is fetched with meeting link, sip uri, phone number, hydra room id, hydra people id, or a conversation url.');

          case 47:
            return _context.abrupt("return", _promise.default.resolve(options));

          case 48:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[33, 40]]);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();
/**
 * Helper function to build up a correct locus url depending on the value passed
 * @param {String} type One of [SIP_URI, PERSONAL_ROOM, MEETING_ID, CONVERSATION_URL, LOCUS_ID, MEETING_LINK]
 * @param {Object} value ?? value.value
 * @returns {Object} returns an object with {resource, method}
 */


MeetingInfoUtil.getResourceUrl = function (type, value) {
  var resource = "/".concat(_constants.LOCI, "/").concat(_constants.MEETINGINFO);
  var method = _constants.HTTP_VERBS.GET;
  var uri = null;

  switch (type) {
    case _constants._SIP_URI_:
    case _constants._PERSONAL_ROOM_:
    case _constants._MEETING_ID_:
      resource = "/".concat(_constants.LOCI, "/").concat(_constants.MEETINGINFO, "/").concat(encodeURIComponent(value), "?").concat(_constants.TYPE, "=").concat(type, "&").concat(_constants.USE_URI_LOOKUP_FALSE);
      break;

    case _constants._CONVERSATION_URL_:
      method = _constants.HTTP_VERBS.PUT;
      break;

    case _constants._LOCUS_ID_:
      uri = "".concat(value, "/").concat(_constants.MEETINGINFO);
      method = _constants.HTTP_VERBS.PUT;
      break;

    case _constants._MEETING_LINK_:
      resource = "$/".concat(_constants.LOCI, "/").concat(_constants.MEETINGINFO, "/").concat((0, _btoa.default)(value), "?").concat(_constants.TYPE, "=").concat(_constants._MEETING_LINK_, "&").concat(_constants.USE_URI_LOOKUP_FALSE);
      break;

    default:
  }

  return {
    uri: uri,
    resource: resource,
    method: method
  };
};

MeetingInfoUtil.getRequestParams = function (resourceOptions, type, value, api) {
  var requestParams = {
    method: resourceOptions.method,
    api: api,
    resource: resourceOptions.resource
  };

  if (resourceOptions.method === _constants.HTTP_VERBS.GET) {
    // for handling URL redirections
    requestParams.resource = requestParams.resource.concat("&".concat(_constants.ALTERNATE_REDIRECT_TRUE));
  } else if (type !== _constants._LOCUS_ID_) {
    // locus id check is a PUT not sure why
    requestParams.resource = requestParams.resource.concat("?".concat(_constants.ALTERNATE_REDIRECT_TRUE));
    requestParams.body = {
      value: value,
      lookupType: type
    };
  } else if (type === _constants._LOCUS_ID_) {
    requestParams = {
      method: resourceOptions.method,
      uri: resourceOptions.uri
    };
  }

  return requestParams;
};

var _default = MeetingInfoUtil;
exports.default = _default;
//# sourceMappingURL=util.js.map
