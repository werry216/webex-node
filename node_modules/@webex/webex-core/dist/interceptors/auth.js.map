{"version":3,"sources":["auth.js"],"names":["AuthInterceptor","options","headers","authorization","resolve","requiresCredentials","then","requires","webex","credentials","getUserToken","token","toString","addAuthHeader","internal","services","details","getServiceFromUrl","uri","name","resource","service","api","includes","validateDomains","hasAllowedDomains","isAllowedDomainUrl","waitForService","url","detectedUrl","catch","error","logger","warn","reason","shouldAttemptReauth","info","canRefresh","refresh","replay","reject","replayCount","config","maxAuthenticationReplays","Error","request","shouldRefreshAccessToken","statusCode","Interceptor"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {Interceptor} from '@webex/http-core';\n\n/**\n * @class\n */\nexport default class AuthInterceptor extends Interceptor {\n  /**\n   * @returns {AuthInterceptor}\n   */\n  static create() {\n    return new AuthInterceptor({webex: this});\n  }\n\n  /**\n   * @see {@link Interceptor#onRequest}\n   * @param {Object} options\n   * @returns {Object}\n   */\n  onRequest(options) {\n    options.headers = options.headers || {};\n\n    // If Authorizations is already set, don't overwrite it\n    if ('authorization' in options.headers || 'auth' in options) {\n      // If Authorization is set to null, false, or undefined, delete it to\n      // prevent a CORS preflight.\n      if (!options.headers.authorization) {\n        Reflect.deleteProperty(options.headers, 'authorization');\n      }\n\n      return Promise.resolve(options);\n    }\n\n    return this.requiresCredentials(options)\n      .then((requires) => {\n        if (!requires) {\n          return options;\n        }\n\n        return this.webex.credentials.getUserToken()\n          .then((token) => {\n            options.headers.authorization = token.toString();\n\n            return options;\n          });\n      });\n  }\n\n  /**\n   * Determines if the provided options object needs an authorization header.\n   *\n   * @param {Object} options\n   * @returns {Promise<boolean>}\n   */\n  requiresCredentials(options) {\n    // Validate that authorization is necessary.\n    if (options.addAuthHeader === false) {\n      return Promise.resolve(false);\n    }\n\n    // Validate that the services plugin has been loaded before proceeding.\n    if (!this.webex.internal.services) {\n      return Promise.resolve(false);\n    }\n\n    // Destructure webex instance to isolate services plugin.\n    const {services} = this.webex.internal;\n\n    // Store the current service details if available and destructure details.\n    const details = services.getServiceFromUrl(options.uri || '');\n    const {name} = details || {};\n    const {resource, uri} = options;\n    const service = options.service || options.api;\n\n    // Unique validation for the u2c service.\n    if ((service && service === 'u2c') || (name && name === 'u2c')) {\n      if (\n        (resource && resource.includes('limited')) ||\n        (uri && uri.includes('limited'))\n      ) {\n        return Promise.resolve(false);\n      }\n\n      return Promise.resolve(true);\n    }\n\n\n    // Validate that the allowed domains can be utilized.\n    if (services.validateDomains &&\n      services.hasAllowedDomains() &&\n      (uri && services.isAllowedDomainUrl(uri))) {\n      return Promise.resolve(true);\n    }\n\n    // Perform an additional validation in case the service does not exist yet.\n    return services.waitForService({name: service, url: uri})\n      .then((detectedUrl) => {\n        // Validate that the url exists in the catalog.\n        if (services.getServiceFromUrl(detectedUrl)) {\n          return true;\n        }\n\n        // Return false to indicate authentication is not required.\n        return false;\n      })\n      .catch((error) => {\n        this.webex.logger.warn(\n          'auth-interceptor: failed to validate service exists in catalog',\n          error\n        );\n\n        return false;\n      });\n  }\n\n  /**\n   * @see {@link Interceptor#onResponseError}\n   * @param {Object} options\n   * @param {Error} reason\n   * @returns {Object}\n   */\n  onResponseError(options, reason) {\n    return this.shouldAttemptReauth(reason, options)\n      .then((shouldAttemptReauth) => {\n        if (shouldAttemptReauth) {\n          this.webex.logger.info('auth: received 401, attempting to reauthenticate');\n\n          if (reason.options.headers) {\n            Reflect.deleteProperty(reason.options.headers, 'authorization');\n          }\n\n          if (this.webex.credentials.canRefresh) {\n            return this.webex.credentials.refresh()\n              .then(() => this.replay(options));\n          }\n        }\n\n        return Promise.reject(reason);\n      });\n  }\n\n  /**\n   * Replays the request\n   * @param {Object} options\n   * @returns {Object}\n   */\n  replay(options) {\n    if (options.replayCount) {\n      options.replayCount += 1;\n    }\n    else {\n      options.replayCount = 1;\n    }\n\n    if (options.replayCount > this.webex.config.maxAuthenticationReplays) {\n      this.webex.logger.error(`auth: failed after ${this.webex.config.maxAuthenticationReplays} replay attempts`);\n\n      return Promise.reject(new Error(`Failed after ${this.webex.config.maxAuthenticationReplays} replay attempts`));\n    }\n\n    this.webex.logger.info(`auth: replaying request ${options.replayCount} time`);\n\n    return this.webex.request(options);\n  }\n\n  /**\n   * Indicates whether or not the current request should refresh its access\n   * token in event of a 401\n   * @param {Error} reason\n   * @param {Object} options\n   * @returns {Promise<boolean>}\n   */\n  shouldAttemptReauth(reason, options) {\n    if (options && options.shouldRefreshAccessToken === false) {\n      return Promise.resolve(false);\n    }\n\n    if (reason.statusCode === 401) {\n      return Promise.resolve(true);\n    }\n\n    return Promise.resolve(false);\n  }\n}\n"]}