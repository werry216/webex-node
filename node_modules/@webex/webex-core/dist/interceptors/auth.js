"use strict";

var _Reflect$construct = require("@babel/runtime-corejs2/core-js/reflect/construct");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _deleteProperty = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/delete-property"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _httpCore = require("@webex/http-core");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class
 */
var AuthInterceptor = /*#__PURE__*/function (_Interceptor) {
  (0, _inherits2.default)(AuthInterceptor, _Interceptor);

  var _super = _createSuper(AuthInterceptor);

  function AuthInterceptor() {
    (0, _classCallCheck2.default)(this, AuthInterceptor);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(AuthInterceptor, [{
    key: "onRequest",
    value:
    /**
     * @see {@link Interceptor#onRequest}
     * @param {Object} options
     * @returns {Object}
     */
    function onRequest(options) {
      var _this = this;

      options.headers = options.headers || {}; // If Authorizations is already set, don't overwrite it

      if ('authorization' in options.headers || 'auth' in options) {
        // If Authorization is set to null, false, or undefined, delete it to
        // prevent a CORS preflight.
        if (!options.headers.authorization) {
          (0, _deleteProperty.default)(options.headers, 'authorization');
        }

        return _promise.default.resolve(options);
      }

      return this.requiresCredentials(options).then(function (requires) {
        if (!requires) {
          return options;
        }

        return _this.webex.credentials.getUserToken().then(function (token) {
          options.headers.authorization = token.toString();
          return options;
        });
      });
    }
    /**
     * Determines if the provided options object needs an authorization header.
     *
     * @param {Object} options
     * @returns {Promise<boolean>}
     */

  }, {
    key: "requiresCredentials",
    value: function requiresCredentials(options) {
      var _this2 = this;

      // Validate that authorization is necessary.
      if (options.addAuthHeader === false) {
        return _promise.default.resolve(false);
      } // Validate that the services plugin has been loaded before proceeding.


      if (!this.webex.internal.services) {
        return _promise.default.resolve(false);
      } // Destructure webex instance to isolate services plugin.


      var services = this.webex.internal.services; // Store the current service details if available and destructure details.

      var details = services.getServiceFromUrl(options.uri || '');

      var _ref = details || {},
          name = _ref.name;

      var resource = options.resource,
          uri = options.uri;
      var service = options.service || options.api; // Unique validation for the u2c service.

      if (service && service === 'u2c' || name && name === 'u2c') {
        if (resource && resource.includes('limited') || uri && uri.includes('limited')) {
          return _promise.default.resolve(false);
        }

        return _promise.default.resolve(true);
      } // Validate that the allowed domains can be utilized.


      if (services.validateDomains && services.hasAllowedDomains() && uri && services.isAllowedDomainUrl(uri)) {
        return _promise.default.resolve(true);
      } // Perform an additional validation in case the service does not exist yet.


      return services.waitForService({
        name: service,
        url: uri
      }).then(function (detectedUrl) {
        // Validate that the url exists in the catalog.
        if (services.getServiceFromUrl(detectedUrl)) {
          return true;
        } // Return false to indicate authentication is not required.


        return false;
      }).catch(function (error) {
        _this2.webex.logger.warn('auth-interceptor: failed to validate service exists in catalog', error);

        return false;
      });
    }
    /**
     * @see {@link Interceptor#onResponseError}
     * @param {Object} options
     * @param {Error} reason
     * @returns {Object}
     */

  }, {
    key: "onResponseError",
    value: function onResponseError(options, reason) {
      var _this3 = this;

      return this.shouldAttemptReauth(reason, options).then(function (shouldAttemptReauth) {
        if (shouldAttemptReauth) {
          _this3.webex.logger.info('auth: received 401, attempting to reauthenticate');

          if (reason.options.headers) {
            (0, _deleteProperty.default)(reason.options.headers, 'authorization');
          }

          if (_this3.webex.credentials.canRefresh) {
            return _this3.webex.credentials.refresh().then(function () {
              return _this3.replay(options);
            });
          }
        }

        return _promise.default.reject(reason);
      });
    }
    /**
     * Replays the request
     * @param {Object} options
     * @returns {Object}
     */

  }, {
    key: "replay",
    value: function replay(options) {
      if (options.replayCount) {
        options.replayCount += 1;
      } else {
        options.replayCount = 1;
      }

      if (options.replayCount > this.webex.config.maxAuthenticationReplays) {
        this.webex.logger.error("auth: failed after ".concat(this.webex.config.maxAuthenticationReplays, " replay attempts"));
        return _promise.default.reject(new Error("Failed after ".concat(this.webex.config.maxAuthenticationReplays, " replay attempts")));
      }

      this.webex.logger.info("auth: replaying request ".concat(options.replayCount, " time"));
      return this.webex.request(options);
    }
    /**
     * Indicates whether or not the current request should refresh its access
     * token in event of a 401
     * @param {Error} reason
     * @param {Object} options
     * @returns {Promise<boolean>}
     */

  }, {
    key: "shouldAttemptReauth",
    value: function shouldAttemptReauth(reason, options) {
      if (options && options.shouldRefreshAccessToken === false) {
        return _promise.default.resolve(false);
      }

      if (reason.statusCode === 401) {
        return _promise.default.resolve(true);
      }

      return _promise.default.resolve(false);
    }
  }], [{
    key: "create",
    value:
    /**
     * @returns {AuthInterceptor}
     */
    function create() {
      return new AuthInterceptor({
        webex: this
      });
    }
  }]);
  return AuthInterceptor;
}(_httpCore.Interceptor);

exports.default = AuthInterceptor;
//# sourceMappingURL=auth.js.map
