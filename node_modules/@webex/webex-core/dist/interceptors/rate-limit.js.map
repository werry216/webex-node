{"version":3,"sources":["rate-limit.js"],"names":["rateLimitExpiryTime","idBrokerRegex","RateLimitInterceptor","args","set","options","isRateLimited","uri","reject","Error","resolve","reason","statusCode","includes","setRateLimitExpiry","extractRetryAfterTime","milliMultiplier","retryAfter","headers","apiName","getApiName","currTimeMilli","Date","getTime","expiry","dict","get","expiryTime","undefined","results","match","getRateLimitStatus","webex","Interceptor"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {Interceptor} from '@webex/http-core';\n\n// contains the system time in milliseconds at which the retry after associated with a 429 expires\n// mapped by the API name, e.g.: idbroker.webex.com/doStuff would be mapped as 'doStuff'\nconst rateLimitExpiryTime = new WeakMap();\n\n// extracts the common identity API being called\nconst idBrokerRegex = /.*(idbroker|identity)(bts)?.ciscospark.com\\/([^/]+)/;\n\n/**\n * @class\n */\nexport default class RateLimitInterceptor extends Interceptor {\n  /**\n   * @returns {RateLimitInterceptor}\n   */\n  static create() {\n    return new RateLimitInterceptor({webex: this});\n  }\n\n  /**\n  * constructor\n  * @param {mixed} args\n  * @returns {Exception}\n  */\n  constructor(...args) {\n    super(...args);\n    rateLimitExpiryTime.set(this, new Map());\n  }\n\n  /**\n   * @see {@link Interceptor#onRequest}\n   * @param {Object} options\n   * @returns {Object}\n   */\n  onRequest(options) {\n    if (this.isRateLimited(options.uri)) {\n      return Promise.reject(new Error(`API rate limited ${options.uri}`));\n    }\n\n    return Promise.resolve(options);\n  }\n\n  /**\n   * @see {@link Interceptor#onResponseError}\n   * @param {Object} options\n   * @param {Error} reason\n   * @returns {Object}\n   */\n  onResponseError(options, reason) {\n    if (reason.statusCode === 429 && (options.uri.includes('idbroker') || options.uri.includes('identity'))) {\n      // set the retry after in the map, setting to milliseconds\n      this.setRateLimitExpiry(options.uri, this.extractRetryAfterTime(options));\n    }\n\n    return Promise.reject(reason);\n  }\n\n  /**\n   * @param {object} options associated with the request\n   * @returns {number} retry after time in milliseconds\n   */\n  extractRetryAfterTime(options) {\n    // 1S * 1K === 1MS\n    const milliMultiplier = 1000;\n    const retryAfter = options.headers['retry-after'] || null;\n\n    // set 60 retry if no usable time defined\n    if (retryAfter === null || retryAfter <= 0) {\n      return 60 * milliMultiplier;\n    }\n    // set max to 3600 S (1 hour) if greater than 1 hour\n    if (retryAfter > 3600) {\n      return 3600 * milliMultiplier;\n    }\n\n    return retryAfter * milliMultiplier;\n  }\n\n  /**\n   * Set the system time at which the rate limiting\n   * will expire in the rateLimitExpiryTime map.\n   * Assumes retryAfter is in milliseconds\n   * @param {string} uri API issuing the rate limiting\n   * @param {number} retryAfter milliseconds until rate limiting expires\n   * @returns {bool} true is value was successfully set\n   */\n  setRateLimitExpiry(uri, retryAfter) {\n    const apiName = this.getApiName(uri);\n\n    if (!apiName) {\n      return false;\n    }\n\n    const currTimeMilli = new Date().getTime();\n    const expiry = currTimeMilli + retryAfter;\n    const dict = rateLimitExpiryTime.get(this);\n\n    return dict.set(apiName, expiry);\n  }\n\n  /**\n   * returns true if the API is currently rate limited\n   * @param {string} uri\n   * @returns {Boolean} indicates whether or not the API is rate currently rate limited\n   */\n  getRateLimitStatus(uri) {\n    const apiName = this.getApiName(uri);\n\n    if (!apiName) {\n      return false;\n    }\n\n    const currTimeMilli = new Date().getTime();\n    const dict = rateLimitExpiryTime.get(this);\n    const expiryTime = dict.get(apiName);\n\n    // if no rate limit expiry has been registered in the map, return false.\n    if (expiryTime === undefined) {\n      return false;\n    }\n\n    // return true, indicating rate limiting, if the system time is less than the expiry time\n    return currTimeMilli < dict.get(apiName);\n  }\n\n  /**\n   * split the URI and returns the API name of idBroker\n   * @param {string} uri\n   * @returns {string}\n   */\n  getApiName(uri) {\n    if (!uri) {\n      return null;\n    }\n\n    const results = uri.match(idBrokerRegex);\n\n    if (!results) {\n      return null;\n    }\n\n    // group 0 = full match of URL, group 1 = identity or idbroker base\n    // group 2 = api name\n    return results[2];\n  }\n\n  /**\n   * check URI against list of currently rate limited\n   * URIs, and determines if retry-after\n   * @param {String} uri pattern to check\n   * @returns {bool}\n   */\n  isRateLimited(uri) {\n    // determine if the URI is associated with a common identity API\n    if (uri && (uri.includes('idbroker') || uri.includes('identity'))) {\n      return this.getRateLimitStatus(uri);\n    }\n\n    return false;\n  }\n}\n"]}