{"version":3,"sources":["decorators.js"],"names":["persist","args","length","key","decider","persistDecorator","target","prop","descriptor","TypeError","value","persistExecutor","fn","initializeArgs","ret","changeEvent","on","shouldPersist","Reflect","resolve","boundedStorage","put","prepareInitialize","M","S","BlockingKeyMap","blockingKeys","waitForValue","Error","waitForValueDecorator","add","waitForValueExecutor","keys","get","all","map","k","waitFor","then","prototype","inited","identifyTarget","namespace","stack","id","has","initialize","applyInit","init","self","getNamespace","webex","set","logger","debug","parent","toLowerCase","handle","reason","NotFoundError","process","env","NODE_ENV","toString","includes","error","reject","promises","forEach","push","catch","delete","size","loaded"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* eslint no-invalid-this: [0] */\n\nimport {\n  curry,\n  debounce,\n  identity,\n  result,\n  wrap\n} from 'lodash';\nimport {make} from '@webex/common';\n\nimport {NotFoundError} from './errors';\n\n/**\n * Stores the result of fn before returning it\n * @param  {string} key\n * @private\n * @returns {Promise} resolves with the result of fn\n */\nexport function persist(...args) {\n  if (args.length === 3) {\n    return persist('@')(...args);\n  }\n\n  const [key, decider] = args;\n\n  return function persistDecorator(target, prop, descriptor) {\n    if (prop !== 'initialize') {\n      // Once we have class-based alternative to AmpersandState, it should be\n      // detected here.\n      throw new TypeError('@persist can only currently be applied to AmpersandState objects or their derivatives and must be applied to the initialize method');\n    }\n\n    descriptor.value = wrap(descriptor.value, function persistExecutor(fn, ...initializeArgs) {\n      const ret = Reflect.apply(fn, this, initializeArgs);\n      const changeEvent = key === '@' ? 'change' : `change:${key}`;\n\n      // Some scenarios will lead to lots of change events on a single tick; we\n      // really only care about writing once things have stopped changing. with\n      // a debounce of zero, we're effectively coalescing all the changes\n      // triggered by a single call to set() and commiting them on the next tick\n      // eslint-disable-next-line no-invalid-this\n      this.on(changeEvent, debounce(() => {\n        const shouldPersist = !decider || Reflect.apply(decider, this, ...initializeArgs);\n\n        if (!shouldPersist) {\n          return Promise.resolve();\n        }\n        if (key === '@') {\n          // eslint-disable-next-line no-invalid-this\n          return this.boundedStorage.put(key, this);\n        }\n\n        // eslint-disable-next-line no-invalid-this\n        return this.boundedStorage.put(key, this[key]);\n      }, 0));\n\n      return ret;\n    });\n\n    prepareInitialize(target, prop);\n  };\n}\n\nconst M = Map;\nconst S = Set;\nconst BlockingKeyMap = make(M, M, S);\nconst blockingKeys = new BlockingKeyMap();\n\n/**\n * Prevents fn from executing until key has been (attempted to be) loaded\n * @param {string} key\n * @param {Function} fn\n * @private\n * @returns {Promise} result of fn\n */\nexport function waitForValue(key) {\n  if (!key) {\n    throw new Error('`key` is required');\n  }\n\n  return function waitForValueDecorator(target, prop, descriptor) {\n    blockingKeys.add(target, prop, key);\n    descriptor.value = wrap(descriptor.value, function waitForValueExecutor(fn, ...args) {\n      const keys = blockingKeys.get(target, prop);\n\n      return Promise.all([...keys].map((k) => this.boundedStorage.waitFor(k)))\n        .then(() => Reflect.apply(fn, this, args));\n    });\n\n    // This *should* make decorators compatible with AmpersandState class\n    // definitions\n    if (typeof target === 'object' && !target.prototype) {\n      target[prop] = descriptor.value;\n    }\n\n    prepareInitialize(target, prop);\n\n    return descriptor;\n  };\n}\n\nconst inited = new Set();\n\n/**\n * finds a means of identitying the `target` param passed to\n * `prepareInitialize()`. When possible, avoids duplicate `init()` calls if\n * namespaces collide\n *\n * @param {Object|Constructor} target\n * @private\n * @returns {String|Constructor}\n */\nfunction identifyTarget(target) {\n  if (target.namespace) {\n    return target.namespace;\n  }\n\n  return target;\n}\n\nconst stack = new Set();\n\n/**\n * @param {Function} target\n * @param {string} prop\n * @private\n * @returns {undefined}\n */\nfunction prepareInitialize(target, prop) {\n  const id = identifyTarget(target);\n\n  if (!inited.has(id)) {\n    inited.add(id);\n    if (target.initialize) {\n      target.initialize = wrap(target.initialize, function applyInit(fn, ...args) {\n        const ret = Reflect.apply(fn, this, args);\n\n        Reflect.apply(init, this, args);\n\n        return ret;\n      });\n\n      return;\n    }\n\n    target.initialize = init;\n  }\n\n  /**\n   * @private\n   * @returns {undefined}\n   */\n  function init() {\n    const self = this;\n    const namespace = this.getNamespace();\n\n    this.webex.initialize = wrap(this.webex.initialize || identity, function applyInit(fn, ...args) {\n      // Call webex's initalize method first\n      // Reminder: in order for MockWebex to accept initial storage data, the\n      // wrapped initialize() must be invoked before attempting to load data.\n      // Reminder: context here is `webex`, not `self`.\n      stack.add(namespace);\n      Reflect.apply(fn, this, args);\n\n      // Then prepare a function for setting values retrieved from storage\n      const set = curry((key, value) => {\n        this.logger.debug(`storage:(${namespace}): got \\`${key}\\` for first time`);\n        if (key === '@') {\n          self.parent.set({\n            [namespace.toLowerCase()]: value\n          });\n        }\n        else if (result(self[key], 'isState')) {\n          self[key].set(value);\n        }\n        else {\n          self.set(key, value);\n        }\n        this.logger.debug(`storage:(${namespace}): set \\`${key}\\` for first time`);\n      });\n\n      // And prepare an error handler for when those keys can't be found\n      const handle = curry((key, reason) => {\n        if (reason instanceof NotFoundError || process.env.NODE_ENV !== 'production' && reason.toString().includes('MockNotFoundError')) {\n          this.logger.debug(`storage(${namespace}): no data for \\`${key}\\`, continuing`);\n\n          return Promise.resolve();\n        }\n        this.logger.error(`storage(${namespace}): failed to init \\`${key}\\``, reason);\n\n        return Promise.reject(reason);\n      });\n\n      // Iterate over the list of keys marked as blocking via `@waitForValue`\n      const keys = blockingKeys.get(target, prop);\n      const promises = [];\n\n      keys.forEach((key) => {\n        promises.push(this.boundedStorage.get(namespace, key)\n          .then(set(key))\n          .catch(handle(key)));\n      });\n\n      Promise.all(promises)\n        .then(() => {\n          stack.delete(namespace);\n          if (stack.size === 0) {\n            this.loaded = true;\n          }\n        });\n    });\n  }\n}\n"]}