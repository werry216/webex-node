"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = makeWebexPluginStorage;

var _weakMap = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/weak-map"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/map"));

var _getOwnPropertyDescriptor = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _applyDecoratedDescriptor2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/applyDecoratedDescriptor"));

var _result2 = _interopRequireDefault(require("lodash/result"));

var _isObject2 = _interopRequireDefault(require("lodash/isObject"));

var _isArray2 = _interopRequireDefault(require("lodash/isArray"));

var _common = require("@webex/common");

var _errors = require("./errors");

/*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */
var defers = new _weakMap.default();
/**
 * Walks an object before writing it to the store and omits empty arrays
 * @private
 * @param {Object} value
 * @returns {Object}
 */

function serialize(value) {
  if (!(0, _isObject2.default)(value)) {
    return value;
  }

  var serialized = value.serialize ? value.serialize() : value;
  (0, _keys.default)(serialized).forEach(function (key) {
    var val = serialized[key];

    if ((0, _isArray2.default)(val)) {
      if (val.length === 0) {
        serialized[key] = undefined;
      } else {
        serialized[key] = val.map(serialize);
      }
    } else if ((0, _isObject2.default)(val)) {
      (0, _keys.default)(val).forEach(function (k) {
        val[k] = serialize(val[k]);
      });
    }
  });
  var empty = (0, _keys.default)(serialized).reduce(function (acc, key) {
    return acc && !serialized[key];
  }, true);

  if (empty) {
    return undefined;
  }

  return serialized;
}
/**
 * [makeWebexPluginStorage description]
 * @param {[type]} type
 * @param {[type]} context
 * @private
 * @returns {[type]}
 */


function makeWebexPluginStorage(type, context) {
  var _dec, _class;

  /**
   * Interface between WebexPlugin and Webex#boundeStorage or
   * Webex#unboundedStorage
   */
  var WebexPluginStorage = (_dec = (0, _common.oneFlight)({
    keyFactory: function keyFactory(key) {
      return "initValue-".concat(key);
    }
  }), (_class = /*#__PURE__*/function () {
    /**
     * @param {Object} attrs
     * @param {Object} options
     * @returns {WebexPluginStorage}
     */
    function WebexPluginStorage() {
      (0, _classCallCheck2.default)(this, WebexPluginStorage);
      defers.set(this, new _map.default());
    }
    /**
     * Clears an entire namespace
     * @returns {Promise}
     */


    (0, _createClass2.default)(WebexPluginStorage, [{
      key: "clear",
      value: function clear() {
        return context.webex["".concat(type, "Storage")].del(context.getNamespace());
      }
      /**
       * Deletes the specified key from the store
       * @param {string} key
       * @returns {[type]}
       */

    }, {
      key: "del",
      value: function del() {
        var _context$webex$;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return (_context$webex$ = context.webex["".concat(type, "Storage")]).del.apply(_context$webex$, [context.getNamespace()].concat(args));
      }
      /**
       * Retrieves the value specified by key from the store. Rejects with
       * NotFoundError if no value can be found
       * @param {string} key
       * @returns {Promise}
       */

    }, {
      key: "get",
      value: function get(key) {
        var defer = defers.get(this).get(key);

        if (!defer) {
          defer = new _common.Defer();
          defers.get(this).set(key, defer);
        }

        return context.webex["".concat(type, "Storage")].get(context.getNamespace(), key).then(function (res) {
          defer.resolve();
          return res;
        });
      }
      /**
       * Writes a value to the store
       * @param {string} key
       * @param {any} value
       * @returns {Promise}
       */

    }, {
      key: "put",
      value: function put(key, value) {
        return context.webex["".concat(type, "Storage")].put(context.getNamespace(), key, serialize(value));
      }
      /**
       * Returns a Promise that won't resolve until the value specified by key has
       * been attempted to be loaded from the store. This allows us to lazily
       * prevent certain method from executing until the specified keys have been
       * retrieved from the store.
       * @param {string} key
       * @returns {Promise}
       */

    }, {
      key: "waitFor",
      value: function waitFor(key) {
        context.logger.debug("plugin-storage(".concat(context.getNamespace(), "): waiting to init key `").concat(key, "`"));
        var defer = defers.get(this).get(key);

        if (defer) {
          context.logger.debug("plugin-storage(".concat(context.getNamespace(), "): already inited `").concat(key, "`"));
          return defer.promise;
        }

        context.logger.debug("plugin-storage(".concat(context.getNamespace(), "): initing `").concat(key, "`"));
        return this.initValue(key);
      }
    }, {
      key: "initValue",
      value: function initValue(key) {
        var defer = new _common.Defer();
        defers.get(this).set(key, defer); // Intentionally bypasses this.get so we don't resolve the promise until
        // after the parent value is set.

        context.webex["".concat(type, "Storage")].get(context.getNamespace(), key).then(function (value) {
          context.logger.debug("plugin-storage(".concat(context.getNamespace(), "): got `").concat(key, "` for first time"));

          if (key === '@') {
            context.parent.set(value);
          } else if ((0, _result2.default)(context[key], 'isState')) {
            context[key].set(value);
          } else {
            context.set(key, value);
          }

          context.logger.debug("plugin-storage(".concat(context.getNamespace(), "): set `").concat(key, "` for first time"));
          defer.resolve();
          context.logger.debug("plugin-storage(".concat(context.getNamespace(), "): inited `").concat(key, "`"));
        }).catch(function (reason) {
          // The  next conditional is a bit of an unfortunate solution to deal
          // with circular dependencies in unit tests. It should not effect
          // integration tests or production code.
          if (reason instanceof _errors.NotFoundError || process.env.NODE_ENV !== 'production' && reason.toString().includes('MockNotFoundError')) {
            context.logger.debug("plugin-storage(".concat(context.getNamespace(), "): no data for `").concat(key, "`, continuing"));
            return defer.resolve();
          }

          context.logger.warn("plugin-storage(".concat(context.getNamespace(), "): failed to init `").concat(key, "`"), reason);
          return defer.reject(reason);
        });
        return defer.promise;
      }
    }]);
    return WebexPluginStorage;
  }(), ((0, _applyDecoratedDescriptor2.default)(_class.prototype, "initValue", [_dec], (0, _getOwnPropertyDescriptor.default)(_class.prototype, "initValue"), _class.prototype)), _class));
  return new WebexPluginStorage();
}
//# sourceMappingURL=make-webex-plugin-store.js.map
