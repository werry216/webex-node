"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/map"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _errors = require("./errors");

/*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */

/**
 * Binds a namespace
 * @param {string} namespace
 * @param {Object} options
 * @param {Object} options.data
 * @private
 * @returns {Promise<Object>}
 */
function _bind(namespace) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  options = options || {};

  if (!namespace) {
    return _promise.default.reject(new Error('`namespace` is required'));
  }

  if (!options.logger) {
    return _promise.default.reject(new Error('`options.logger` is required'));
  }

  var _options = options,
      logger = _options.logger;
  var map = new _map.default([['@', {}]]);

  if (options.data) {
    (0, _keys.default)(options.data).forEach(function (key) {
      map.set(key, options.data[key]);
    });
  }

  logger.debug('memory-store-adapter: returning binding');
  return _promise.default.resolve({
    clear: function clear() {
      logger.debug('memory-store-adapter: clearing the binding');
      return _promise.default.resolve(map.clear());
    },
    del: function del(key) {
      logger.debug("memory-store-adapter: deleting `".concat(key, "`"));
      return _promise.default.resolve(map.delete(key));
    },
    get: function get(key) {
      logger.debug("memory-store-adapter: reading `".concat(key, "`"));
      var res = map.get(key);

      if (typeof res === 'undefined') {
        return _promise.default.reject(new _errors.NotFoundError());
      }

      return _promise.default.resolve(res);
    },
    put: function put(key, value) {
      logger.debug("memory-store-adapter: writing `".concat(key, "`"));
      return _promise.default.resolve(map.set(key, value));
    }
  });
}

var _default = {
  bind: _bind,
  preload: function preload(data) {
    return {
      bind: function bind(namespace) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (data[namespace]) {
          options.data = data[namespace];
        }

        return _bind(namespace, options);
      }
    };
  }
};
exports.default = _default;
//# sourceMappingURL=memory-store-adapter.js.map
