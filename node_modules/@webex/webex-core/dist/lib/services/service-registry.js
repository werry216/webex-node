"use strict";

var _Object$keys2 = require("@babel/runtime-corejs2/core-js/object/keys");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");

var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/array/is-array"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _constants = require("./constants");

var _serviceHost = _interopRequireDefault(require("./service-host"));

function ownKeys(object, enumerableOnly) { var keys = _Object$keys2(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * The parameter transfer object for {@link ServiceRegistry#mapRemoteCatalog}.
 * This object is shaped to match the object returned from the **U2C** service.
 *
 * @typedef {Record<string, string>} RSL
 * @typedef {Record<string, Array<Record<string, number | string>>>} RHC
 *
 * @typedef {Object} MapRemoteCatalogPTO
 * @property {string} MapRemoteCatalogPTO.catalog - Service catalog name.
 * @property {RSL} MapRemoteCatalogPTO.serviceLinks - Service links.
 * @property {RHC} MapRemoteCatalogPTO.hostCatalog - Service host catalog.
 */

/**
 * Service manipulation filter object for retrieving services within the
 * {@link ServiceRegistry} class.
 *
 * @typedef {Object} HostFilter
 * @property {boolean} [HostFilter.active] - Active state to filter.
 * @property {Array<string> | string} [HostFilter.catalog] - Catalogs to filter.
 * @property {Array<string> | string} [HostFilter.cluster] - Clusters to filter.
 * @property {boolean} [HostFilter.local] - Filter to the user's home cluster.
 * @property {boolean} [HostFilter.priority] - Filter for the highest priority.
 * @property {Array<string> | string} [HostFilter.service] - Services to filter.
 * @property {Array<string> | string} [HostFilter.url] - URL to filter.
 */

/**
 * @class
 * @classdesc - Manages a collection of {@link ServiceHost} class objects.
 */
var ServiceRegistry = /*#__PURE__*/function () {
  /**
   * Generate a new {@link ServiceHost}.
   *
   * @public
   * @constructor
   * @memberof ServiceHost
   */
  function ServiceRegistry() {
    (0, _classCallCheck2.default)(this, ServiceRegistry);

    /**
     * The collection of managed {@link ServiceHost}s.
     *
     * @instance
     * @type {Array<ServiceHost>}
     * @private
     * @memberof ServiceRegistry
     */
    this.hosts = [];
  }
  /**
   * An active, local, and priority mapped record of the current
   * {@link ServiceCatalog#hosts}.
   *
   * @public
   * @memberof ServiceCatalog
   * @type {Record<string, string>}
   */


  (0, _createClass2.default)(ServiceRegistry, [{
    key: "map",
    get: function get() {
      // Get a list of active, local, and priority-mapped hosts.
      return this.find({
        active: true,
        local: true,
        priority: true
      }).reduce(function (map, host) {
        // Generate a new object to assign the existing map.
        var hostReference = {}; // Assign the key:value pair for the service and url.

        hostReference[host.service] = host.url; // Assign the reference to the map and return.

        return _objectSpread(_objectSpread({}, map), hostReference);
      }, {});
    }
    /**
     * Removes a collection of {@link ServiceHost} class objects from the
     * {@link ServiceRegistry#hosts} array based on the provided
     * {@link HostFilter}.
     *
     * @public
     * @memberof ServiceRegistry
     * @param {HostFilter} filter - The inclusive filter for hosts to remove.
     * @returns {Array<ServiceHost>} - The removed {@link ServiceHost}s.
     */

  }, {
    key: "clear",
    value: function clear(filter) {
      // Collect a list of hosts to remove based on the provided filter.
      var removing = this.find(filter); // Remove the hosts from the array.

      this.hosts = this.hosts.filter(function (host) {
        return !removing.includes(host);
      }); // Return the removed hosts.

      return removing;
    }
    /**
     * Mark a collection of {@link ServiceHost} class objects from the
     * {@link ServiceRegistry#hosts} array as failed based on the provided
     * {@link HostFilter}.
     *
     * @public
     * @memberof ServiceRegistry
     * @param {HostFilter} filter - The inclusive filter for hosts to mark failed.
     * @returns {Array<ServiceHost>} - The {@link ServiceHost}s marked failed.
     */

  }, {
    key: "failed",
    value: function failed(filter) {
      // Collect a list of hosts to mark as failed based on the provided filter.
      var failing = this.find(filter); // Mark the hosts from the array as failed.

      failing.forEach(function (host) {
        host.setStatus({
          failed: true
        });
      }); // Return the marked hosts.

      return failing;
    }
    /**
     * Filter the {@link ServiceRegistry#hosts} array against their active states.
     *
     * @private
     * @memberof ServiceRegistry
     * @param {boolean} [active] - Filter for the host state.
     * @returns {Array<ServiceHost>} - The filtered host array.
     */

  }, {
    key: "filterActive",
    value: function filterActive(active) {
      // Filter the host array if the active requirement is true.
      return typeof active === 'boolean' ? this.hosts.filter(function (host) {
        return host.active === active;
      }) : (0, _toConsumableArray2.default)(this.hosts);
    }
    /**
     * Filter the {@link ServiceRegistry#hosts} array against their assigned
     * catalog values.
     *
     * @private
     * @memberof ServiceRegistry
     * @param {Array<string> | string} [catalog] - Catalogs to filter.
     * @returns {Array<ServiceHost>} - The filtered host array.
     */

  }, {
    key: "filterCatalog",
    value: function filterCatalog() {
      var catalog = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      // Generate a catalog names array based on the provided catalog param.
      var catalogs = ((0, _isArray.default)(catalog) ? catalog : [catalog]).map(function (catalogId) {
        return ServiceRegistry.mapCatalogName({
          id: catalogId,
          type: _constants.SERVICE_CATALOGS_ENUM_TYPES.STRING
        }) || catalogId;
      }); // Filter the host array against the catalog names array.

      return catalogs.length > 0 ? this.hosts.filter(function (host) {
        return catalogs.includes(host.catalog);
      }) : (0, _toConsumableArray2.default)(this.hosts);
    }
    /**
     * Filter the {@link ServiceRegistry#hosts} array against their assigned
     * cluster values.
     *
     * @private
     * @memberof ServiceRegistry
     * @param {Array<string> | string} [cluster] - Clusters to filter for.
     * @returns {Array<ServiceHost>} - The filtered host array.
     */

  }, {
    key: "filterCluster",
    value: function filterCluster() {
      var cluster = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      // Generate an array of clusters regardless of parameter type.
      var clusters = (0, _isArray.default)(cluster) ? cluster : [cluster]; // Filter the host array against the provided clusters.

      return clusters.length > 0 ? this.hosts.filter(function (host) {
        return clusters.includes(host.id);
      }) : (0, _toConsumableArray2.default)(this.hosts);
    }
    /**
     * Filter the {@link ServiceRegistry#hosts} array against their location in
     * reference to the authenticated user.
     *
     * @private
     * @memberof ServiceRegistry
     * @param {boolean} [local] - Filter for the host location.
     * @returns {Array<ServiceHost>} - The filtered host array.
     */

  }, {
    key: "filterLocal",
    value: function filterLocal(local) {
      return typeof local === 'boolean' ? this.hosts.filter(function (host) {
        return host.local === local;
      }) : (0, _toConsumableArray2.default)(this.hosts);
    }
    /**
     * Filter the {@link ServiceRegistry#hosts} array for the highest priority
     * hosts for each specific service.
     *
     * @private
     * @memberof ServiceRegistry
     * @param {boolean} [priority] - Filter for the highest priority
     * @returns {Array<ServiceHost>} - The filtered host array.
     */

  }, {
    key: "filterPriority",
    value: function filterPriority(priority) {
      return priority ? this.hosts.reduce(function (filteredHosts, currentHost) {
        // Validate that the current host is not active.
        if (!currentHost.active) {
          return filteredHosts;
        } // Determine if the filtered hosts array contains a host from the same
        // host group.


        var foundHost = filteredHosts.find(function (host) {
          return host.hostGroup === currentHost.hostGroup;
        }); // Validate if a host was found.

        if (!foundHost) {
          filteredHosts.push(currentHost);
          return filteredHosts;
        } // Map the found host's catalog to its priority value.


        var foundHostCatalogPriority = ServiceRegistry.mapCatalogName({
          id: foundHost.catalog,
          type: _constants.SERVICE_CATALOGS_ENUM_TYPES.NUMBER
        }); // Map the current host's catalog to its priority value.

        var currentHostCatalogPriority = ServiceRegistry.mapCatalogName({
          id: currentHost.catalog,
          type: _constants.SERVICE_CATALOGS_ENUM_TYPES.NUMBER
        }); // Validate if the found host has a lower priority than the current
        // host.

        if (foundHostCatalogPriority < currentHostCatalogPriority || foundHost.priority < currentHost.priority) {
          filteredHosts.splice(filteredHosts.indexOf(foundHost, 1));
          filteredHosts.push(currentHost);
        }

        return filteredHosts;
      }, []) : (0, _toConsumableArray2.default)(this.hosts);
    }
    /**
     * Filter the {@link ServiceRegistry#hosts} array for hosts with a specified
     * set of service names.
     *
     * @private
     * @memberof ServiceRegistry
     * @param {Array<string> | string} [service] - Services to filter.
     * @returns {Array<ServiceHost>} - The filtered host array.
     */

  }, {
    key: "filterService",
    value: function filterService() {
      var service = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      // Generate an array of services regardless of parameter type.
      var services = (0, _isArray.default)(service) ? service : [service]; // Filter the host array against the provided services.

      return services.length > 0 ? this.hosts.filter(function (host) {
        return services.includes(host.service);
      }) : (0, _toConsumableArray2.default)(this.hosts);
    }
    /**
     * Filter the {@link ServiceRegistry#hosts} array for hosts with a specified
     * set of URLs.
     *
     * @private
     * @memberof ServiceRegistry
     * @param {Array<string> | string} [url] - URL to filter.
     * @returns {Array<ServiceHost>} - The filter host array.
     */

  }, {
    key: "filterUrl",
    value: function filterUrl() {
      var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      // Generate an array of URLs regardless of the parameter type.
      var urls = (0, _isArray.default)(url) ? url : [url]; // Filter the host array against the provided URLs.

      return urls.length > 0 ? this.hosts.filter(function (host) {
        return urls.includes(host.url);
      }) : (0, _toConsumableArray2.default)(this.hosts);
    }
    /**
     * Get an array of {@link ServiceHost}s based on a provided
     * {@link HostFilter} from the {@link ServiceRegistry#hosts} array.
     *
     * @public
     * @memberof ServiceRegistry
     * @param {HostFilter} [filter] - The inclusive filter for hosts to find.
     * @returns {Array<ServiceHost>} - The filtered hosts.
     */

  }, {
    key: "find",
    value: function find() {
      var _this = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          active = _ref.active,
          catalog = _ref.catalog,
          cluster = _ref.cluster,
          local = _ref.local,
          priority = _ref.priority,
          service = _ref.service,
          url = _ref.url;

      return this.hosts.filter(function (host) {
        return _this.filterActive(active).includes(host) && _this.filterCatalog(catalog).includes(host) && _this.filterCluster(cluster).includes(host) && _this.filterLocal(local).includes(host) && _this.filterPriority(priority).includes(host) && _this.filterService(service).includes(host) && _this.filterUrl(url).includes(host);
      });
    }
    /**
     * Load a formatted array of {@link ServiceHost} constructor parameter
     * transfer objects as instances of {@link ServiceHost} class objects to the
     * {@link ServiceRegistry#hosts} array.
     *
     * @public
     * @memberof ServiceRegistry
     * @param {Array<ServiceHost.ConstructorPTO>} hosts
     * @returns {this}
     */

  }, {
    key: "load",
    value: function load() {
      var _this$hosts;

      var hosts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      // Validate that the provided hosts are eligible to be loaded.
      var validHosts = hosts.filter(function (host) {
        return !!ServiceRegistry.mapCatalogName({
          id: host.catalog,
          type: _constants.SERVICE_CATALOGS_ENUM_TYPES.STRING
        });
      }); // Load the eligible hosts.

      (_this$hosts = this.hosts).push.apply(_this$hosts, (0, _toConsumableArray2.default)(validHosts.map(function (loadableHost) {
        return new _serviceHost.default(loadableHost);
      })));

      return this;
    }
    /**
     * Mark a collection of {@link ServiceHost} class objects from the
     * {@link ServiceRegistry#hosts} array as replaced based on the provided
     * {@link HostFilter}.
     *
     * @public
     * @memberof ServiceRegistry
     * @param {HostFilter} filter - The inclusive filter to mark replaced.
     * @returns {Array<ServiceHost>} - The {@link ServiceHost}s marked replaced.
     */

  }, {
    key: "replaced",
    value: function replaced(filter) {
      // Collect a list of hosts to mark as replaced based on the provided filter.
      var replacing = this.find(filter); // Mark the hosts from the array as replaced.

      replacing.forEach(function (host) {
        host.setStatus({
          replaced: true
        });
      }); // Return the marked hosts.

      return replacing;
    }
    /**
     * Reset the failed status of a collection of {@link ServiceHost} class
     * objects from the {@link ServiceRegistry#hosts} array based on the provided
     * {@link HostFilter}.
     *
     * @public
     * @memberof ServiceRegistry
     * @param {HostFilter} filter - The inclusive filter of hosts to reset.
     * @returns {Array<ServiceHost>} - The {@link ServiceHost}s that reset.
     */

  }, {
    key: "reset",
    value: function reset(filter) {
      // Collect a list of hosts to mark as replaced based on the provided filter.
      var resetting = this.find(filter); // Mark the hosts from the array as replaced.

      resetting.forEach(function (host) {
        host.setStatus({
          failed: false
        });
      }); // Return the marked hosts.

      return resetting;
    }
    /**
     * Convert a {@link SERVICE_CATALOGS} identifier or value to its associated
     * idenfier or value.
     *
     * @public
     * @static
     * @memberof ServiceRegistry
     * @param {Object} pto - The parameter transfer object.
     * @property {string | number} pto.id - The identifier to convert in the enum.
     * @property {SERVICE_CATALOGS_ENUM_TYPES} pto.type - The desired output.
     * @returns {string|number} - The matching enum value or index.
     */

  }], [{
    key: "mapCatalogName",
    value: function mapCatalogName(_ref2) {
      var id = _ref2.id,
          type = _ref2.type;

      // Validate that the id is a number.
      if (typeof id === 'number') {
        // Validate that the desired type is a number.
        if (type === _constants.SERVICE_CATALOGS_ENUM_TYPES.NUMBER) {
          return _constants.SERVICE_CATALOGS[id] !== undefined ? id : undefined;
        } // Validate that the desired type is a string.


        if (type === _constants.SERVICE_CATALOGS_ENUM_TYPES.STRING) {
          return _constants.SERVICE_CATALOGS[id];
        }
      } // Validate that the id is a string.


      if (typeof id === 'string') {
        // Validate that the desired type is a string.
        if (type === _constants.SERVICE_CATALOGS_ENUM_TYPES.STRING) {
          return _constants.SERVICE_CATALOGS.includes(id) ? id : undefined;
        } // Validate that the desired type is a number.


        if (type === _constants.SERVICE_CATALOGS_ENUM_TYPES.NUMBER) {
          return _constants.SERVICE_CATALOGS.includes(id) ? _constants.SERVICE_CATALOGS.indexOf(id) : undefined;
        }
      }

      return undefined;
    }
    /**
     * Generate a formatted array based on the object received from the **U2C**
     * service for usage in the {@link ServiceRegistry#load} method.
     *
     * @public
     * @static
     * @memberof ServiceRegistry
     * @param {MapRemoteCatalogPTO} pto - The parameter transfer object.
     * @throws - If the target catalog does not exist.
     * @returns {Array<ServiceHost#ServiceHostConstructorPTO>}
     */

  }, {
    key: "mapRemoteCatalog",
    value: function mapRemoteCatalog(_ref3) {
      var catalog = _ref3.catalog,
          hostCatalog = _ref3.hostCatalog,
          serviceLinks = _ref3.serviceLinks;
      // Collect the service catalog name if needed.
      var catalogIndex = ServiceRegistry.mapCatalogName({
        id: catalog,
        type: _constants.SERVICE_CATALOGS_ENUM_TYPES.STRING
      }); // Validate that the target catalog exists.

      if (!_constants.SERVICE_CATALOGS.includes(catalogIndex)) {
        throw new Error("service-catalogs: '".concat(catalog, "' is not a valid catalog"));
      } // Map the remote catalog to a mountable host array.


      return (0, _keys.default)(hostCatalog).reduce(function (output, key) {
        output.push.apply(output, (0, _toConsumableArray2.default)(hostCatalog[key].map(function (host) {
          return {
            catalog: catalogIndex,
            defaultUri: serviceLinks[host.id.split(':')[3]],
            hostGroup: key,
            id: host.id,
            priority: host.priority,
            uri: host.host
          };
        })));
        return output;
      }, []);
    }
  }]);
  return ServiceRegistry;
}();

exports.default = ServiceRegistry;
//# sourceMappingURL=service-registry.js.map
