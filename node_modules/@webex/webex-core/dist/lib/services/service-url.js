"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _url = _interopRequireDefault(require("url"));

var _ampersandState = _interopRequireDefault(require("ampersand-state"));

/* eslint-disable no-underscore-dangle */

/**
 * @class
 */
var ServiceUrl = _ampersandState.default.extend({
  namespace: 'ServiceUrl',
  props: {
    defaultUrl: ['string', true, undefined],
    hosts: ['array', false, function () {
      return [];
    }],
    name: ['string', true, undefined]
  },

  /**
   * Generate a host url based on the host
   * uri provided.
   * @param {string} hostUri
   * @returns {string}
   */
  _generateHostUrl: function _generateHostUrl(hostUri) {
    var url = _url.default.parse(this.defaultUrl); // setting url.hostname will not apply during Url.format(), set host via
    // a string literal instead.


    url.host = "".concat(hostUri).concat(url.port ? ":".concat(url.port) : '');
    return _url.default.format(url);
  },

  /**
   * Generate a list of urls based on this
   * `ServiceUrl`'s known hosts.
   * @returns {string[]}
   */
  _getHostUrls: function _getHostUrls() {
    var _this = this;

    return this.hosts.map(function (host) {
      return {
        url: _this._generateHostUrl(host.host),
        priority: host.priority
      };
    });
  },

  /**
   * Get the current host url with the highest priority. If a clusterId is not
   * provided, this will only return a URL with a filtered host that has the
   * `homeCluster` value set to `true`.
   *
   * @param {string} [clusterId] - The clusterId to filter for a priority host.
   * @returns {string} - The priority host url.
   */
  _getPriorityHostUrl: function _getPriorityHostUrl(clusterId) {
    if (this.hosts.length === 0) {
      return this.defaultUrl;
    }

    var filteredHosts = clusterId ? this.hosts.filter(function (host) {
      return host.id === clusterId;
    }) : this.hosts.filter(function (host) {
      return host.homeCluster;
    });
    var aliveHosts = filteredHosts.filter(function (host) {
      return !host.failed;
    });
    filteredHosts = aliveHosts.length === 0 ? filteredHosts.map(function (host) {
      /* eslint-disable-next-line no-param-reassign */
      host.failed = false;
      return host;
    }) : aliveHosts;
    return this._generateHostUrl(filteredHosts.reduce(function (previous, current) {
      return previous.priority > current.priority || !previous.homeCluster ? current : previous;
    }, {}).host);
  },

  /**
   * Attempt to mark a host from this `ServiceUrl` as failed and return true
   * if the provided url has a host that could be successfully marked as failed.
   *
   * @param {string} url
   * @returns {boolean}
   */
  failHost: function failHost(url) {
    if (url === this.defaultUrl) {
      return true;
    }

    var _Url$parse = _url.default.parse(url),
        hostname = _Url$parse.hostname;

    var foundHost = this.hosts.find(function (hostObj) {
      return hostObj.host === hostname;
    });

    if (foundHost) {
      foundHost.failed = true;
    }

    return foundHost !== undefined;
  },

  /**
   * Get the current `defaultUrl` or generate a url using the host with the
   * highest priority via host rendering.
   *
   * @param {boolean} [priorityHost] - Retrieve the priority host.
   * @param {string} [clusterId] - Cluster to match a host against.
   * @returns {string} - The full service url.
   */
  get: function get(priorityHost, clusterId) {
    if (!priorityHost) {
      return this.defaultUrl;
    }

    return this._getPriorityHostUrl(clusterId);
  }
});
/* eslint-enable no-underscore-dangle */


var _default = ServiceUrl;
exports.default = _default;
//# sourceMappingURL=service-url.js.map
