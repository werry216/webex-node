"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

_Object$defineProperty(exports, "default", {
  enumerable: true,
  get: function get() {
    return _conversation.default;
  }
});

_Object$defineProperty(exports, "ShareActivity", {
  enumerable: true,
  get: function get() {
    return _shareActivity.default;
  }
});

_Object$defineProperty(exports, "ConversationError", {
  enumerable: true,
  get: function get() {
    return _convoError.ConversationError;
  }
});

_Object$defineProperty(exports, "InvalidUserCreation", {
  enumerable: true,
  get: function get() {
    return _convoError.InvalidUserCreation;
  }
});

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _deleteProperty = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/delete-property"));

var _has2 = _interopRequireDefault(require("lodash/has"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _capitalize2 = _interopRequireDefault(require("lodash/capitalize"));

require("@webex/internal-plugin-encryption");

require("@webex/internal-plugin-user");

var _common = require("@webex/common");

var _helperHtml = require("@webex/helper-html");

var _webexCore = require("@webex/webex-core");

var _conversation = _interopRequireDefault(require("./conversation"));

var _config = _interopRequireDefault(require("./config"));

var _encryptionTransforms = require("./encryption-transforms");

var _decryptionTransforms = require("./decryption-transforms");

var _shareActivity = _interopRequireDefault(require("./share-activity"));

var _convoError = require("./convo-error");

/*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */
(0, _webexCore.registerInternalPlugin)('conversation', _conversation.default, {
  payloadTransformer: {
    predicates: [{
      name: 'transformObject',
      test: function test(ctx, optionsOrResponse) {
        return _promise.default.resolve((0, _has2.default)(optionsOrResponse, 'body.objectType'));
      },
      extract: function extract(optionsOrResponse) {
        return _promise.default.resolve(optionsOrResponse.body);
      }
    }, {
      name: 'transformObject',
      direction: 'inbound',
      test: function test(ctx, event) {
        return _promise.default.resolve((0, _has2.default)(event, 'activity'));
      },
      extract: function extract(event) {
        return _promise.default.resolve(event.activity);
      }
    }, {
      name: 'transformObjectArray',
      direction: 'inbound',
      test: function test(ctx, response) {
        return _promise.default.resolve((0, _has2.default)(response, 'body.multistatus'));
      },
      extract: function extract(response) {
        return _promise.default.resolve(response.body.multistatus.map(function (item) {
          return item && item.data && item.data.activity;
        }));
      }
    }, {
      name: 'normalizeConversationListAndBindDecrypters',
      direction: 'inbound',
      test: function test(ctx, options) {
        if (!(0, _has2.default)(options, 'body.items[0].objectType')) {
          return _promise.default.resolve(false);
        }

        if ((0, _get2.default)(options, 'options.deferDecrypt')) {
          return _promise.default.resolve(true);
        }

        return _promise.default.resolve(false);
      },
      extract: function extract(options) {
        return _promise.default.resolve(options.body.items);
      }
    }, {
      name: 'transformObjectArray',
      direction: 'inbound',
      test: function test(ctx, options) {
        if (!(0, _has2.default)(options, 'body.items[0].objectType')) {
          return _promise.default.resolve(false);
        }

        if ((0, _get2.default)(options, 'options.deferDecrypt')) {
          return _promise.default.resolve(false);
        }

        return _promise.default.resolve(true);
      },
      extract: function extract(options) {
        return _promise.default.resolve(options.body.items);
      }
    }, {
      name: 'transformThreadArray',
      direction: 'inbound',
      test: function test(ctx, options) {
        if (!(0, _has2.default)(options, 'body.items[0].childType') || !(0, _has2.default)(options, 'body.items[0].actorId')) {
          return _promise.default.resolve(false);
        }

        if ((0, _get2.default)(options, 'options.deferDecrypt')) {
          return _promise.default.resolve(false);
        }

        return _promise.default.resolve(true);
      },
      extract: function extract(options) {
        return _promise.default.resolve(options.body.items);
      }
    }],
    transforms: [{
      name: 'normalizeConversationListAndBindDecrypters',
      fn: function fn(ctx, array) {
        return _promise.default.all(array.map(function (item) {
          return ctx.transform('normalizeObject', item).then(function () {
            item.decrypt = function decrypt() {
              (0, _deleteProperty.default)(item, 'decrypt');
              return ctx.transform('decryptObject', item);
            };

            return item;
          });
        }));
      }
    }, {
      name: 'transformObjectArray',
      fn: function fn(ctx, array) {
        return _promise.default.all(array.map(function (item) {
          return ctx.transform('transformObject', item);
        }));
      }
    }, {
      name: 'transformThreadArray',
      fn: function fn(ctx, array) {
        return _promise.default.all(array.map(function (item) {
          return ctx.transform('transformThread', item);
        }));
      }
    }, {
      name: 'transformObject',
      direction: 'outbound',
      fn: function fn(ctx, object) {
        if (!object) {
          return _promise.default.resolve();
        }

        if (!object.objectType) {
          return _promise.default.resolve();
        }

        return ctx.transform('normalizeObject', object).then(function () {
          return ctx.transform('encryptObject', object);
        }).then(function () {
          return ctx.transform('encryptKmsMessage', object);
        });
      }
    }, {
      name: 'transformObject',
      direction: 'inbound',
      fn: function fn(ctx, object) {
        if (!object) {
          return _promise.default.resolve();
        }

        if (!object.objectType) {
          return _promise.default.resolve();
        }

        return ctx.transform('decryptObject', object).then(function () {
          return ctx.transform('normalizeObject', object);
        });
      }
    }, {
      name: 'normalizeObject',
      fn: function fn(ctx, object) {
        if (!object) {
          return _promise.default.resolve();
        }

        if (!object.objectType) {
          return _promise.default.resolve();
        }

        return _promise.default.all([ctx.transform("normalize".concat((0, _capitalize2.default)(object.objectType)), object), ctx.transform('normalizePropContent', object)]);
      }
    }, {
      name: 'transformThread',
      direction: 'inbound',
      fn: function fn(ctx, object) {
        if (!object) {
          return _promise.default.resolve();
        }

        return ctx.transform('decryptThread', object).then(function () {
          return ctx.transform('normalizeThread', object);
        });
      }
    }, {
      name: 'normalizePropContent',
      direction: 'inbound',
      fn: function fn(ctx, object) {
        if (!object.content) {
          return _promise.default.resolve();
        }

        var _ctx$webex$config$con = ctx.webex.config.conversation,
            inboundProcessFunc = _ctx$webex$config$con.inboundProcessFunc,
            allowedInboundTags = _ctx$webex$config$con.allowedInboundTags,
            allowedInboundStyles = _ctx$webex$config$con.allowedInboundStyles;
        return (0, _helperHtml.filter)(inboundProcessFunc, allowedInboundTags || {}, allowedInboundStyles, object.content).then(function (c) {
          object.content = c;
        });
      }
    }, {
      name: 'normalizePropContent',
      direction: 'outbound',
      fn: function fn(ctx, object) {
        if (!object.content) {
          return _promise.default.resolve();
        }

        var _ctx$webex$config$con2 = ctx.webex.config.conversation,
            outboundProcessFunc = _ctx$webex$config$con2.outboundProcessFunc,
            allowedOutboundTags = _ctx$webex$config$con2.allowedOutboundTags,
            allowedOutboundStyles = _ctx$webex$config$con2.allowedOutboundStyles;
        return (0, _helperHtml.filterEscape)(outboundProcessFunc, allowedOutboundTags || {}, allowedOutboundStyles, object.content).then(function (c) {
          object.content = c;
        });
      }
    }, {
      name: 'normalizeConversation',
      fn: function fn(ctx, conversation) {
        conversation.activities = conversation.activities || {};
        conversation.activities.items = conversation.activities.items || [];
        conversation.participants = conversation.participants || {};
        conversation.participants.items = conversation.participants.items || [];
        return _promise.default.all([_promise.default.all(conversation.activities.items.map(function (item) {
          return ctx.transform('normalizeObject', item);
        })), _promise.default.all(conversation.participants.items.map(function (item) {
          return ctx.transform('normalizeObject', item);
        }))]);
      }
    }, {
      name: 'normalizeActivity',
      fn: function fn(ctx, activity) {
        return _promise.default.all([ctx.transform('normalizeObject', activity.actor), ctx.transform('normalizeObject', activity.object), ctx.transform('normalizeObject', activity.target)]);
      }
    }, {
      name: 'normalizeThread',
      fn: function fn(ctx, threadActivity) {
        // childActivities are of type Activity
        return _promise.default.all(threadActivity.childActivities.map(function (item) {
          return ctx.transform('normalizeObject', item);
        }));
      }
    }, {
      name: 'normalizePerson',
      // eslint-disable-next-line complexity
      fn: function fn(ctx, person) {
        var email = person.entryEmail || person.emailAddress || person.id;
        var id = person.entryUUID || person.id;

        if (_common.patterns.email.test(email)) {
          person.entryEmail = person.emailAddress = email.toLowerCase();
        } else {
          (0, _deleteProperty.default)(person, 'entryEmail');
          (0, _deleteProperty.default)(person, 'emailAddress');
        }

        if (person.roomProperties) {
          person.roomProperties.isModerator = Boolean(person.roomProperties.isModerator);
        }

        if (_common.patterns.uuid.test(id)) {
          person.entryUUID = person.id = id.toLowerCase();
          return _promise.default.resolve(person);
        }

        if (!email) {
          return _promise.default.reject(new Error('cannot determine id without an `emailAddress` or `entryUUID` property'));
        }

        return ctx.webex.internal.user.asUUID(email).then(function (uuid) {
          person.entryUUID = person.id = uuid;
          return person;
        });
      }
    }].concat(_decryptionTransforms.transforms).concat(_encryptionTransforms.transforms)
  },
  config: _config.default
});
//# sourceMappingURL=index.js.map
