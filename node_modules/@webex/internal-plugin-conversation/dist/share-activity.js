"use strict";

var _Array$from = require("@babel/runtime-corejs2/core-js/array/from");

var _Symbol2 = require("@babel/runtime-corejs2/core-js/symbol");

var _Symbol$iterator = require("@babel/runtime-corejs2/core-js/symbol/iterator");

var _Array$isArray = require("@babel/runtime-corejs2/core-js/array/is-array");

var _getIterator = require("@babel/runtime-corejs2/core-js/get-iterator");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = exports.FILE_SYMBOL = exports.EMITTER_SYMBOL = void 0;

var _symbol = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/symbol"));

var _map2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/map"));

var _apply = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/apply"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/assign"));

var _deleteProperty = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/delete-property"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _some2 = _interopRequireDefault(require("lodash/some"));

var _pick2 = _interopRequireDefault(require("lodash/pick"));

var _map3 = _interopRequireDefault(require("lodash/map"));

var _filter2 = _interopRequireDefault(require("lodash/filter"));

var _events = require("events");

var _nodeScr = _interopRequireDefault(require("node-scr"));

var _common = require("@webex/common");

var _webexCore = require("@webex/webex-core");

var _helperImage = require("@webex/helper-image");

var _sha = _interopRequireDefault(require("crypto-js/sha256"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof _Symbol2 === "undefined" || o[_Symbol$iterator] == null) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = _getIterator(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return _Array$from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var EMITTER_SYMBOL = (0, _symbol.default)('EMITTER_SYMBOL');
exports.EMITTER_SYMBOL = EMITTER_SYMBOL;
var FILE_SYMBOL = (0, _symbol.default)('FILE_SYMBOL');
exports.FILE_SYMBOL = FILE_SYMBOL;
var PROMISE_SYMBOL = (0, _symbol.default)('PROMISE_SYMBOL');
/**
 * @class
 */

var ShareActivity = _webexCore.WebexPlugin.extend({
  getSymbols: function getSymbols() {
    return {
      file: FILE_SYMBOL,
      emitter: EMITTER_SYMBOL
    };
  },
  namespace: 'Conversation',
  derived: {
    target: {
      deps: ['conversation'],
      fn: function fn() {
        return this.conversation;
      }
    }
  },
  session: {
    conversation: {
      required: true,
      type: 'object'
    },
    content: 'string',
    clientTempId: 'string',
    displayName: 'string',
    enableThumbnails: {
      default: true,
      type: 'boolean'
    },
    hiddenSpaceUrl: 'object',
    mentions: 'object',
    spaceUrl: 'object',
    uploads: {
      type: 'object',
      default: function _default() {
        return new _map2.default();
      }
    }
  },
  initialize: function initialize(attrs, options) {
    (0, _apply.default)(_webexCore.WebexPlugin.prototype.initialize, this, [attrs, options]);

    if (attrs && attrs.conversation) {
      this.spaceUrl = _promise.default.resolve(attrs.conversation._spaceUrl || this._retrieveSpaceUrl("".concat(attrs.conversation.url, "/space")).then(function (url) {
        attrs.conversation._spaceUrl = url;
        return url;
      }));
      this.hiddenSpaceUrl = _promise.default.resolve(attrs.conversation._hiddenSpaceUrl || this._retrieveSpaceUrl("".concat(attrs.conversation.url, "/space/hidden")).then(function (url) {
        attrs.conversation._hiddenSpaceUrl = url;
        return url;
      }));
    }
  },

  /**
   * Adds an additional GIF to the share activity
   * Different from regular add to skip uploading to webex files service
   * @param {File} gif
   * @param {File} gif.image // thumbnail
   * @param {Object} options
   * @param {Object} options.actions
   * @returns {Promise}
   */
  addGif: function addGif(gif, options) {
    var gifToAdd = this.uploads.get(gif); // If the gif already exists, then don't do anything

    if (gifToAdd) {
      return _promise.default.resolve();
    }

    gifToAdd = (0, _assign.default)((0, _defineProperty2.default)({
      displayName: gif.name,
      fileSize: gif.size || gif.byteLength || gif.length,
      mimeType: gif.type,
      url: 'https://giphy.com',
      objectType: 'file',
      height: gif.height,
      width: gif.width,
      image: {
        height: gif.image.height,
        width: gif.image.width,
        url: 'https://giphy.com'
      }
    }, FILE_SYMBOL, gif), (0, _pick2.default)(options, 'actions'));
    this.uploads.set(gif, gifToAdd);
    /* Instead of encryptBinary, which produces a encrypted version of
     * the file for upload and a SCR (contains info needed to encrypt the
     * SCR itself and the displayName), we directly create an SCR.
     * Because we are skipping uploading, the encrypted file is not needed.
     */

    return _nodeScr.default.create().then(function (scr) {
      scr.loc = gif.url;
      gifToAdd.scr = scr;
      return _nodeScr.default.create();
    }).then(function (thumbnailScr) {
      thumbnailScr.loc = gif.image.url;
      gifToAdd.image.scr = thumbnailScr;
    });
  },

  /**
   * Adds an additional file to the share and begins submitting it to webex
   * files
   * @param {File} file
   * @param {Object} options
   * @param {Object} options.actions
   * @returns {EventEmittingPromise}
   */
  add: function add(file, options) {
    var _Object$assign3,
        _this = this;

    options = options || {};
    var upload = this.uploads.get(file);

    if (upload) {
      return upload[PROMISE_SYMBOL];
    }

    var emitter = new _events.EventEmitter();
    upload = (0, _assign.default)((_Object$assign3 = {
      displayName: file.name,
      fileSize: file.size || file.byteLength || file.length,
      mimeType: file.type,
      objectType: 'file'
    }, (0, _defineProperty2.default)(_Object$assign3, EMITTER_SYMBOL, emitter), (0, _defineProperty2.default)(_Object$assign3, FILE_SYMBOL, file), _Object$assign3), (0, _pick2.default)(options, 'actions'));
    this.uploads.set(file, upload);
    var promise = (0, _helperImage.detectFileType)(file, this.logger).then(function (type) {
      upload.mimeType = type;
      return (0, _helperImage.processImage)({
        file: file,
        type: type,
        thumbnailMaxWidth: _this.config.thumbnailMaxWidth,
        thumbnailMaxHeight: _this.config.thumbnailMaxHeight,
        enableThumbnails: _this.enableThumbnails,
        logger: _this.logger
      });
    }).then(function (imageData) {
      var main = _this.webex.internal.encryption.encryptBinary(file).then(function (_ref) {
        var scr = _ref.scr,
            cdata = _ref.cdata;
        upload.scr = scr;
        return _promise.default.all([cdata, _this.spaceUrl]);
      }).then(function (_ref2) {
        var _ref3 = (0, _slicedToArray2.default)(_ref2, 2),
            cdata = _ref3[0],
            spaceUrl = _ref3[1];

        var uploadPromise = _this._upload(cdata, "".concat(spaceUrl, "/upload_sessions"));

        (0, _common.transferEvents)('progress', uploadPromise, emitter);
        return uploadPromise;
      }).then(function (metadata) {
        upload.url = upload.scr.loc = metadata.downloadUrl;
      });

      var thumb;

      if (imageData) {
        var _imageData = (0, _slicedToArray2.default)(imageData, 3),
            thumbnail = _imageData[0],
            fileDimensions = _imageData[1],
            thumbnailDimensions = _imageData[2];

        (0, _assign.default)(upload, fileDimensions);

        if (thumbnail && thumbnailDimensions) {
          upload.image = thumbnailDimensions;
          thumb = _this.webex.internal.encryption.encryptBinary(thumbnail).then(function (_ref4) {
            var scr = _ref4.scr,
                cdata = _ref4.cdata;
            upload.image.scr = scr;
            return _promise.default.all([cdata, _this.hiddenSpaceUrl]);
          }).then(function (_ref5) {
            var _ref6 = (0, _slicedToArray2.default)(_ref5, 2),
                cdata = _ref6[0],
                spaceUrl = _ref6[1];

            return _this._upload(cdata, "".concat(spaceUrl, "/upload_sessions"));
          }).then(function (metadata) {
            upload.image.url = upload.image.scr.loc = metadata.downloadUrl;
          });
        }
      }

      return _promise.default.all([main, thumb]);
    });
    upload[PROMISE_SYMBOL] = promise;
    (0, _common.proxyEvents)(emitter, promise);
    return promise;
  },

  /**
   * Fetches the files from the share
   * @returns {Array}
   */
  getFiles: function getFiles() {
    var files = [];

    var _iterator = _createForOfIteratorHelper(this.uploads),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = (0, _slicedToArray2.default)(_step.value, 1),
            key = _step$value[0];

        files.push(this.uploads.get(key)[FILE_SYMBOL]);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return files;
  },

  /**
   * @param {File} file
   * @param {string} uri
   * @private
   * @returns {Promise}
   */
  _upload: function _upload(file, uri) {
    var fileSize = file.length || file.size || file.byteLength;
    var fileHash = (0, _sha.default)(file).toString();
    return this.webex.upload({
      uri: uri,
      file: file,
      qs: {
        transcode: true
      },
      phases: {
        initialize: {
          fileSize: fileSize
        },
        upload: {
          $url: function $url(session) {
            return session.uploadUrl;
          }
        },
        finalize: {
          $uri: function $uri(session) {
            return session.finishUploadUrl;
          },
          body: {
            fileSize: fileSize,
            fileHash: fileHash
          }
        }
      }
    });
  },

  /**
   * Removes the specified file from the share (Does not currently delete the
   * uploaded file)
   * @param {File} file
   * @returns {Promise}
   */
  remove: function remove(file) {
    this.uploads.delete(file); // Returns a promise for future-proofiness.

    return _promise.default.resolve();
  },

  /**
   * @private
   * @returns {Promise<Object>}
   */
  prepare: function prepare() {
    if (!this.uploads.size) {
      throw new Error('Cannot submit a share activity without atleast one file');
    }

    var activity = {
      verb: 'share',
      object: {
        objectType: 'content',
        displayName: this.object && this.object.displayName ? this.object.displayName : undefined,
        content: this.object && this.object.content ? this.object.content : undefined,
        mentions: this.object && this.object.mentions ? this.object.mentions : undefined,
        files: {
          items: []
        }
      },
      clientTempId: this.clientTempId
    };
    var promises = [];
    this.uploads.forEach(function (item) {
      activity.object.files.items.push(item);
      promises.push(item[PROMISE_SYMBOL]);
    });
    activity.object.contentCategory = this._determineContentCategory(activity.object.files.items);
    return _promise.default.all(promises).then(function () {
      return activity;
    });
  },

  /**
   * @param {Array} items
   * @param {string} mimeType
   * @private
   * @returns {boolean}
   */
  _itemContainsActionWithMimeType: function _itemContainsActionWithMimeType(items, mimeType) {
    return (0, _some2.default)(items.map(function (item) {
      return (0, _some2.default)(item.actions, {
        mimeType: mimeType
      });
    }));
  },

  /**
   * @param {Array} items
   * @private
   * @returns {string}
   */
  _determineContentCategory: function _determineContentCategory(items) {
    // determine if the items contain an image
    if (this._itemContainsActionWithMimeType(items, 'application/x-cisco-webex-whiteboard')) {
      return 'documents';
    }

    var mimeTypes = (0, _filter2.default)((0, _map3.default)(items, 'mimeType'));

    if (mimeTypes.length !== items.length) {
      return 'documents';
    }

    var contentCategory = mimeTypes[0].split('/').shift();

    if (contentCategory !== 'video' && contentCategory !== 'image') {
      return 'documents';
    }

    var _iterator2 = _createForOfIteratorHelper(mimeTypes),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var mimeType = _step2.value;

        if (mimeType.split('/').shift() !== contentCategory) {
          return 'documents';
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return "".concat(contentCategory, "s");
  },

  /**
   * @param {string} uri
   * @returns {Promise}
   */
  _retrieveSpaceUrl: function _retrieveSpaceUrl(uri) {
    return this.webex.request({
      method: 'PUT',
      uri: uri
    }).then(function (res) {
      return res.body.spaceUrl;
    });
  },
  version: "1.125.6"
});
/**
 * Instantiates a ShareActivity
 * @param {Object} conversation
 * @param {ShareActivity|Object|array} object
 * @param {ProxyWebex} webex
 * @returns {ShareActivity}
 */


ShareActivity.create = function create(conversation, object, webex) {
  var _object$object, _files$items, _files;

  if (object instanceof ShareActivity) {
    return object;
  }

  var files;

  if (object !== null && object !== void 0 && (_object$object = object.object) !== null && _object$object !== void 0 && _object$object.files) {
    files = object.object.files;
    (0, _deleteProperty.default)(object.object, 'files');
  }

  var share = new ShareActivity((0, _assign.default)({
    conversation: conversation
  }, object), {
    parent: webex
  });
  files = (_files$items = (_files = files) === null || _files === void 0 ? void 0 : _files.items) !== null && _files$items !== void 0 ? _files$items : files;

  if (files) {
    files.forEach(function (file) {
      return share.add(file);
    });
  }

  return share;
};

var _default2 = ShareActivity;
exports.default = _default2;
//# sourceMappingURL=share-activity.js.map
