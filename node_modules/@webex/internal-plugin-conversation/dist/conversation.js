"use strict";

var _Array$from = require("@babel/runtime-corejs2/core-js/array/from");

var _Symbol = require("@babel/runtime-corejs2/core-js/symbol");

var _Symbol$iterator = require("@babel/runtime-corejs2/core-js/symbol/iterator");

var _Array$isArray = require("@babel/runtime-corejs2/core-js/array/is-array");

var _getIterator = require("@babel/runtime-corejs2/core-js/get-iterator");

var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");

var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _map2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/map"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/assign"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/typeof"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/toConsumableArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/awaitAsyncGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/wrapAsyncGenerator"));

var _uniq2 = _interopRequireDefault(require("lodash/uniq"));

var _pick2 = _interopRequireDefault(require("lodash/pick"));

var _omit2 = _interopRequireDefault(require("lodash/omit"));

var _merge2 = _interopRequireDefault(require("lodash/merge"));

var _map3 = _interopRequireDefault(require("lodash/map"));

var _last2 = _interopRequireDefault(require("lodash/last"));

var _isString2 = _interopRequireDefault(require("lodash/isString"));

var _isObject2 = _interopRequireDefault(require("lodash/isObject"));

var _isArray2 = _interopRequireDefault(require("lodash/isArray"));

var _defaults2 = _interopRequireDefault(require("lodash/defaults"));

var _cloneDeepWith2 = _interopRequireDefault(require("lodash/cloneDeepWith"));

var _cloneDeep2 = _interopRequireDefault(require("lodash/cloneDeep"));

var _querystring = _interopRequireDefault(require("querystring"));

var _events = require("events");

var _hmacSha = _interopRequireDefault(require("crypto-js/hmac-sha256"));

var _encHex = _interopRequireDefault(require("crypto-js/enc-hex"));

var _common = require("@webex/common");

var _webexCore = require("@webex/webex-core");

var _helperImage = require("@webex/helper-image");

var _uuid = _interopRequireDefault(require("uuid"));

var _convoError = require("./convo-error");

var _shareActivity = _interopRequireDefault(require("./share-activity"));

var _activityThreadOrdering = require("./activity-thread-ordering");

var _activities = require("./activities");

var _constants = require("./constants");

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof _Symbol === "undefined" || o[_Symbol$iterator] == null) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = _getIterator(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return _Array$from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var CLUSTER_SERVICE = process.env.WEBEX_CONVERSATION_CLUSTER_SERVICE || _constants.DEFAULT_CLUSTER_SERVICE;
var DEFAULT_CLUSTER_IDENTIFIER = process.env.WEBEX_CONVERSATION_DEFAULT_CLUSTER || "".concat(_constants.DEFAULT_CLUSTER, ":").concat(CLUSTER_SERVICE);
var idToUrl = new _map2.default();

var getConvoLimit = function getConvoLimit() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var limit;

  if (options.conversationsLimit) {
    limit = {
      value: options.conversationsLimit,
      name: 'conversationsLimit'
    };
  }

  return limit;
};

var Conversation = _webexCore.WebexPlugin.extend({
  namespace: 'Conversation',

  /**
   * @param {String} cluster the cluster containing the id
   * @param {UUID} [id] the id of the conversation.
   *  If empty, just return the base URL.
   * @returns {String} url of the conversation
   */
  getUrlFromClusterId: function getUrlFromClusterId() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$cluster = _ref.cluster,
        cluster = _ref$cluster === void 0 ? 'us' : _ref$cluster,
        id = _ref.id;

    var clusterId = cluster === 'us' ? DEFAULT_CLUSTER_IDENTIFIER : cluster; // Determine if cluster has service name (non-US clusters from hydra do not)

    if (clusterId.split(':').length < 4) {
      // Add Service to cluster identifier
      clusterId = "".concat(cluster, ":").concat(CLUSTER_SERVICE);
    }

    var _ref2 = this.webex.internal.services.getServiceFromClusterId({
      clusterId: clusterId
    }) || {},
        url = _ref2.url;

    if (!url) {
      throw Error("Could not find service for cluster [".concat(cluster, "]"));
    }

    return id ? "".concat(url, "/conversations/").concat(id) : url;
  },

  /**
   * @param {Object} conversation
   * @param {Object} object
   * @param {Object} activity
   * @returns {Promise}
   */
  acknowledge: function acknowledge(conversation, object, activity) {
    var _this2 = this;

    var url = this.getConvoUrl(conversation);
    var convoWithUrl = (0, _assign.default)({}, conversation, {
      url: url
    });

    if (!(0, _isObject2.default)(object)) {
      return _promise.default.reject(new Error('`object` must be an object'));
    }

    return this.prepare(activity, {
      verb: 'acknowledge',
      target: this.prepareConversation(convoWithUrl),
      object: {
        objectType: 'activity',
        id: object.id,
        url: object.url
      }
    }).then(function (a) {
      return _this2.submit(a);
    });
  },

  /**
   * Adds a participant to a conversation
   * @param {Object} conversation
   * @param {Object|string} participant
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @returns {Promise<Activity>}
   */
  add: function add(conversation, participant, activity) {
    var _this3 = this;

    var url = this.getConvoUrl(conversation);
    var convoWithUrl = (0, _assign.default)({}, conversation, {
      url: url
    });
    return this.webex.internal.user.asUUID(participant, {
      create: true
    }).then(function (id) {
      return _this3.prepare(activity, {
        verb: 'add',
        target: _this3.prepareConversation(convoWithUrl),
        object: {
          id: id,
          objectType: 'person'
        },
        kmsMessage: {
          method: 'create',
          uri: '/authorizations',
          resourceUri: '<KRO>',
          userIds: [id]
        }
      }).then(function (a) {
        return _this3.submit(a);
      });
    });
  },

  /**
   * Creates a conversation
   * @param {Object} params
   * @param {Array<Participant>} params.participants
   * @param {Array<File>} params.files
   * @param {string} params.comment
   * @param {string} params.html
   * @param {Object} params.displayName
   * @param {string} params.classificationId
   * @param {string} params.effectiveDate
   * @param {Boolean} params.isDefaultClassification
   * @param {Array<string>} params.tags
   * @param {Boolean} params.favorite
   * @param {Object} options
   * @param {Boolean} options.allowPartialCreation
   * @param {Boolean} options.forceGrouped
   * @param {Boolean} options.skipOneOnOneFetch skips checking 1:1 exists before creating conversation
   * @returns {Promise<Conversation>}
   */
  create: function create(params) {
    var _this4 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!params.participants || params.participants.length === 0) {
      return _promise.default.reject(new Error('`params.participants` is required'));
    }

    return _promise.default.all(params.participants.map(function (participant) {
      return _this4.webex.internal.user.asUUID(participant, {
        create: true
      }) // eslint-disable-next-line arrow-body-style
      .catch(function (err) {
        return options.allowPartialCreation ? undefined : _promise.default.reject(err);
      });
    })).then(function (participants) {
      participants.unshift(_this4.webex.internal.device.userId);
      participants = (0, _uniq2.default)(participants);
      var validParticipants = participants.filter(function (participant) {
        return participant;
      });
      params.participants = validParticipants; // check if original participants list was to create a 1:1

      if (participants.length === 2 && !(options && options.forceGrouped)) {
        if (!params.participants[1]) {
          return _promise.default.reject(new _convoError.InvalidUserCreation());
        }

        if (options.skipOneOnOneFetch) {
          return _this4._createOneOnOne(params);
        }

        return _this4._maybeCreateOneOnOneThenPost(params, options);
      }

      return _this4._createGrouped(params, options);
    }).then(function (c) {
      idToUrl.set(c.id, c.url);

      if (!params.files) {
        return c;
      }

      return _this4.webex.internal.conversation.share(c, params.files).then(function (a) {
        c.activities.items.push(a);
        return c;
      });
    });
  },

  /**
   * @private
   * generate a deterministic HMAC for a reaction
   * @param {Object} displayName displayName of reaction we are sending
   * @param {Object} parent parent activity of reaction
   * @returns {Promise<HMAC>}
   */
  createReactionHmac: function createReactionHmac(displayName, parent) {
    // not using webex.internal.encryption.getKey() because the JWK it returns does not have a 'k'
    // property. we need jwk.k to correctly generate the HMAC
    return this.webex.internal.encryption.unboundedStorage.get(parent.encryptionKeyUrl).then(function (keyString) {
      var key = JSON.parse(keyString); // when we stringify this object, keys must be in this order to generate same HMAC as
      // desktop clients

      var formatjwk = {
        k: key.jwk.k,
        kid: key.jwk.kid,
        kty: key.jwk.kty
      };
      var source = "".concat((0, _stringify.default)(formatjwk)).concat(parent.id).concat(displayName);

      var hmac = _encHex.default.stringify((0, _hmacSha.default)(source, parent.id));

      return _promise.default.resolve(hmac);
    });
  },

  /**
   * @typedef {Object} ReactionPayload
   * @property {Object} actor
   * @property {string} actor.objectType
   * @property {string} actor.id
   * @property {string} objectType
   * @property {string} verb will be either add' or 'delete'
   * @property {Object} target
   * @property {string} target.id
   * @property {string} target.objectType
   * @property {Object} object this will change on delete vs. add
   * @property {string} object.id present in delete case
   * @property {string} object.objectType 'activity' in delete case, 'reaction2' in add case
   * @property {string} object.displayName must be 'celebrate', 'heart', 'thumbsup', 'smiley', 'haha', 'confused', 'sad'
   * @property {string} object.hmac
   */

  /**
   * @private
   * send add or delete reaction to convo service
   * @param {Object} conversation
   * The payload to send a reaction
   * @param {ReactionPayload} reactionPayload
   * @returns {Promise<Activity>}
   */
  sendReaction: function sendReaction(conversation, reactionPayload) {
    var _this5 = this;

    var url = this.getConvoUrl(conversation);
    var convoWithUrl = (0, _assign.default)({}, conversation, {
      url: url
    });

    if (!(0, _isObject2.default)(reactionPayload)) {
      return _promise.default.reject(new Error('`object` must be an object'));
    }

    return this.prepare(reactionPayload, {
      target: this.prepareConversation(convoWithUrl),
      object: (0, _pick2.default)(reactionPayload, 'id', 'url', 'objectType')
    }).then(function (act) {
      return _this5.submit(act);
    });
  },

  /**
   * delete a reaction
   * @param {Object} conversation
   * @param {Object} reactionId
   * @returns {Promise<Activity>}
   */
  deleteReaction: function deleteReaction(conversation, reactionId) {
    var deleteReactionPayload = {
      actor: {
        objectType: 'person',
        id: this.webex.internal.device.userId
      },
      object: {
        id: reactionId,
        objectType: 'activity'
      },
      objectType: 'activity',
      target: {
        id: conversation.id,
        objectType: 'conversation'
      },
      verb: 'delete'
    };
    return this.sendReaction(conversation, deleteReactionPayload);
  },

  /**
   * create a reaction
   * @param {Object} conversation
   * @param {Object} displayName must be 'celebrate', 'heart', 'thumbsup', 'smiley', 'haha', 'confused', 'sad'
   * @param {Object} activity activity object from convo we are reacting to
   * @returns {Promise<Activity>}
   */
  addReaction: function addReaction(conversation, displayName, activity) {
    var _this6 = this;

    return this.createReactionHmac(displayName, activity).then(function (hmac) {
      var addReactionPayload = {
        actor: {
          objectType: 'person',
          id: _this6.webex.internal.device.userId
        },
        target: {
          id: conversation.id,
          objectType: 'conversation'
        },
        verb: 'add',
        objectType: 'activity',
        parent: {
          type: 'reaction',
          id: activity.id
        },
        object: {
          objectType: 'reaction2',
          displayName: displayName,
          hmac: hmac
        }
      };
      return _this6.sendReaction(conversation, addReactionPayload);
    });
  },

  /**
   * delete content
   * @param {Object} conversation
   * @param {Object} object
   * @param {Object} activity
   * @returns {Promise}
   */
  delete: function _delete(conversation, object, activity) {
    var _this7 = this;

    var url = this.getConvoUrl(conversation);
    var convoWithUrl = (0, _assign.default)({}, conversation, {
      url: url
    });

    if (!(0, _isObject2.default)(object)) {
      return _promise.default.reject(new Error('`object` must be an object'));
    }

    return this.prepare(activity, {
      verb: 'delete',
      target: this.prepareConversation(convoWithUrl),
      object: (0, _pick2.default)(object, 'id', 'url', 'objectType')
    }).then(function (a) {
      return _this7.submit(a);
    });
  },

  /**
   * Downloads the file specified in item.scr or item.url
   * @param {Object} item
   * @param {Object} item.scr
   * @param {string} item.url
   * @param {Object} options
   * @param {Object} options.headers
   * @param {boolean} options.shouldNotAddExifData
   * @returns {Promise<File>}
   */
  download: function download(item) {
    var _this8 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var isEncrypted = Boolean(item.scr && item.scr.key);
    var shunt = new _events.EventEmitter();
    var promise;

    if (isEncrypted) {
      promise = this.webex.internal.encryption.download(item.scr, item.options);
    } else if (item.scr && item.scr.loc) {
      promise = this._downloadUnencryptedFile(item.scr.loc, options);
    } else {
      promise = this._downloadUnencryptedFile(item.url, options);
    }

    promise = promise.on('progress', function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return shunt.emit.apply(shunt, ['progress'].concat(args));
    }).then(function (res) {
      if (options.shouldNotAddExifData) {
        return res;
      }

      return (0, _helperImage.readExifData)(item, res);
    }).then(function (file) {
      _this8.logger.info('conversation: file downloaded');

      if (item.displayName && !file.name) {
        file.name = item.displayName;
      }

      if (!file.type && item.mimeType) {
        file.type = item.mimeType;
      }

      return file;
    });
    (0, _common.proxyEvents)(shunt, promise);
    return promise;
  },

  /**
   * Downloads an unencrypted file
   * @param {string} uri
   * @param {Object} options
   * @param {Ojbect} options.headers
   * @returns {Promise<File>}
   */
  _downloadUnencryptedFile: function _downloadUnencryptedFile(uri) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _assign.default)(options, {
      uri: uri,
      responseType: 'buffer'
    });
    var promise = this.request(options).then(function (res) {
      return res.body;
    });
    (0, _common.proxyEvents)(options.download, promise);
    return promise;
  },

  /**
   * Helper method that expands a set of parameters into an activty object
   * @param {string} verb
   * @param {Object} object
   * @param {Object} target
   * @param {Object|string} actor
   * @returns {Object}
   */
  expand: function expand(verb, object, target, actor) {
    var activity = {
      actor: actor,
      objectType: 'activity',
      verb: verb
    };

    if (!actor) {
      actor = this.webex.internal.device.userId;
    }

    if ((0, _isString2.default)(actor)) {
      activity.actor = {
        objectType: 'person',
        id: actor
      };
    }

    if (object) {
      activity.object = object;
    }

    if (target) {
      activity.target = target;
    }

    return activity;
  },

  /**
  * Gets an array of activities with an array of activity URLS
  * @param {Array} activityUrls
  * @param {Object} options
  * @param {String} options.cluster cluster where the activities are located
  * @param {String} options.url base convo url where the activities are located
  * @returns {Promise<Object>} Resolves with the activities
  */
  bulkActivitiesFetch: function bulkActivitiesFetch(activityUrls) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var cluster, url;

    if (typeof options === 'string') {
      cluster = options;
    } else {
      cluster = options.cluster;
      url = options.url;
    }

    var resource = 'bulk_activities_fetch';
    var params = {
      method: 'POST',
      body: {
        activityUrls: activityUrls
      }
    };

    if (url) {
      var uri = "".concat(url, "/").concat(resource);
      (0, _assign.default)(params, {
        uri: uri
      });
    } else if (cluster) {
      var _uri = "".concat(this.getUrlFromClusterId({
        cluster: cluster
      }), "/").concat(resource);

      (0, _assign.default)(params, {
        uri: _uri
      });
    } else {
      (0, _assign.default)(params, {
        api: 'conversation',
        resource: resource
      });
    }

    return this.webex.request(params).then(function (res) {
      var activitiesArr = [];

      if (res.body.multistatus) {
        res.body.multistatus.forEach(function (statusData) {
          if (statusData.status === '200' && statusData.data && statusData.data.activity) {
            activitiesArr.push(statusData.data.activity);
          }
        });
      }

      return activitiesArr;
    });
  },

  /**
   * Fetches a single conversation
   * @param {Object} conversation
   * @param {String} [conversation.url] The URL where the conversation is located.
   * @param {String|UUID} [conversation.user] The user to look up in the conversation service
   *   If specified, the user lookup will take precedence over the url lookup
   * @param {Object} options
   * @returns {Promise<Conversation>}
   */
  get: function get(conversation) {
    var _this9 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var user = conversation.user;
    var uri;

    try {
      uri = !user ? this.getConvoUrl(conversation) : '';
    } catch (err) {
      return _promise.default.reject(Error(err));
    }

    var params = {
      qs: (0, _assign.default)({
        uuidEntryFormat: true,
        personRefresh: true,
        activitiesLimit: 0,
        includeConvWithDeletedUserUUID: false,
        includeParticipants: false
      }, (0, _omit2.default)(options, 'id', 'user', 'url'))
    }; // Default behavior is to set includeParticipants=false,
    // which makes the payload lighter by removing participant info.
    // If the caller explicitly sets the participantAckFilter or
    // participantsLimit, we don't want that default setting.

    if ('participantAckFilter' in options || 'participantsLimit' in options) {
      delete params.qs.includeParticipants;
    }

    return _promise.default.resolve(user ? this.webex.internal.user.asUUID(user) : null).then(function (userId) {
      if (userId) {
        (0, _assign.default)(params, {
          service: 'conversation',
          resource: "conversations/user/".concat(userId)
        });
      } else {
        params.uri = uri;
      }

      return _this9.request(params);
    }).then((0, _common.tap)(function (_ref3) {
      var body = _ref3.body;
      var id = body.id,
          url = body.url;

      _this9._recordUUIDs(body);

      idToUrl.set(id, url);
    })).then(function (res) {
      return res.body;
    });
  },

  /**
   * Leaves the conversation or removes the specified user from the specified
   * conversation
   * @param {Object} conversation
   * @param {Object|string} participant If not specified, defaults to current
   * user
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @returns {Promise<Activity>}
   */
  leave: function leave(conversation, participant, activity) {
    var _this10 = this;

    var convoWithUrl = (0, _assign.default)({}, conversation, {
      url: this.getConvoUrl(conversation)
    });
    return _promise.default.resolve().then(function () {
      if (!participant) {
        participant = _this10.webex.internal.device.userId;
      }

      return _this10.webex.internal.user.asUUID(participant).then(function (id) {
        return _this10.prepare(activity, {
          verb: 'leave',
          target: _this10.prepareConversation(convoWithUrl),
          object: {
            id: id,
            objectType: 'person'
          },
          kmsMessage: {
            method: 'delete',
            uri: "<KRO>/authorizations?".concat(_querystring.default.stringify({
              authId: id
            }))
          }
        });
      });
    }).then(function (a) {
      return _this10.submit(a);
    });
  },

  /**
   * Lists a set of conversations. By default does not fetch activities or
   * participants
   * @param {Object} options
   * @param {boolean} options.summary - when true, use conversationSummary resource
   * @param {Number} options.conversationsLimit - limit the number of conversations fetched
   * @param {boolean} options.deferDecrypt - when true, deferDecrypt tells the
   * payload transformer to normalize (but not decrypt) each received
   * conversation. Instead, the received conversations will each have a bound
   * decrypt method that can be executed at the consumer's leisure
   * @returns {Promise<Array<Conversation>>}
   */
  list: function list() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return this._list({
      service: 'conversation',
      resource: options.summary ? 'conversationsSummary' : 'conversations',
      qs: (0, _omit2.default)(options, ['deferDecrypt', 'summary']),
      deferDecrypt: options.deferDecrypt,
      limit: getConvoLimit(options)
    }).then(function (results) {
      var _iterator = _createForOfIteratorHelper(results),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var convo = _step.value;
          idToUrl.set(convo.id, convo.url);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return results;
    });
  },

  /**
   * Paginates through a set of conversations. By default does not fetch activities or
   * participants
   * @param {Object} options
   * @param {boolean} options.deferDecrypt - when true, deferDecrypt tells the
   * payload transformer to normalize (but not decrypt) each received
   * conversation. Instead, the received conversations will each have a bound
   * decrypt method that can be executed at the consumer's leisure
   * @param {Page} options.page - After the first result has been returned to a consumer,
   * you can pass the Page back to the sdk to get the next list of results.
   * @returns {Promise<Array<Conversation>>}
   */
  paginate: function paginate() {
    var _arguments = arguments,
        _this11 = this;

    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
      var options, queryOptions, reqOptions;
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              options = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : {};

              if (!options.page) {
                _context.next = 5;
                break;
              }

              if (!(!options.page.links || !options.page.links.next)) {
                _context.next = 4;
                break;
              }

              throw new Error('No link to follow for the provided page');

            case 4:
              return _context.abrupt("return", _this11.request({
                url: options.page.links.next
              }).then(function (res) {
                return {
                  page: new _webexCore.Page(res, _this11.webex)
                };
              }));

            case 5:
              // No page - so this is the first request to kick off the pagination process
              queryOptions = (0, _assign.default)({
                personRefresh: true,
                uuidEntryFormat: true,
                activitiesLimit: 0,
                participantsLimit: 0,
                paginate: true
              }, (0, _omit2.default)(options, ['deferDecrypt', 'url']));
              reqOptions = {
                qs: queryOptions,
                deferDecrypt: options.deferDecrypt,
                limit: getConvoLimit(options)
              }; // if options.url is present we likely received one or more additional urls due to federation. In this case
              // we need to initialize pagination against that url instead of the default home cluster

              if (options.url) {
                reqOptions.uri = "".concat(options.url, "/conversations");
              } else {
                reqOptions.service = 'conversation';
                reqOptions.resource = 'conversations';
              }

              return _context.abrupt("return", _this11.request(reqOptions).then(function (res) {
                var response = {
                  page: new _webexCore.Page(res, _this11.webex)
                };

                if (res.body && res.body.additionalUrls) {
                  response.additionalUrls = res.body.additionalUrls;
                }

                return response;
              }));

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  },

  /**
   * Lists the conversations the current user has left. By default does not
   * fetch activities or participants
   * @param {Object} options
   * @returns {Promise<Array<Conversation>>}
   */
  listLeft: function listLeft(options) {
    return this._list({
      service: 'conversation',
      resource: 'conversations/left',
      qs: options,
      limit: getConvoLimit(options)
    }).then(function (results) {
      var _iterator2 = _createForOfIteratorHelper(results),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var convo = _step2.value;
          idToUrl.set(convo.id, convo.url);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return results;
    });
  },

  /**
   * List activities for the specified conversation
   * @param {Object} options
   * @param {String} options.conversationUrl URL to the conversation
   * @returns {Promise<Array<Activity>>}
   */
  listActivities: function listActivities(options) {
    return this._listActivities((0, _assign.default)(options, {
      resource: 'activities'
    }));
  },

  /**
   * @typedef QueryOptions
   * @param {number} [limit] The limit of child activities that can be returned per request
   * @param {boolean} [latestActivityFirst] Sort order for the child activities
   * @param {boolean} [includeParentActivity] Enables the parent activity to be returned in the activity list
   * @param {string} [sinceDate] Get all child activities after this date
   * @param {string} [maxDate] Get all child activities before this date
   * @param {boolean} [latestActivityFirst] Sort order for the child activities
   * @param {string} [activityType] The type of children to return the parents of, a null value here returns parents of all types of children.
   * The value is one of 'reply', 'edit', 'cardAction', 'reaction', 'reactionSummary', 'reactionSelfSummary'
   */

  /**
   * Get all parent ids for a conversation.
   * @param {string} conversationUrl conversation URL.
   * @param {QueryOptions} [query] object containing query string values to be appended to the url
   * @returns {Promise<Array<String>>}
   */
  listParentActivityIds: function listParentActivityIds(conversationUrl, query) {
    var _this12 = this;

    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
      var params, response;
      return _regenerator.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              params = {
                method: 'GET',
                url: "".concat(conversationUrl, "/parents"),
                qs: query
              };
              _context2.next = 3;
              return _this12.request(params);

            case 3:
              response = _context2.sent;
              return _context2.abrupt("return", response.body);

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }))();
  },

  /**
   * Returns a list of _all_ child activities for a given parentId within a given conversation
   * @param {object} [options = {}]
   * @param {string} [options.conversationUrl] targeted conversation URL
   * @param {string} [options.activityParentId] parent id of edit activities or thread activities
   * @param {QueryOptions} [options.query] object containing query string values to be appended to the url
   * @returns {Promise<Array>}
   */
  listAllChildActivitiesByParentId: function listAllChildActivitiesByParentId() {
    var _arguments2 = arguments,
        _this13 = this;

    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
      var options, conversationUrl, activityParentId, query, activityType, initialResponse, page, items, _iterator3, _step3, activity;

      return _regenerator.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              options = _arguments2.length > 0 && _arguments2[0] !== undefined ? _arguments2[0] : {};
              conversationUrl = options.conversationUrl, activityParentId = options.activityParentId, query = options.query;
              activityType = query.activityType;
              _context3.next = 5;
              return _this13.listChildActivitiesByParentId(conversationUrl, activityParentId, activityType, query);

            case 5:
              initialResponse = _context3.sent;
              page = new _webexCore.Page(initialResponse, _this13.webex);
              items = (0, _toConsumableArray2.default)(page.items);

            case 8:
              if (!page.hasNext()) {
                _context3.next = 16;
                break;
              }

              _context3.next = 11;
              return page.next();

            case 11:
              page = _context3.sent;
              _iterator3 = _createForOfIteratorHelper(page);

              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  activity = _step3.value;
                  items.push(activity);
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }

              _context3.next = 8;
              break;

            case 16:
              // reverse list if needed (see _list for precedent)
              if (items.length && (0, _last2.default)(items).published < items[0].published) {
                items.reverse();
              }

              return _context3.abrupt("return", items);

            case 18:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }))();
  },

  /**
   * Return a list of child activities with a given conversation, parentId and other constraints.
   * @param {string} conversationUrl targeted conversation URL
   * @param {string} activityParentId parent id of edit activities or thread activities
   * @param {string} activityType type of child activity to return
   * The value is one of 'reply', 'edit', 'cardAction', 'reaction', 'reactionSummary', 'reactionSelfSummary'
   * @param {QueryOptions} [query = {}] object containing query string values to be appended to the url
   * @returns {Promise<Array>}
   */
  listChildActivitiesByParentId: function listChildActivitiesByParentId(conversationUrl, activityParentId, activityType) {
    var _arguments3 = arguments,
        _this14 = this;

    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {
      var query, finalQuery, params;
      return _regenerator.default.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              query = _arguments3.length > 3 && _arguments3[3] !== undefined ? _arguments3[3] : {};
              finalQuery = _objectSpread(_objectSpread({}, query), {}, {
                activityType: activityType
              });
              params = {
                method: 'GET',
                url: "".concat(conversationUrl, "/parents/").concat(activityParentId),
                qs: finalQuery
              };
              return _context4.abrupt("return", _this14.request(params));

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }))();
  },

  /**
   * Return an array of reactionSummary and reactionSelfSummary objects
   * @param {string} conversationUrl targeted conversation URL
   * @param {string} activityParentId parent id of reaction activities
   * @param {QueryOptions} query object representing query parameters to pass to convo endpoint
   * @returns {Promise<Array>}
   */
  getReactionSummaryByParentId: function getReactionSummaryByParentId(conversationUrl, activityParentId, query) {
    var _this15 = this;

    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {
      var _yield$_this15$reques, body, reactionObjects;

      return _regenerator.default.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return _this15.request({
                method: 'GET',
                url: "".concat(conversationUrl, "/activities/").concat(activityParentId),
                qs: query
              });

            case 2:
              _yield$_this15$reques = _context5.sent;
              body = _yield$_this15$reques.body;
              reactionObjects = body.children ? body.children.filter(function (child) {
                return child.type === 'reactionSelfSummary' || child.type === 'reactionSummary';
              }) : [];
              return _context5.abrupt("return", reactionObjects);

            case 6:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }))();
  },

  /**
   * Lists activities in which the current user was mentioned
   * @param {Object} options
   * @returns {Promise<Array<Activity>>}
   */
  listMentions: function listMentions(options) {
    return this._list({
      service: 'conversation',
      resource: 'mentions',
      qs: (0, _omit2.default)(options, 'mentions')
    });
  },

  /**
   * Mutes the mentions of a conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  muteMentions: function muteMentions(conversation, activity) {
    return this.tag(conversation, {
      tags: ['MENTION_NOTIFICATIONS_OFF']
    }, activity);
  },

  /**
   * Mutes the messages of a conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  muteMessages: function muteMessages(conversation, activity) {
    return this.tag(conversation, {
      tags: ['MESSAGE_NOTIFICATIONS_OFF']
    }, activity);
  },

  /**
   * Starts ignoring conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  ignore: function ignore(conversation, activity) {
    return this.tag(conversation, {
      tags: ['IGNORED']
    }, activity);
  },

  /**
   * @param {Object} conversation
   * @param {Object} inputs
   * @param {Object} parentActivity
   * @param {Object} activity
   * @returns {Promise}
   */
  cardAction: function cardAction(conversation, inputs, parentActivity) {
    var _this16 = this;

    var activity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var convoWithUrl = (0, _assign.default)({}, conversation, {
      url: this.getConvoUrl(conversation)
    });
    activity.parent = {
      id: parentActivity.id,
      type: 'cardAction'
    };
    return this.prepare(activity, {
      verb: 'cardAction',
      target: this.prepareConversation(convoWithUrl),
      object: (0, _assign.default)({
        objectType: 'submit'
      }, inputs)
    }).then(function (a) {
      return _this16.submit(a);
    });
  },

  /**
   * Posts a message to a conversation
   * @param {Object} conversation
   * @param {Object|string} message if string, treated as plaintext; if object,
   * assumed to be object property of `post` activity
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @returns {Promise<Activity>}
   */
  post: function post(conversation, message, activity) {
    var _this17 = this;

    var convoWithUrl = (0, _assign.default)({}, conversation, {
      url: this.getConvoUrl(conversation)
    });

    if ((0, _isString2.default)(message)) {
      message = {
        displayName: message
      };
    }

    return this.prepare(activity, {
      verb: 'post',
      target: this.prepareConversation(convoWithUrl),
      object: (0, _assign.default)({
        objectType: 'comment'
      }, message)
    }).then(function (a) {
      return _this17.submit(a);
    });
  },
  prepareConversation: function prepareConversation(conversation) {
    return (0, _defaults2.default)((0, _pick2.default)(conversation, 'id', 'url', 'objectType', 'defaultActivityEncryptionKeyUrl', 'kmsResourceObjectUrl'), {
      objectType: 'conversation'
    });
  },
  prepare: function prepare(activity, params) {
    var _this18 = this;

    params = params || {};
    activity = activity || {};
    return _promise.default.resolve(activity.prepare ? activity.prepare(params) : activity).then(function (act) {
      (0, _defaults2.default)(act, {
        verb: params.verb,
        kmsMessage: params.kmsMessage,
        objectType: 'activity',
        clientTempId: _uuid.default.v4(),
        actor: _this18.webex.internal.device.userId
      }); // Workaround because parent is a reserved props in Ampersand

      if (activity.parentActivityId && activity.activityType || activity.parent && activity.parent.id && activity.parent.type) {
        act.parent = {
          id: activity.parentActivityId || activity.parent.id,
          type: activity.activityType || activity.parent.type
        };
      }

      if ((0, _isString2.default)(act.actor)) {
        act.actor = {
          objectType: 'person',
          id: act.actor
        };
      }

      ['actor', 'object'].forEach(function (key) {
        if (params[key]) {
          act[key] = act[key] || {};
          (0, _defaults2.default)(act[key], params[key]);
        }
      });

      if (params.target) {
        (0, _merge2.default)(act, {
          target: (0, _pick2.default)(params.target, 'id', 'url', 'objectType', 'kmsResourceObjectUrl', 'defaultActivityEncryptionKeyUrl')
        });
      }

      ['object', 'target'].forEach(function (key) {
        if (act[key] && act[key].url && !act[key].id) {
          act[key].id = act[key].url.split('/').pop();
        }
      });
      ['actor', 'object', 'target'].forEach(function (key) {
        if (act[key] && !act[key].objectType) {
          // Reminder: throwing here because it's the only way to get out of
          // this loop in event of an error.
          throw new Error("`act.".concat(key, ".objectType` must be defined"));
        }
      });

      if (act.object && act.object.content && !act.object.displayName) {
        return _promise.default.reject(new Error('Cannot submit activity object with `content` but no `displayName`'));
      }

      return act;
    });
  },

  /**
  * Get a subset of threads for a user.
  * @param {Object} options
  * @returns {Promise<Array<Activity>>}
  */
  listThreads: function listThreads(options) {
    var _this19 = this;

    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6() {
      return _regenerator.default.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              return _context6.abrupt("return", _this19._list({
                service: 'conversation',
                resource: 'threads',
                qs: (0, _omit2.default)(options, 'showAllTypes')
              }));

            case 1:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }))();
  },

  /**
   * Handles incoming conversation.activity mercury messages
   * @param {Event} event
   * @returns {Promise}
   */
  processActivityEvent: function processActivityEvent(event) {
    return this.webex.transform('inbound', event).then(function () {
      return event;
    });
  },

  /**
   * Removes all mute-related tags
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  removeAllMuteTags: function removeAllMuteTags(conversation, activity) {
    return this.untag(conversation, {
      tags: ['MENTION_NOTIFICATIONS_OFF', 'MENTION_NOTIFICATIONS_ON', 'MESSAGE_NOTIFICATIONS_OFF', 'MESSAGE_NOTIFICATIONS_ON']
    }, activity);
  },

  /**
   * Creates a ShareActivty for the specified conversation
   * @param {Object} conversation
   * @param {Object} activity
   * @returns {ShareActivty}
   */
  makeShare: function makeShare(conversation, activity) {
    // if we pass activity as null then it does not take care of the
    // clientTempId created by the web-client while making the provisional
    // activity, hence we need to pass the activity which was created by the
    // web-client. This fixes the issue where the image activities do not come
    // back properly oriented from the server since the clientTempId is missing
    return _shareActivity.default.create(conversation, activity, this.webex);
  },

  /**
   * Assigns an avatar to a room
   * @param {Object} conversation
   * @param {File} avatar
   * @returns {Promise<Activity>}
   */
  assign: function assign(conversation, avatar) {
    var _this20 = this;

    if ((avatar.size || avatar.length) > 1024 * 1024) {
      return _promise.default.reject(new Error('Room avatars must be less than 1MB'));
    }

    var convoWithUrl = (0, _assign.default)({}, conversation, {
      url: this.getConvoUrl(conversation)
    });
    return _promise.default.resolve().then(function () {
      var activity = _shareActivity.default.create(conversation, null, _this20.webex);

      activity.enableThumbnails = false;
      activity.add(avatar);
      return _this20.prepare(activity, {
        target: _this20.prepareConversation(convoWithUrl)
      });
    }).then(function (a) {
      // yes, this seems a little hacky; will likely be resolved as a result
      // of #213
      a.verb = 'assign';
      return _this20.submit(a);
    });
  },

  /**
   * Get url from convo object. If there isn't one, get it from the cache
   *
   * @param {String} url The location of the conversation
   * @param {UUID} id If there is no url, fall back to id to lookup in cache or with cluster
   * @param {String} cluster Used with id to lookup url
   * @param {UUID} generalConversationUuid If this is a team, the id of the general conversation
   * @param {Object} conversations If this is a team, the list of conversations in the team
   * @returns {String} url for the specific convo
   */
  getConvoUrl: function getConvoUrl(_ref4) {
    var id = _ref4.id,
        url = _ref4.url,
        cluster = _ref4.cluster,
        conversations = _ref4.conversations,
        generalConversationUuid = _ref4.generalConversationUuid;

    if (generalConversationUuid) {
      // This is a Team
      // Because Convo doesn't have an endpoint for the team URL
      // we have to use the general convo URL.
      var generalConvo = conversations.items.find(function (convo) {
        return convo.id === generalConversationUuid;
      });
      return generalConvo.url;
    }

    if (url) {
      return url;
    }

    if (id) {
      if (cluster) {
        return this.getUrlFromClusterId({
          cluster: cluster,
          id: id
        });
      }

      this.logger.warn('You should be using the `url` instead of the `id` property');
      var relatedUrl = idToUrl.get(id);

      if (!relatedUrl) {
        throw Error('Could not find the `url` from the given `id`');
      }

      return relatedUrl;
    }

    throw Error('The space needs a `url` property');
  },

  /**
   * Sets the typing status of the current user in a conversation
   *
   * @param {Object} conversation
   * @param {Object} options
   * @param {boolean} options.typing
   * @returns {Promise}
   */
  updateTypingStatus: function updateTypingStatus(conversation, options) {
    if (!conversation.id) {
      if (conversation.url) {
        conversation.id = conversation.url.split('/').pop();
      } else {
        return _promise.default.reject(new Error('conversation: could not identify conversation'));
      }
    }

    var eventType;

    if (options.typing) {
      eventType = 'status.start_typing';
    } else {
      eventType = 'status.stop_typing';
    }

    var url = this.getConvoUrl(conversation);
    var resource = 'status/typing';
    var params = {
      method: 'POST',
      body: {
        conversationId: conversation.id,
        eventType: eventType
      },
      url: "".concat(url, "/").concat(resource)
    };
    return this.request(params);
  },

  /**
   * Shares files to the specified conversation
   * @param {Object} conversation
   * @param {ShareActivity|Array<File>} activity
   * @returns {Promise<Activity>}
   */
  share: function share(conversation, activity) {
    var _this21 = this;

    if ((0, _isArray2.default)(activity)) {
      activity = {
        object: {
          files: activity
        }
      };
    }

    var convoWithUrl = (0, _assign.default)({}, conversation, {
      url: this.getConvoUrl(conversation)
    });

    if (!(activity instanceof _shareActivity.default)) {
      activity = _shareActivity.default.create(convoWithUrl, activity, this.webex);
    }

    return this.prepare(activity, {
      target: this.prepareConversation(convoWithUrl)
    }).then(function (a) {
      return _this21.submit(a);
    });
  },

  /**
   * Submits an activity to the conversation service
   * @param {Object} activity
   * @param {String} [endpoint] endpoint to submit activity. If empty, find in activity
   * @returns {Promise<Activity>}
   */
  submit: function submit(activity, endpoint) {
    var _this22 = this;

    var url = endpoint || this.getConvoUrl(activity.target);
    var resource = activity.verb === 'share' ? 'content' : 'activities';
    var params = {
      method: 'POST',
      body: activity,
      qs: {
        personRefresh: true
      },
      url: "".concat(url, "/").concat(resource)
    };

    if (activity.verb === 'share') {
      (0, _assign.default)(params.qs, {
        transcode: true,
        async: false
      });
    }
    /**
     * helper to cloneDeepWith for copying instance function
     * @param {Object|String|Symbol|Array|Date} value (recursive value to clone from params)
     * @returns {Object|null}
     */
    // eslint-disable-next-line consistent-return


    var customActivityCopy = function customActivityCopy(value) {
      var files = params.body.object.files;

      if (files && value && files.items.length > 0 && value.constructor === files.items[0].scr.constructor) {
        var copySrc = (0, _cloneDeep2.default)(value);
        copySrc.toJWE = value.toJWE;
        copySrc.toJSON = value.toJSON;
        return copySrc;
      }
    };

    var cloneActivity = (0, _cloneDeepWith2.default)(params, customActivityCopy); // triggers user-activity to reset logout timer

    this.webex.trigger('user-activity');
    return this.request(params).then(function (res) {
      return res.body;
    }).catch(function (error) {
      // handle when key need to rotate
      if (error.body && error.body.errorCode === _constants.KEY_ROTATION_REQUIRED) {
        cloneActivity.body.target.defaultActivityEncryptionKeyUrl = null;

        _this22.request(cloneActivity);
      } else if (error.body && (error.body.errorCode === _constants.KEY_ALREADY_ROTATED || error.body.errorCode === _constants.ENCRYPTION_KEY_URL_MISMATCH)) {
        // handle when key need to update
        _this22.webex.request({
          method: 'GET',
          api: 'conversation',
          resource: "conversations/".concat(params.body.target.id)
        }).then(function (res) {
          cloneActivity.body.target.defaultActivityEncryptionKeyUrl = res.body.defaultActivityEncryptionkeyUrl;

          _this22.request(cloneActivity);
        });
      } else {
        throw error;
      }
    });
  },

  /**
   * Remove the avatar from a room
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise}
   */
  unassign: function unassign(conversation, activity) {
    var _this23 = this;

    var convoWithUrl = (0, _assign.default)({}, conversation, {
      url: this.getConvoUrl(conversation)
    });
    return this.prepare(activity, {
      verb: 'unassign',
      target: this.prepareConversation(convoWithUrl),
      object: {
        objectType: 'content',
        files: {
          items: []
        }
      }
    }).then(function (a) {
      return _this23.submit(a);
    });
  },

  /**
   * Mutes the mentions of a conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  unmuteMentions: function unmuteMentions(conversation, activity) {
    return this.tag(conversation, {
      tags: ['MENTION_NOTIFICATIONS_ON']
    }, activity);
  },

  /**
   * Mutes the messages of a conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  unmuteMessages: function unmuteMessages(conversation, activity) {
    return this.tag(conversation, {
      tags: ['MESSAGE_NOTIFICATIONS_ON']
    }, activity);
  },

  /**
   * Stops ignoring conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  unignore: function unignore(conversation, activity) {
    return this.untag(conversation, {
      tags: ['IGNORED']
    }, activity);
  },

  /**
   * Update an existing activity
   * @param {Object} conversation
   * @param {Object} object
   * @param {Object} activity
   * @returns {Promise}
   */
  update: function update(conversation, object, activity) {
    var _this24 = this;

    if (!(0, _isObject2.default)(object)) {
      return _promise.default.reject(new Error('`object` must be an object'));
    }

    var convoWithUrl = (0, _assign.default)({}, conversation, {
      url: this.getConvoUrl(conversation)
    });
    return this.prepare(activity, {
      verb: 'update',
      target: this.prepareConversation(convoWithUrl),
      object: object
    }).then(function (a) {
      return _this24.submit(a);
    });
  },

  /**
   * Sets a new key for the conversation
   * @param {Object} conversation
   * @param {Key|string} key (optional)
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @returns {Promise<Activity>}
   */
  updateKey: function updateKey(conversation, key, activity) {
    var _this25 = this;

    var convoWithUrl = (0, _assign.default)({}, conversation, {
      url: this.getConvoUrl(conversation)
    });
    return this.get(convoWithUrl, {
      activitiesLimit: 0,
      includeParticipants: true
    }).then(function (c) {
      return _this25._updateKey(c, key, activity);
    });
  },

  /**
   * Sets a new key for the conversation
   * @param {Object} conversation
   * @param {Key|string} key (optional)
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @private
   * @returns {Promise<Activity>}
   */
  _updateKey: function _updateKey(conversation, key, activity) {
    var _this26 = this;

    var convoWithUrl = (0, _assign.default)({}, conversation, {
      url: this.getConvoUrl(conversation)
    });
    return _promise.default.resolve(key || this.webex.internal.encryption.kms.createUnboundKeys({
      count: 1
    })).then(function (keys) {
      var k = (0, _isArray2.default)(keys) ? keys[0] : keys;
      var params = {
        verb: 'updateKey',
        target: _this26.prepareConversation(convoWithUrl),
        object: {
          defaultActivityEncryptionKeyUrl: k.uri,
          objectType: 'conversation'
        }
      }; // Reminder: the kmsResourceObjectUrl is only usable if there is
      // defaultActivityEncryptionKeyUrl.
      // Valid defaultActivityEncryptionKeyUrl start with 'kms:'

      if (convoWithUrl.kmsResourceObjectUrl && convoWithUrl.kmsResourceObjectUrl.startsWith('kms:')) {
        params.kmsMessage = {
          method: 'update',
          resourceUri: '<KRO>',
          uri: k.uri
        };
      } else {
        params.kmsMessage = {
          method: 'create',
          uri: '/resources',
          userIds: (0, _map3.default)(convoWithUrl.participants.items, 'id'),
          keyUris: [k.uri]
        };
      }

      return _this26.prepare(activity, params).then(function (a) {
        return _this26.submit(a);
      });
    });
  },

  /**
   * @param {Object} payload
   * @param {Object} options
   * @private
   * @returns {Promise<Activity>}
   */
  _create: function _create(payload) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this.request({
      method: 'POST',
      service: 'conversation',
      resource: 'conversations',
      body: payload,
      qs: {
        forceCreate: options.allowPartialCreation
      }
    }).then(function (res) {
      return res.body;
    });
  },

  /**
   * @param {Object} params
   * @param {Object} options
   * @private
   * @returns {Promise}
   */
  _createGrouped: function _createGrouped(params, options) {
    return this._create(this._prepareConversationForCreation(params), options);
  },

  /**
   * @param {Object} params
   * @param {Object} options
   * @private
   * @returns {Promise}
   */
  _createOneOnOne: function _createOneOnOne(params) {
    var payload = this._prepareConversationForCreation(params);

    payload.tags = ['ONE_ON_ONE'];
    return this._create(payload);
  },

  /**
   * Get the current conversation url.
   *
   * @returns {Promise<string>} - conversation url
   */
  getConversationUrl: function getConversationUrl() {
    var _this27 = this;

    this.logger.info('conversation: getting the conversation service url');
    var convoUrl = this.webex.internal.services.get('conversation'); // Validate if the conversation url exists in the services plugin and
    // resolve with its value.

    if (convoUrl) {
      return _promise.default.resolve(convoUrl);
    } // Wait for the postauth catalog to update and then try to retrieve the
    // conversation service url again.


    return this.webex.internal.waitForCatalog('postauth').then(function () {
      return _this27.webex.internal.services.get('conversation');
    }).catch(function (error) {
      _this27.logger.warn('conversation: unable to get conversation url', error.message);

      return _promise.default.reject(error);
    });
  },

  /**
   * @param {Object} conversation
   * @private
   * @returns {Promise}
   */
  _inferConversationUrl: function _inferConversationUrl(conversation) {
    var _this28 = this;

    if (conversation.id) {
      return this.webex.internal.feature.getFeature('developer', 'web-high-availability').then(function (haMessagingEnabled) {
        if (haMessagingEnabled) {
          // recompute conversation URL each time as the host may have changed
          // since last usage
          return _this28.getConversationUrl().then(function (url) {
            conversation.url = "".concat(url, "/conversations/").concat(conversation.id);
            return conversation;
          });
        }

        if (!conversation.url) {
          return _this28.getConversationUrl().then(function (url) {
            conversation.url = "".concat(url, "/conversations/").concat(conversation.id);
            /* istanbul ignore else */

            if (process.env.NODE_ENV !== 'production') {
              _this28.logger.warn('conversation: inferred conversation url from conversation id; please pass whole conversation objects to Conversation methods');
            }

            return conversation;
          });
        }

        return _promise.default.resolve(conversation);
      });
    }

    return _promise.default.resolve(conversation);
  },

  /**
   * @param {Object} options
   * @param {String} options.conversationUrl URL to the conversation
   * @param {String} options.resource The URL resource to hit for a list of objects
   * @private
   * @returns {Promise<Array<Activity>>}
   */
  _listActivities: function _listActivities(options) {
    var id = options.conversationId;
    var url = this.getConvoUrl({
      url: options.conversationUrl,
      id: id
    });
    var resource = options.resource;
    return this._list({
      qs: (0, _omit2.default)(options, 'resource'),
      url: "".concat(url, "/").concat(resource)
    });
  },

  /**
   * common interface for facade of generator functions
   * @typedef {object} IGeneratorResponse
   * @param {boolean} done whether there is more to fetch
   * @param {any} value the value yielded or returned by generator
   */

  /**
   * @param {object} options
   * @param {string} options.conversationId
   * @param {string} options.conversationUrl,
   * @param {boolean} options.includeChildren, If set to true, parent activities will be enhanced with child objects
   * @param {number} options.minActivities how many activities to return in first batch
   * @param {?string} [options.queryType] one of older, newer, mid. defines which direction to fetch
   * @param {?object} [options.search] server activity to use as search middle date
   *
   * @returns {object}
   * returns three functions:
   *
   * getOlder - gets older activities than oldest fetched
   *
   * getNewer - gets newer activities than newest fetched
   *
   * jumpToActivity - gets searched-for activity and surrounding activities
   */
  listActivitiesThreadOrdered: function listActivitiesThreadOrdered(options) {
    var _this29 = this;

    var conversationUrl = options.conversationUrl,
        conversationId = options.conversationId;

    if (!conversationUrl && !conversationId) {
      throw new Error('must provide a conversation URL or conversation ID');
    }

    var url = this.getConvoUrl({
      url: conversationUrl,
      id: conversationId
    });

    var baseOptions = _objectSpread(_objectSpread({}, (0, _omit2.default)(options, ['conversationUrl', 'conversationId'])), {}, {
      url: url
    });

    var olderOptions = _objectSpread(_objectSpread({}, baseOptions), {}, {
      queryType: _activities.OLDER
    });

    var threadOrderer = this._listActivitiesThreadOrdered(baseOptions);
    /**
     * gets queried activity and surrounding activities
     * calling this function creates a new generator instance, losing the previous instance's internal state
     * this ensures that jumping to older and newer activities is relative to a single set of timestamps, not many
     * @param {object} searchObject activity object from convo
     * @returns {IGeneratorResponse}
     */


    var jumpToActivity = /*#__PURE__*/function () {
      var _ref5 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7(searchObject) {
        var newUrl, searchOptions, _yield$threadOrderer$, searchResults;

        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (searchObject) {
                  _context7.next = 2;
                  break;
                }

                throw new Error('Search must be an activity object from conversation service');

              case 2:
                newUrl = searchObject.target && searchObject.target.url;

                if (newUrl) {
                  _context7.next = 5;
                  break;
                }

                throw new Error('Search object must have a target url!');

              case 5:
                searchOptions = _objectSpread(_objectSpread({}, baseOptions), {}, {
                  url: newUrl,
                  queryType: _activities.MID,
                  search: searchObject
                });
                threadOrderer = _this29._listActivitiesThreadOrdered(searchOptions);
                _context7.next = 9;
                return threadOrderer.next(searchOptions);

              case 9:
                _yield$threadOrderer$ = _context7.sent;
                searchResults = _yield$threadOrderer$.value;
                return _context7.abrupt("return", {
                  done: true,
                  value: searchResults
                });

              case 12:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      return function jumpToActivity(_x) {
        return _ref5.apply(this, arguments);
      };
    }();
    /**
     * gets older activities than oldest fetched
     * @returns {IGeneratorResponse}
     */


    var getOlder = /*#__PURE__*/function () {
      var _ref6 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8() {
        var _yield$threadOrderer$2, _yield$threadOrderer$3, value, oldestInBatch, moreActivitiesExist;

        return _regenerator.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return threadOrderer.next(olderOptions);

              case 2:
                _yield$threadOrderer$2 = _context8.sent;
                _yield$threadOrderer$3 = _yield$threadOrderer$2.value;
                value = _yield$threadOrderer$3 === void 0 ? [] : _yield$threadOrderer$3;
                oldestInBatch = value[0] && value[0].activity;
                moreActivitiesExist = oldestInBatch && (0, _activities.getActivityType)(oldestInBatch) !== _activities.ACTIVITY_TYPES.CREATE;
                return _context8.abrupt("return", {
                  done: !moreActivitiesExist,
                  value: value
                });

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }));

      return function getOlder() {
        return _ref6.apply(this, arguments);
      };
    }();
    /**
     * gets newer activities than newest fetched
     * @returns {IGeneratorResponse}
     */


    var getNewer = /*#__PURE__*/function () {
      var _ref7 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9() {
        var newerOptions, _yield$threadOrderer$4, value;

        return _regenerator.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                newerOptions = _objectSpread(_objectSpread({}, baseOptions), {}, {
                  queryType: _activities.NEWER
                });
                _context9.next = 3;
                return threadOrderer.next(newerOptions);

              case 3:
                _yield$threadOrderer$4 = _context9.sent;
                value = _yield$threadOrderer$4.value;
                return _context9.abrupt("return", {
                  done: !value.length,
                  value: value
                });

              case 6:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));

      return function getNewer() {
        return _ref7.apply(this, arguments);
      };
    }();

    return {
      jumpToActivity: jumpToActivity,
      getNewer: getNewer,
      getOlder: getOlder
    };
  },

  /**
    * Represents reactions to messages
    * @typedef {object} Reaction
    * @property {object} activity reaction2summary server activity object
    */

  /**
   * Represents a root (parent, with or without children) activity, along with any replies and reactions
   * @typedef {object} Activity
   * @property {object} activity server activity object
   * @property {Reaction} reactions
   * @property {Reaction} reactionSelf
   */

  /**
   * @generator
   * @method
   * @async
   * @private
   * @param {object} options
   * @param {string} options.url
   * @param {boolean} options.includeChildren, If set to true, parent activities will be enhanced with child objects
   * @param {string} [options.minActivities] how many activities to return in first batch
   * @param {string} [options.queryType] one of older, newer, mid. defines which direction to fetch
   * @param {object} [options.search] server activity to use as search middle date
   *
   * @yields {Activity[]}
   *
   * @returns {void}
   */
  _listActivitiesThreadOrdered: function _listActivitiesThreadOrdered() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return (0, _wrapAsyncGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee10() {
      var _options$minActivitie, minActivities, _options$queryType, queryType, convoUrl, _options$search, search, includeChildren, _bookendManager, setBookends, getNewestAct, getOldestAct, defaultBatchSize, batchSize, _activityManager, getActivityHandlerByKey, getActivityByTypeAndParentId, query, _loop, _ret;

      return _regenerator.default.wrap(function _callee10$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              // ***********************************************
              // INSTANCE STATE VARIABLES
              // variables that will be used for the life of the generator
              // ***********************************************
              _options$minActivitie = options.minActivities, minActivities = _options$minActivitie === void 0 ? _activityThreadOrdering.defaultMinDisplayableActivities : _options$minActivitie, _options$queryType = options.queryType, queryType = _options$queryType === void 0 ? _activities.INITIAL : _options$queryType; // must fetch initially before getting newer activities!

              if (queryType === _activities.NEWER) {
                queryType = _activities.INITIAL;
              }

              convoUrl = options.url, _options$search = options.search, search = _options$search === void 0 ? {} : _options$search, includeChildren = options.includeChildren; // manage oldest, newest activities (ie bookends)

              _bookendManager = (0, _activityThreadOrdering.bookendManager)(), setBookends = _bookendManager.setBookends, getNewestAct = _bookendManager.getNewestAct, getOldestAct = _bookendManager.getOldestAct; // default batch should be equal to minActivities when fetching back in time, but halved when fetching newer due to subsequent child fetches filling up the minActivities count
              // reduces server RTs when fetching older activities

              defaultBatchSize = queryType === _activities.INITIAL || queryType === _activities.OLDER ? minActivities : Math.max(_activityThreadOrdering.minBatchSize, Math.ceil(minActivities / 2));
              batchSize = defaultBatchSize; // exposes activity states and handlers with simple getters

              _activityManager = (0, _activityThreadOrdering.activityManager)(), getActivityHandlerByKey = _activityManager.getActivityHandlerByKey, getActivityByTypeAndParentId = _activityManager.getActivityByTypeAndParentId; // set initial query

              query = (0, _activityThreadOrdering.getQuery)(queryType, {
                activityToSearch: search,
                batchSize: batchSize
              });
              /* eslint-disable no-await-in-loop */

              /* eslint-disable no-loop-func */

              _loop = /*#__PURE__*/_regenerator.default.mark(function _loop() {
                var _rootActivityManager, getRootActivityHash, addNewRoot, _noMoreActivitiesMana, getNoMoreActs, checkAndSetNoMoreActs, checkAndSetNoOlderActs, checkAndSetNoNewerActs, getActivityHandlerByType, handleNewActivity, handleNewActivities, handleOlderQuery, handleNewerQuery, handleSearch, getQueryResponseHandler, incrementLoopCounter, _loop2, _ret2, orderedActivities, getRepliesByParentId, orderedRoots, nextOptions, currentOldestPublishedDate, currentNewestPublishedDate;

                return _regenerator.default.wrap(function _loop$(_context11) {
                  while (1) {
                    switch (_context11.prev = _context11.next) {
                      case 0:
                        // ***********************************************
                        // EXECUTION STATE VARIABLES
                        // variables that will be used for each "batch" of activities asked for
                        // ***********************************************
                        // stores all "root" activities (activities that are, or could be, thread parents)
                        _rootActivityManager = (0, _activityThreadOrdering.rootActivityManager)(), getRootActivityHash = _rootActivityManager.getRootActivityHash, addNewRoot = _rootActivityManager.addNewRoot; // used to determine if we should continue to fetch older activities
                        // must be set per iteration, as querying newer activities is still valid when all end of convo has been reached

                        _noMoreActivitiesMana = (0, _activityThreadOrdering.noMoreActivitiesManager)(), getNoMoreActs = _noMoreActivitiesMana.getNoMoreActs, checkAndSetNoMoreActs = _noMoreActivitiesMana.checkAndSetNoMoreActs, checkAndSetNoOlderActs = _noMoreActivitiesMana.checkAndSetNoOlderActs, checkAndSetNoNewerActs = _noMoreActivitiesMana.checkAndSetNoNewerActs;

                        getActivityHandlerByType = function getActivityHandlerByType(type) {
                          var _ACTIVITY_TYPES$ROOT$;

                          return (_ACTIVITY_TYPES$ROOT$ = {}, (0, _defineProperty2.default)(_ACTIVITY_TYPES$ROOT$, _activities.ACTIVITY_TYPES.ROOT, addNewRoot), (0, _defineProperty2.default)(_ACTIVITY_TYPES$ROOT$, _activities.ACTIVITY_TYPES.REPLY, getActivityHandlerByKey(_activities.ACTIVITY_TYPES.REPLY)), (0, _defineProperty2.default)(_ACTIVITY_TYPES$ROOT$, _activities.ACTIVITY_TYPES.EDIT, getActivityHandlerByKey(_activities.ACTIVITY_TYPES.EDIT)), (0, _defineProperty2.default)(_ACTIVITY_TYPES$ROOT$, _activities.ACTIVITY_TYPES.REACTION, getActivityHandlerByKey(_activities.ACTIVITY_TYPES.REACTION)), (0, _defineProperty2.default)(_ACTIVITY_TYPES$ROOT$, _activities.ACTIVITY_TYPES.REACTION_SELF, getActivityHandlerByKey(_activities.ACTIVITY_TYPES.REACTION_SELF)), (0, _defineProperty2.default)(_ACTIVITY_TYPES$ROOT$, _activities.ACTIVITY_TYPES.TOMBSTONE, addNewRoot), (0, _defineProperty2.default)(_ACTIVITY_TYPES$ROOT$, _activities.ACTIVITY_TYPES.CREATE, addNewRoot), _ACTIVITY_TYPES$ROOT$)[type];
                        };

                        handleNewActivity = function handleNewActivity(activity) {
                          var actType = (0, _activities.getActivityType)(activity); // ignore deletes

                          if ((0, _activities.isDeleteActivity)(activity)) {
                            return;
                          }

                          var activityHandler = getActivityHandlerByType(actType);
                          activityHandler(activity);
                        };

                        handleNewActivities = function handleNewActivities(activities) {
                          activities.forEach(function (act) {
                            handleNewActivity(act);
                            checkAndSetNoOlderActs(act);
                          });
                        };

                        handleOlderQuery = function handleOlderQuery(activities) {
                          setBookends(activities, _activities.OLDER);
                          handleNewActivities(activities);
                        };

                        handleNewerQuery = function handleNewerQuery(activities) {
                          checkAndSetNoNewerActs(activities);

                          if (activities.length) {
                            setBookends(activities, _activities.NEWER);
                            handleNewActivities(activities);
                          }
                        };

                        handleSearch = function handleSearch(activities) {
                          setBookends(activities, _activities.MID);
                          handleNewActivities(activities);
                        };

                        getQueryResponseHandler = function getQueryResponseHandler(type) {
                          var _OLDER$NEWER$MID$INIT;

                          return (_OLDER$NEWER$MID$INIT = {}, (0, _defineProperty2.default)(_OLDER$NEWER$MID$INIT, _activities.OLDER, handleOlderQuery), (0, _defineProperty2.default)(_OLDER$NEWER$MID$INIT, _activities.NEWER, handleNewerQuery), (0, _defineProperty2.default)(_OLDER$NEWER$MID$INIT, _activities.MID, handleSearch), (0, _defineProperty2.default)(_OLDER$NEWER$MID$INIT, _activities.INITIAL, handleOlderQuery), _OLDER$NEWER$MID$INIT)[type];
                        }; // ***********************************************
                        // INNER LOOP
                        // responsible for fetching and building our maps of activities
                        // fetch until minActivities is reached, or no more acts to fetch, or we hit our max fetch count
                        // ***********************************************


                        incrementLoopCounter = (0, _activityThreadOrdering.getLoopCounterFailsafe)();
                        _loop2 = /*#__PURE__*/_regenerator.default.mark(function _loop2() {
                          var allBatchActivitiesConfig, $allBatchActivitiesFetch, $fetchRequests, params, $parentsFetch, _yield$_awaitAsyncGen, _yield$_awaitAsyncGen2, allBatchActivities, _yield$_awaitAsyncGen3, parents, handler, _parents$reply, replyIds, _parents$edit, editIds, _parents$reaction, reactionIds, $reactionFetches, $replyFetches, $editFetches, _iterator4, _step4, activity, actId, childFetchOptions, _yield$_awaitAsyncGen4, _yield$_awaitAsyncGen5, reactions, replies, edits, newReplyReactions, allReactions, rootActivityHash, visibleActivitiesCount, _iterator5, _step5, rootActivity, rootId, repliesByRootId, currentOldestPublishedDate, currentNewestPublishedDate;

                          return _regenerator.default.wrap(function _loop2$(_context10) {
                            while (1) {
                              switch (_context10.prev = _context10.next) {
                                case 0:
                                  // count loops and throw if we detect infinite loop
                                  incrementLoopCounter(); // configure fetch request. Use a smaller limit when fetching newer or mids to account for potential children fetches

                                  allBatchActivitiesConfig = _objectSpread({
                                    conversationUrl: convoUrl,
                                    limit: batchSize,
                                    includeChildren: includeChildren
                                  }, query); // request activities in batches

                                  $allBatchActivitiesFetch = _this.listActivities(allBatchActivitiesConfig); // contain fetches in array to parallelize fetching as needed

                                  $fetchRequests = [$allBatchActivitiesFetch]; // if query requires recursive fetches for children acts, add the additional fetch

                                  if (queryType === _activities.MID || queryType === _activities.NEWER) {
                                    params = {
                                      activityType: null
                                    };

                                    if (query.sinceDate) {
                                      params.sinceDate = query.sinceDate;
                                    }

                                    $parentsFetch = _this.listParentActivityIds(convoUrl, params);
                                    $fetchRequests.push($parentsFetch);
                                  } // we dont always need to fetch for parents


                                  _context10.next = 7;
                                  return (0, _awaitAsyncGenerator2.default)(_promise.default.all($fetchRequests));

                                case 7:
                                  _yield$_awaitAsyncGen = _context10.sent;
                                  _yield$_awaitAsyncGen2 = (0, _slicedToArray2.default)(_yield$_awaitAsyncGen, 2);
                                  allBatchActivities = _yield$_awaitAsyncGen2[0];
                                  _yield$_awaitAsyncGen3 = _yield$_awaitAsyncGen2[1];
                                  parents = _yield$_awaitAsyncGen3 === void 0 ? {} : _yield$_awaitAsyncGen3;
                                  // use query type to decide how to handle response
                                  handler = getQueryResponseHandler(queryType);
                                  handler(allBatchActivities);
                                  /*
                                    next we must selectively fetch the children of each of the parents to ensure completeness
                                    do this by checking the hash for each of the above parent IDs
                                    fetch children when we have a parent whose ID is represented in the parent ID lists
                                  */

                                  _parents$reply = parents.reply, replyIds = _parents$reply === void 0 ? [] : _parents$reply, _parents$edit = parents.edit, editIds = _parents$edit === void 0 ? [] : _parents$edit, _parents$reaction = parents.reaction, reactionIds = _parents$reaction === void 0 ? [] : _parents$reaction; // if no parent IDs returned, do nothing

                                  if (!(replyIds.length || editIds.length || reactionIds.length)) {
                                    _context10.next = 35;
                                    break;
                                  }

                                  $reactionFetches = [];
                                  $replyFetches = [];
                                  $editFetches = [];
                                  _iterator4 = _createForOfIteratorHelper(allBatchActivities);

                                  try {
                                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                                      activity = _step4.value;
                                      actId = activity.id;
                                      childFetchOptions = {
                                        conversationUrl: convoUrl,
                                        activityParentId: actId
                                      };

                                      if (reactionIds.includes(actId)) {
                                        $reactionFetches.push(_this.getReactionSummaryByParentId(convoUrl, actId, {
                                          activityType: 'reactionSummary',
                                          includeChildren: true
                                        }));
                                      }

                                      if (replyIds.includes(actId)) {
                                        childFetchOptions.query = {
                                          activityType: 'reply'
                                        };
                                        $replyFetches.push(_this.listAllChildActivitiesByParentId(childFetchOptions));
                                      }

                                      if (editIds.includes(actId)) {
                                        childFetchOptions.query = {
                                          activityType: 'edit'
                                        };
                                        $editFetches.push(_this.listAllChildActivitiesByParentId(childFetchOptions));
                                      }
                                    } // parallelize fetch for speeedz

                                  } catch (err) {
                                    _iterator4.e(err);
                                  } finally {
                                    _iterator4.f();
                                  }

                                  _context10.next = 23;
                                  return (0, _awaitAsyncGenerator2.default)(_promise.default.all([_promise.default.all($reactionFetches), _promise.default.all($replyFetches), _promise.default.all($editFetches)]));

                                case 23:
                                  _yield$_awaitAsyncGen4 = _context10.sent;
                                  _yield$_awaitAsyncGen5 = (0, _slicedToArray2.default)(_yield$_awaitAsyncGen4, 3);
                                  reactions = _yield$_awaitAsyncGen5[0];
                                  replies = _yield$_awaitAsyncGen5[1];
                                  edits = _yield$_awaitAsyncGen5[2];
                                  _context10.next = 30;
                                  return (0, _awaitAsyncGenerator2.default)(_promise.default.all(replies.filter(function (reply) {
                                    return replyIds.includes(reply.id);
                                  }).map(function (reply) {
                                    return _this.getReactionSummaryByParentId(convoUrl, reply.id, {
                                      activityType: 'reactionSummary',
                                      includeChildren: true
                                    });
                                  })));

                                case 30:
                                  newReplyReactions = _context10.sent;
                                  allReactions = [].concat((0, _toConsumableArray2.default)(reactions), (0, _toConsumableArray2.default)(newReplyReactions)); // stick them into activity hashes

                                  replies.forEach(function (replyArr) {
                                    return handleNewActivities(replyArr);
                                  });
                                  edits.forEach(function (editArr) {
                                    return handleNewActivities(editArr);
                                  });
                                  allReactions.forEach(function (reactionArr) {
                                    return handleNewActivities(reactionArr);
                                  });

                                case 35:
                                  rootActivityHash = getRootActivityHash();
                                  visibleActivitiesCount = rootActivityHash.size;
                                  _iterator5 = _createForOfIteratorHelper(rootActivityHash.values());

                                  try {
                                    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                                      rootActivity = _step5.value;
                                      rootId = rootActivity.id;
                                      repliesByRootId = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.REPLY, rootId);

                                      if (repliesByRootId && repliesByRootId.size) {
                                        visibleActivitiesCount += repliesByRootId.size || 0;
                                      }
                                    } // stop fetching if we've reached desired count of visible activities

                                  } catch (err) {
                                    _iterator5.e(err);
                                  } finally {
                                    _iterator5.f();
                                  }

                                  if (!(visibleActivitiesCount >= minActivities)) {
                                    _context10.next = 41;
                                    break;
                                  }

                                  return _context10.abrupt("return", "break");

                                case 41:
                                  checkAndSetNoMoreActs(queryType, visibleActivitiesCount, batchSize); // batchSize should be equal to minimum activities when fetching older activities
                                  // covers "best case" when we reach minActivities on the first fetch

                                  if (queryType === _activities.OLDER) {
                                    batchSize = minActivities;
                                  } // since a MID query can bump the batchSize, we need to reset it _after_ a potential MID query
                                  // reset batchSize in case of MID queries bumping it up


                                  if (queryType === _activities.NEWER) {
                                    batchSize = defaultBatchSize;
                                  }

                                  currentOldestPublishedDate = (0, _activities.getPublishedDate)(getOldestAct());
                                  currentNewestPublishedDate = (0, _activities.getPublishedDate)(getNewestAct()); // we're still building our activity list - derive new query from prior query and start loop again

                                  if (queryType === _activities.INITIAL) {
                                    query = (0, _activityThreadOrdering.getQuery)(_activities.OLDER, {
                                      oldestPublishedDate: currentOldestPublishedDate,
                                      batchSize: batchSize
                                    });
                                  } else {
                                    query = (0, _activityThreadOrdering.getQuery)(queryType, {
                                      batchSize: batchSize,
                                      activityToSearch: search,
                                      oldestPublishedDate: currentOldestPublishedDate,
                                      newestPublishedDate: currentNewestPublishedDate
                                    });
                                  } // if we're still building out the midDate search, bump the search limit to include activities on both sides


                                  if (queryType === _activities.MID) {
                                    batchSize += _activityThreadOrdering.batchSizeIncrementCount;
                                  }

                                case 48:
                                case "end":
                                  return _context10.stop();
                              }
                            }
                          }, _loop2);
                        });

                      case 11:
                        if (getNoMoreActs()) {
                          _context11.next = 18;
                          break;
                        }

                        return _context11.delegateYield(_loop2(), "t0", 13);

                      case 13:
                        _ret2 = _context11.t0;

                        if (!(_ret2 === "break")) {
                          _context11.next = 16;
                          break;
                        }

                        return _context11.abrupt("break", 18);

                      case 16:
                        _context11.next = 11;
                        break;

                      case 18:
                        orderedActivities = [];

                        getRepliesByParentId = function getRepliesByParentId(replyParentId) {
                          var replies = [];
                          var repliesByParentId = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.REPLY, replyParentId);

                          if (!repliesByParentId) {
                            return replies;
                          }

                          var sortedReplies = (0, _activities.sortActivitiesByPublishedDate)((0, _activityThreadOrdering.getActivityObjectsFromMap)(repliesByParentId));
                          sortedReplies.forEach(function (replyActivity) {
                            var replyId = replyActivity.id;
                            var edit = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.EDIT, replyId);
                            var reaction = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.REACTION, replyId);
                            var reactionSelf = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.REACTION_SELF, replyId);
                            var latestActivity = edit || replyActivity; // hash of root activities (in case of plain reply) and the reply activity (in case of edit)

                            var allRelevantActivitiesArr = [].concat((0, _toConsumableArray2.default)((0, _activityThreadOrdering.getActivityObjectsFromMap)(getRootActivityHash())), (0, _toConsumableArray2.default)((0, _activityThreadOrdering.getActivityObjectsFromMap)(repliesByParentId)));
                            var allRelevantActivities = allRelevantActivitiesArr.reduce(function (hashMap, act) {
                              hashMap[act.id] = act;
                              return hashMap;
                            }, {});

                            var finalReply = _this._createParsedServerActivity(latestActivity, allRelevantActivities);

                            var fullReply = {
                              id: replyId,
                              activity: finalReply,
                              reaction: reaction,
                              reactionSelf: reactionSelf
                            };
                            var sanitizedFullReply = (0, _activities.sanitizeActivity)(fullReply);
                            replies.push(sanitizedFullReply);
                          });
                          return replies;
                        };

                        orderedRoots = (0, _activities.sortActivitiesByPublishedDate)((0, _activityThreadOrdering.getActivityObjectsFromMap)(getRootActivityHash()));
                        orderedRoots.forEach(function (rootActivity) {
                          var rootId = rootActivity.id;
                          var replies = getRepliesByParentId(rootId);
                          var edit = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.EDIT, rootId);
                          var reaction = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.REACTION, rootId);
                          var reactionSelf = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.REACTION_SELF, rootId);
                          var latestActivity = edit || rootActivity;

                          var finalActivity = _this._createParsedServerActivity(latestActivity, (0, _defineProperty2.default)({}, rootId, rootActivity));

                          var fullRoot = {
                            id: rootId,
                            activity: finalActivity,
                            reaction: reaction,
                            reactionSelf: reactionSelf
                          };
                          var sanitizedFullRoot = (0, _activities.sanitizeActivity)(fullRoot);
                          orderedActivities.push(sanitizedFullRoot);
                          replies.forEach(function (reply) {
                            return orderedActivities.push(reply);
                          });
                        });
                        _context11.next = 24;
                        return orderedActivities;

                      case 24:
                        nextOptions = _context11.sent;

                        if (!nextOptions) {
                          _context11.next = 33;
                          break;
                        }

                        minActivities = nextOptions.minActivities || minActivities;
                        currentOldestPublishedDate = (0, _activities.getPublishedDate)(getOldestAct());
                        currentNewestPublishedDate = (0, _activities.getPublishedDate)(getNewestAct());
                        queryType = nextOptions.queryType;
                        query = (0, _activityThreadOrdering.getQuery)(queryType, {
                          activityToSearch: search,
                          oldestPublishedDate: currentOldestPublishedDate,
                          newestPublishedDate: currentNewestPublishedDate,
                          batchSize: batchSize
                        });
                        _context11.next = 34;
                        break;

                      case 33:
                        return _context11.abrupt("return", {
                          v: void 0
                        });

                      case 34:
                      case "end":
                        return _context11.stop();
                    }
                  }
                }, _loop);
              });

            case 9:
              if (!true) {
                _context12.next = 16;
                break;
              }

              return _context12.delegateYield(_loop(), "t0", 11);

            case 11:
              _ret = _context12.t0;

              if (!((0, _typeof2.default)(_ret) === "object")) {
                _context12.next = 14;
                break;
              }

              return _context12.abrupt("return", _ret.v);

            case 14:
              _context12.next = 9;
              break;

            case 16:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee10);
    }))();
  },

  /**
   * @typedef {object} EditActivity
   * @property {object} editParent
   *
   * @typedef {object} ReplyActivity
   * @property {object} replyParent
   *
   * @typedef {object} EditedReplyActivity
   * @property {object} replyParent
   * @property {object} editParent
   *
   * @typedef {EditActivity | ReplyActivity | EditedReplyActivity} ParsedServerActivity
   */

  /**
    * hashmap of server activities, keyed by id
    * @typedef {object} ActivityHash
    * @property {Object}
    */

  /**
   * extends a given server object with fields that point to their parent activities from the hashmap passed in
   * @param {object} activity server activity
   * @param {ActivityHash} allActivitiesHash hashmap of all server activities caller would like to pass in
   * @returns {ParsedServerActivity} server activity extended with edit and reply parent fields
   */
  _createParsedServerActivity: function _createParsedServerActivity(activity) {
    var allActivitiesHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var isOrphan = (0, _activities.getIsActivityOrphaned)(activity, allActivitiesHash);

    if (isOrphan) {
      throw new Error('activity has a parent that cannot be found in allActivitiesHash! please handle this as necessary');
    }

    var activityType = (0, _activities.determineActivityType)(activity, allActivitiesHash);

    switch (activityType) {
      case _activities.ACTIVITY_TYPES.ROOT:
        {
          return (0, _activities.createRootActivity)(activity);
        }

      case _activities.ACTIVITY_TYPES.EDIT:
        {
          // `activities` must also have the original activity
          return (0, _activities.createEditActivity)(activity, allActivitiesHash);
        }

      case _activities.ACTIVITY_TYPES.REPLY:
        {
          return (0, _activities.createReplyActivity)(activity);
        }

      case _activities.ACTIVITY_TYPES.REPLY_EDIT:
        {
          // `activities` must also have the reply activity
          return (0, _activities.createReplyEditActivity)(activity, allActivitiesHash);
        }

      default:
        {
          return activity;
        }
    }
  },

  /**
   * @param {Object} options
   * @private
   * @returns {Promise<Array<Conversation>>}
   */
  _list: function _list(options) {
    var _this30 = this;

    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee11() {
      var res, list, limit, results, _iterator6, _step6, result, items;

      return _regenerator.default.wrap(function _callee11$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              options.qs = (0, _assign.default)({
                personRefresh: true,
                uuidEntryFormat: true,
                activitiesLimit: 0,
                participantsLimit: 0
              }, options.qs);
              _context13.next = 3;
              return _this30.request(options);

            case 3:
              res = _context13.sent;

              if (!res.body || !res.body.items || res.body.items.length === 0) {
                list = [];
              } else {
                list = res.body.items.slice(0);

                if ((0, _last2.default)(list).published < list[0].published) {
                  list.reverse();
                }
              } // The user has more data in another cluster.
              // Follow the 'additionalUrls' for that data.


              if (!res.body.additionalUrls) {
                _context13.next = 14;
                break;
              }

              limit = 0; // If the user asked for a specific amount of data,
              // don't fetch more than what was asked.
              // Here we figure out how much is left from the original request.
              // Divide that by the number of additional URLS.
              // This won't get us the exact limit but it will retrieve something
              // from every cluster listed.

              if (options.limit) {
                limit = Math.floor((options.limit.value - list.length) / res.body.additionalUrls.length);
              } // If the limit is 0 for some reason,
              // don't bother requesting from other clusters


              if (!(!options.limit || limit !== 0)) {
                _context13.next = 14;
                break;
              }

              _context13.next = 11;
              return _promise.default.all(res.body.additionalUrls.map(function (host) {
                var url = "".concat(host, "/").concat(options.resource);
                var newOptions = (0, _assign.default)({}, options, {
                  uri: url,
                  url: url
                });

                if (options.limit) {
                  newOptions.qs[newOptions.limit.name] = limit;
                }

                return _this30.request(newOptions);
              }));

            case 11:
              results = _context13.sent;
              _iterator6 = _createForOfIteratorHelper(results);

              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  result = _step6.value;

                  if (result.body && result.body.items && result.body.items.length) {
                    items = result.body.items;

                    if ((0, _last2.default)(items).published < items[0].published) {
                      items.reverse();
                    }

                    list = list.concat(items);
                  }
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }

            case 14:
              _context13.next = 16;
              return _promise.default.all(list.map(function (item) {
                return _this30._recordUUIDs(item);
              }));

            case 16:
              return _context13.abrupt("return", list);

            case 17:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee11);
    }))();
  },

  /**
   * @param {Object} params
   * @param {Object} options
   * @private
   * @returns {Promise<Conversation>}
   */
  _maybeCreateOneOnOneThenPost: function _maybeCreateOneOnOneThenPost(params, options) {
    var _this31 = this;

    return this.get((0, _defaults2.default)({
      // the use of uniq in Conversation#create guarantees participant[1] will
      // always be the other user
      user: params.participants[1]
    }), (0, _assign.default)(options, {
      includeConvWithDeletedUserUUID: true,
      includeParticipants: true
    })).then(function (conversation) {
      if (params.comment || params.html) {
        return _this31.post(conversation, {
          content: params.html,
          displayName: params.comment
        }).then(function (activity) {
          conversation.activities.items.push(activity);
          return conversation;
        });
      }

      return conversation;
    }).catch(function (reason) {
      if (reason.statusCode !== 404) {
        return _promise.default.reject(reason);
      }

      return _this31._createOneOnOne(params);
    });
  },

  /**
   * @param {Object} params
   * @private
   * @returns {Object}
   */
  _prepareConversationForCreation: function _prepareConversationForCreation(params) {
    var _this32 = this;

    var payload = {
      activities: {
        items: [this.expand('create')]
      },
      objectType: 'conversation',
      kmsMessage: {
        method: 'create',
        uri: '/resources',
        userIds: (0, _cloneDeep2.default)(params.participants),
        keyUris: []
      }
    };

    if (params.displayName) {
      payload.displayName = params.displayName;
    }

    if (params.tags) {
      payload.tags = params.tags;
    }

    params.participants.forEach(function (participant) {
      payload.activities.items.push(_this32.expand('add', {
        objectType: 'person',
        id: participant
      }));
    });

    if (params.comment) {
      payload.activities.items.push(this.expand('post', {
        objectType: 'comment',
        content: params.html,
        displayName: params.comment
      }));
    }

    if (!params.isDefaultClassification && params.classificationId) {
      payload.activities.items.push(this.expand('update', {
        objectType: 'classification',
        classificationId: params.classificationId,
        effectiveDate: params.effectiveDate
      }));
    }

    if (params.favorite) {
      payload.activities.items.push(this.expand('favorite', {
        objectType: 'conversation'
      }));
    }

    return payload;
  },

  /**
   * @param {Object} conversation
   * @private
   * @returns {Promise}
   */
  _recordUUIDs: function _recordUUIDs(conversation) {
    var _this33 = this;

    if (!conversation.participants || !conversation.participants.items) {
      return _promise.default.resolve(conversation);
    }

    return _promise.default.all(conversation.participants.items.map(function (participant) {
      // ROOMs or LYRA_SPACEs do not have email addresses, so there's no point attempting to
      // record their UUIDs.
      if (participant.type === 'ROOM' || participant.type === 'LYRA_SPACE') {
        return _promise.default.resolve();
      }

      return _this33.webex.internal.user.recordUUID(participant).catch(function (err) {
        return _this33.logger.warn('Could not record uuid', err);
      });
    }));
  },
  version: "1.125.6"
});

['favorite', 'hide', 'lock', 'mute', 'unfavorite', 'unhide', 'unlock', 'unmute'].forEach(function (verb) {
  Conversation.prototype[verb] = function submitSimpleActivity(conversation, activity) {
    var _this34 = this;

    var convoWithUrl = this.prepareConversation((0, _assign.default)({}, conversation, {
      url: this.getConvoUrl(conversation)
    }));
    return this.prepare(activity, {
      verb: verb,
      object: convoWithUrl,
      target: convoWithUrl
    }).then(function (a) {
      return _this34.submit(a);
    });
  };
});
['assignModerator', 'unassignModerator'].forEach(function (verb) {
  Conversation.prototype[verb] = function submitModerationChangeActivity(conversation, moderator, activity) {
    var _this35 = this;

    var convoWithUrl = (0, _assign.default)({}, conversation, {
      url: this.getConvoUrl(conversation)
    });
    return _promise.default.all([convoWithUrl, moderator ? this.webex.internal.user.asUUID(moderator) : this.webex.internal.device.userId]).then(function (_ref8) {
      var _ref9 = (0, _slicedToArray2.default)(_ref8, 2),
          c = _ref9[0],
          userId = _ref9[1];

      return _this35.prepare(activity, {
        verb: verb,
        target: _this35.prepareConversation(c),
        object: {
          id: userId,
          objectType: 'person'
        }
      });
    }).then(function (a) {
      return _this35.submit(a);
    });
  };
});
/**
 * Sets/unsets space property for convo
 * @param {Object} conversation
 * @param {string} tag
 * @param {Activity} activity
 * @returns {Promise<Activity>}
 */

['setSpaceProperty', 'unsetSpaceProperty'].forEach(function (fnName) {
  var verb = fnName.startsWith('set') ? 'set' : 'unset';

  Conversation.prototype[fnName] = function submitSpacePropertyActivity(conversation, tag, activity) {
    var _this36 = this;

    if (!(0, _isString2.default)(tag)) {
      return _promise.default.reject(new Error('`tag` must be a string'));
    }

    var convoWithUrl = (0, _assign.default)({}, conversation, {
      url: this.getConvoUrl(conversation)
    });
    return this.prepare(activity, {
      verb: verb,
      target: this.prepareConversation(convoWithUrl),
      object: {
        tags: [tag],
        objectType: 'spaceProperty'
      }
    }).then(function (a) {
      return _this36.submit(a);
    });
  };
});
['tag', 'untag'].forEach(function (verb) {
  Conversation.prototype[verb] = function submitObjectActivity(conversation, object, activity) {
    var _this37 = this;

    if (!(0, _isObject2.default)(object)) {
      return _promise.default.reject(new Error('`object` must be an object'));
    }

    var c = this.prepareConversation((0, _assign.default)({}, conversation, {
      url: this.getConvoUrl(conversation)
    }));
    return this.prepare(activity, {
      verb: verb,
      target: c,
      object: (0, _assign.default)(c, object)
    }).then(function (a) {
      return _this37.submit(a);
    });
  };
});
var _default = Conversation;
exports.default = _default;
//# sourceMappingURL=conversation.js.map
