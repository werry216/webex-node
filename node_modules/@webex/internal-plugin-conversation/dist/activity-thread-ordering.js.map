{"version":3,"sources":["activity-thread-ordering.js"],"names":["defaultMinDisplayableActivities","minBatchSize","fetchLoopCountMax","batchSizeIncrementCount","setValue","destination","key","value","set","getValue","source","get","getActivityObjectsFromMap","hashMap","map","activity","activityManager","replyActivityHash","editActivityHash","reactionActivityHash","reactionSelfActivityHash","handleNewReply","replyAct","replyParentId","existingReplyHash","id","replyHash","handleNewEdit","editAct","isTombstone","verb","ACTIVITY_TYPES","TOMBSTONE","editParentId","existingEdit","reactionHelper","reactionAct","hash","reactionParentId","existingReaction","handleNewReaction","handleNewReactionSelf","reactionSelfAct","getActivityHandlerByKey","REACTION","REACTION_SELF","EDIT","REPLY","getActivityByTypeAndParentId","type","bookendManager","oldestAct","newestAct","getOldestAct","getNewestAct","setOldestAct","act","setNewestAct","setBookends","activities","oldestActsFirst","newestInBatch","oldestInBatch","noMoreActivitiesManager","noMoreActs","noOlderActs","noNewerActs","getNoMoreActs","checkAndSetNoOlderActs","CREATE","checkAndSetNoNewerActs","length","checkAndSetNoMoreActs","queryType","visibleActs","currentBatchSize","NEWER","OLDER","INITIAL","MID","rootActivityManager","rootActivityHash","addNewRoot","rootAct","getRootActivityHash","getLoopCounterFailsafe","fetchLoopCount","Error","getQuery","queryOptions","newestPublishedDate","oldestPublishedDate","batchSize","activityToSearch","sinceDate","lastActivityFirst","searchType","midDate","parent","published","limit","maxDate"],"mappings":"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","sourcesContent":["import {last} from 'lodash';\n\nimport {\n  ACTIVITY_TYPES,\n  getParentId,\n  isNewer,\n  getActivityType,\n  sortActivitiesByPublishedDate,\n  NEWER,\n  OLDER,\n  INITIAL,\n  MID\n} from './activities';\n\nexport const defaultMinDisplayableActivities = 20;\nexport const minBatchSize = 10;\nexport const fetchLoopCountMax = 100;\nexport const batchSizeIncrementCount = 10;\n\n// use accessors for ease of refactoring underlying implementation\n/**\n * @param {Map} destination destination map object for data. Currently a Map, but could be refactored to use any type.\n * @param {string} key\n * @param {any} value\n * @returns {Map}\n */\nexport const setValue = (destination, key, value) => destination.set(key, value);\n/**\n * @param {Map} source source map object to access. Currently expects a Map, but could be refactored to use any type\n * @param {string} key\n * @returns {Map}\n */\nexport const getValue = (source, key) => source.get(key);\n\nexport const getActivityObjectsFromMap = (hashMap) => Array.from(hashMap).map(([, activity]) => activity);\n/**\n * creates maps for various activity types and defines handlers for working with stored activities\n * utilizes revealing module pattern to close over state and only expose certain necessary functions for altering state\n * @function\n * @returns {object}\n * getActivityHandlerByKey(activityType) - accepts a key to map to a defined activity handler\n * getActivityByTypeAndParentId(activityType, parentId) accepts a key and a parent ID to return an activity of that type whose parent is the parentId\n */\nexport const activityManager = () => {\n  const replyActivityHash = new Map();\n  const editActivityHash = new Map();\n  const reactionActivityHash = new Map();\n  const reactionSelfActivityHash = new Map();\n\n  const handleNewReply = (replyAct) => {\n    const replyParentId = getParentId(replyAct);\n    const existingReplyHash = getValue(replyActivityHash, replyParentId);\n\n    if (existingReplyHash) {\n      setValue(existingReplyHash, replyAct.id, replyAct);\n    }\n    else {\n      const replyHash = new Map();\n\n      setValue(replyHash, replyAct.id, replyAct);\n      setValue(replyActivityHash, replyParentId, replyHash);\n    }\n  };\n\n  const handleNewEdit = (editAct) => {\n    const isTombstone = editAct.verb === ACTIVITY_TYPES.TOMBSTONE;\n\n    // we can ignore tombstone edits in favor of the newer one\n    if (isTombstone) {\n      return;\n    }\n\n    const editParentId = getParentId(editAct);\n    const existingEdit = getValue(editActivityHash, editParentId);\n\n    // edited activity must be newer than what we already have\n    if (!existingEdit || isNewer(editAct, existingEdit)) {\n      setValue(editActivityHash, editParentId, editAct);\n    }\n  };\n\n  // logic is identical between reactions and reaction selfs, so handler simply passes the activity and the correct hash\n  const reactionHelper = (reactionAct, hash) => {\n    const reactionParentId = getParentId(reactionAct);\n    const existingReaction = getValue(hash, reactionParentId);\n\n    // reaction activity must be newer than what we already have\n    if (!existingReaction || isNewer(reactionAct, existingReaction)) {\n      setValue(hash, reactionParentId, reactionAct);\n    }\n  };\n\n  const handleNewReaction = (reactionAct) => {\n    reactionHelper(reactionAct, reactionActivityHash);\n  };\n\n  const handleNewReactionSelf = (reactionSelfAct) => {\n    reactionHelper(reactionSelfAct, reactionSelfActivityHash);\n  };\n\n  const getActivityHandlerByKey = (key) => ({\n    [ACTIVITY_TYPES.REACTION]: handleNewReaction,\n    [ACTIVITY_TYPES.REACTION_SELF]: handleNewReactionSelf,\n    [ACTIVITY_TYPES.EDIT]: handleNewEdit,\n    [ACTIVITY_TYPES.REPLY]: handleNewReply\n  }[key]);\n\n  const getActivityByTypeAndParentId = (type, id) => ({\n    [ACTIVITY_TYPES.EDIT]: getValue(editActivityHash, id),\n    [ACTIVITY_TYPES.REPLY]: getValue(replyActivityHash, id),\n    [ACTIVITY_TYPES.REACTION]: getValue(reactionActivityHash, id),\n    [ACTIVITY_TYPES.REACTION_SELF]: getValue(reactionSelfActivityHash, id)\n  }[type]);\n\n  return {\n    getActivityHandlerByKey,\n    getActivityByTypeAndParentId\n  };\n};\n\n/**\n * encapsulates state and logic for managing oldest and newest activities\n * @returns {object} setters and getters for activity state management\n */\nexport const bookendManager = () => {\n  // keep track of generator state, like what our current oldest & newest activities are\n  let oldestAct;\n  let newestAct;\n\n  const getOldestAct = () => oldestAct;\n  const getNewestAct = () => newestAct;\n\n  const setOldestAct = (act) => {\n    if (!oldestAct) {\n      oldestAct = act;\n    }\n    else if (isNewer(oldestAct, act)) {\n      oldestAct = act;\n    }\n  };\n\n  const setNewestAct = (act) => {\n    if (!newestAct) {\n      newestAct = act;\n    }\n    else if (isNewer(act, newestAct)) {\n      newestAct = act;\n    }\n  };\n\n  const setBookends = (activities) => {\n    const oldestActsFirst = sortActivitiesByPublishedDate(activities);\n\n    const newestInBatch = last(oldestActsFirst);\n    const oldestInBatch = oldestActsFirst[0];\n\n    setOldestAct(oldestInBatch);\n    setNewestAct(newestInBatch);\n  };\n\n  return {\n    setBookends,\n    getNewestAct,\n    getOldestAct\n  };\n};\n\n/**\n * encapsulates state and logic for when there are no more fetchable activities from convo\n * @returns {object} setters and getters for no more activities logic\n */\nexport const noMoreActivitiesManager = () => {\n  // used to determine if we should continue to fetch older activities\n  // must be set per iteration, as querying newer activities is still valid when all end of convo has been reached\n  let noMoreActs = false;\n  let noOlderActs = false;\n  let noNewerActs = false;\n\n  const getNoMoreActs = () => noMoreActs;\n\n  const checkAndSetNoOlderActs = (act) => {\n    if (!noOlderActs && getActivityType(act) === ACTIVITY_TYPES.CREATE) {\n      noOlderActs = true;\n    }\n  };\n\n  const checkAndSetNoNewerActs = (activities) => {\n    if (!activities || !activities.length) {\n      noNewerActs = true;\n    }\n  };\n\n  const checkAndSetNoMoreActs = (queryType, visibleActs, currentBatchSize) => {\n    if (\n      (queryType === NEWER && noNewerActs) ||\n      ((queryType === OLDER || queryType === INITIAL) && noOlderActs) ||\n      (queryType === MID && visibleActs < currentBatchSize && noOlderActs)\n    ) {\n      noMoreActs = true;\n    }\n  };\n\n  return {\n    getNoMoreActs,\n    checkAndSetNoMoreActs,\n    checkAndSetNoNewerActs,\n    checkAndSetNoOlderActs\n  };\n};\n\n/**\n * encapsulates state and logic for managing root activities\n * @returns {object} setters and getters for activity state management\n */\nexport const rootActivityManager = () => {\n  const rootActivityHash = new Map();\n\n  const addNewRoot = (rootAct) => {\n    setValue(rootActivityHash, rootAct.id, rootAct);\n  };\n\n  const getRootActivityHash = () => rootActivityHash;\n\n  return {\n    addNewRoot,\n    getRootActivityHash\n  };\n};\n\nexport const getLoopCounterFailsafe = () => {\n  let fetchLoopCount = 0;\n\n  return () => {\n    fetchLoopCount += 1;\n    if (fetchLoopCount > fetchLoopCountMax) {\n      throw new Error('max fetches reached');\n    }\n  };\n};\n\n/**\n * creates activity query object\n * @param {string} type type of query to create\n * @param {object} queryOptions options to define query\n * @param {string} [queryOptions.newestPublishedDate] the date of the newest fetched activity\n * @param {string} [queryOptions.oldestPublishedDate] the date of the oldest fetched activity\n * @param {number} [queryOptions.batchSize] the number of activities to query\n * @param {object} [queryOptions.activityToSearch] a server activity to use to build middate query\n * @returns {object}\n */\nexport const getQuery = (type, queryOptions) => {\n  const {\n    newestPublishedDate, oldestPublishedDate, batchSize, activityToSearch = {}\n  } = queryOptions;\n\n  switch (type) {\n    case NEWER: {\n      const sinceDate = newestPublishedDate + 1;\n      const lastActivityFirst = false;\n\n      return {sinceDate, lastActivityFirst};\n    }\n    case MID: {\n      const searchType = getActivityType(activityToSearch);\n      let midDate;\n\n      if (searchType === ACTIVITY_TYPES.REPLY || searchType === ACTIVITY_TYPES.EDIT) {\n        midDate = activityToSearch.parent.published;\n      }\n      else {\n        midDate = activityToSearch.published;\n      }\n\n      return {midDate, limit: batchSize};\n    }\n    case OLDER: {\n      const maxDate = oldestPublishedDate - 1;\n\n      return {maxDate};\n    }\n    case INITIAL:\n    default: {\n      return {};\n    }\n  }\n};\n"]}