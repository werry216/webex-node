"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.getQuery = exports.getLoopCounterFailsafe = exports.rootActivityManager = exports.noMoreActivitiesManager = exports.bookendManager = exports.activityManager = exports.getActivityObjectsFromMap = exports.getValue = exports.setValue = exports.batchSizeIncrementCount = exports.fetchLoopCountMax = exports.minBatchSize = exports.defaultMinDisplayableActivities = void 0;

var _from = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/array/from"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/map"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _last2 = _interopRequireDefault(require("lodash/last"));

var _activities = require("./activities");

var defaultMinDisplayableActivities = 20;
exports.defaultMinDisplayableActivities = defaultMinDisplayableActivities;
var minBatchSize = 10;
exports.minBatchSize = minBatchSize;
var fetchLoopCountMax = 100;
exports.fetchLoopCountMax = fetchLoopCountMax;
var batchSizeIncrementCount = 10; // use accessors for ease of refactoring underlying implementation

/**
 * @param {Map} destination destination map object for data. Currently a Map, but could be refactored to use any type.
 * @param {string} key
 * @param {any} value
 * @returns {Map}
 */

exports.batchSizeIncrementCount = batchSizeIncrementCount;

var setValue = function setValue(destination, key, value) {
  return destination.set(key, value);
};
/**
 * @param {Map} source source map object to access. Currently expects a Map, but could be refactored to use any type
 * @param {string} key
 * @returns {Map}
 */


exports.setValue = setValue;

var getValue = function getValue(source, key) {
  return source.get(key);
};

exports.getValue = getValue;

var getActivityObjectsFromMap = function getActivityObjectsFromMap(hashMap) {
  return (0, _from.default)(hashMap).map(function (_ref) {
    var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
        activity = _ref2[1];

    return activity;
  });
};
/**
 * creates maps for various activity types and defines handlers for working with stored activities
 * utilizes revealing module pattern to close over state and only expose certain necessary functions for altering state
 * @function
 * @returns {object}
 * getActivityHandlerByKey(activityType) - accepts a key to map to a defined activity handler
 * getActivityByTypeAndParentId(activityType, parentId) accepts a key and a parent ID to return an activity of that type whose parent is the parentId
 */


exports.getActivityObjectsFromMap = getActivityObjectsFromMap;

var activityManager = function activityManager() {
  var replyActivityHash = new _map.default();
  var editActivityHash = new _map.default();
  var reactionActivityHash = new _map.default();
  var reactionSelfActivityHash = new _map.default();

  var handleNewReply = function handleNewReply(replyAct) {
    var replyParentId = (0, _activities.getParentId)(replyAct);
    var existingReplyHash = getValue(replyActivityHash, replyParentId);

    if (existingReplyHash) {
      setValue(existingReplyHash, replyAct.id, replyAct);
    } else {
      var replyHash = new _map.default();
      setValue(replyHash, replyAct.id, replyAct);
      setValue(replyActivityHash, replyParentId, replyHash);
    }
  };

  var handleNewEdit = function handleNewEdit(editAct) {
    var isTombstone = editAct.verb === _activities.ACTIVITY_TYPES.TOMBSTONE; // we can ignore tombstone edits in favor of the newer one

    if (isTombstone) {
      return;
    }

    var editParentId = (0, _activities.getParentId)(editAct);
    var existingEdit = getValue(editActivityHash, editParentId); // edited activity must be newer than what we already have

    if (!existingEdit || (0, _activities.isNewer)(editAct, existingEdit)) {
      setValue(editActivityHash, editParentId, editAct);
    }
  }; // logic is identical between reactions and reaction selfs, so handler simply passes the activity and the correct hash


  var reactionHelper = function reactionHelper(reactionAct, hash) {
    var reactionParentId = (0, _activities.getParentId)(reactionAct);
    var existingReaction = getValue(hash, reactionParentId); // reaction activity must be newer than what we already have

    if (!existingReaction || (0, _activities.isNewer)(reactionAct, existingReaction)) {
      setValue(hash, reactionParentId, reactionAct);
    }
  };

  var handleNewReaction = function handleNewReaction(reactionAct) {
    reactionHelper(reactionAct, reactionActivityHash);
  };

  var handleNewReactionSelf = function handleNewReactionSelf(reactionSelfAct) {
    reactionHelper(reactionSelfAct, reactionSelfActivityHash);
  };

  var getActivityHandlerByKey = function getActivityHandlerByKey(key) {
    var _ACTIVITY_TYPES$REACT;

    return (_ACTIVITY_TYPES$REACT = {}, (0, _defineProperty2.default)(_ACTIVITY_TYPES$REACT, _activities.ACTIVITY_TYPES.REACTION, handleNewReaction), (0, _defineProperty2.default)(_ACTIVITY_TYPES$REACT, _activities.ACTIVITY_TYPES.REACTION_SELF, handleNewReactionSelf), (0, _defineProperty2.default)(_ACTIVITY_TYPES$REACT, _activities.ACTIVITY_TYPES.EDIT, handleNewEdit), (0, _defineProperty2.default)(_ACTIVITY_TYPES$REACT, _activities.ACTIVITY_TYPES.REPLY, handleNewReply), _ACTIVITY_TYPES$REACT)[key];
  };

  var getActivityByTypeAndParentId = function getActivityByTypeAndParentId(type, id) {
    var _ACTIVITY_TYPES$EDIT$;

    return (_ACTIVITY_TYPES$EDIT$ = {}, (0, _defineProperty2.default)(_ACTIVITY_TYPES$EDIT$, _activities.ACTIVITY_TYPES.EDIT, getValue(editActivityHash, id)), (0, _defineProperty2.default)(_ACTIVITY_TYPES$EDIT$, _activities.ACTIVITY_TYPES.REPLY, getValue(replyActivityHash, id)), (0, _defineProperty2.default)(_ACTIVITY_TYPES$EDIT$, _activities.ACTIVITY_TYPES.REACTION, getValue(reactionActivityHash, id)), (0, _defineProperty2.default)(_ACTIVITY_TYPES$EDIT$, _activities.ACTIVITY_TYPES.REACTION_SELF, getValue(reactionSelfActivityHash, id)), _ACTIVITY_TYPES$EDIT$)[type];
  };

  return {
    getActivityHandlerByKey: getActivityHandlerByKey,
    getActivityByTypeAndParentId: getActivityByTypeAndParentId
  };
};
/**
 * encapsulates state and logic for managing oldest and newest activities
 * @returns {object} setters and getters for activity state management
 */


exports.activityManager = activityManager;

var bookendManager = function bookendManager() {
  // keep track of generator state, like what our current oldest & newest activities are
  var oldestAct;
  var newestAct;

  var getOldestAct = function getOldestAct() {
    return oldestAct;
  };

  var getNewestAct = function getNewestAct() {
    return newestAct;
  };

  var setOldestAct = function setOldestAct(act) {
    if (!oldestAct) {
      oldestAct = act;
    } else if ((0, _activities.isNewer)(oldestAct, act)) {
      oldestAct = act;
    }
  };

  var setNewestAct = function setNewestAct(act) {
    if (!newestAct) {
      newestAct = act;
    } else if ((0, _activities.isNewer)(act, newestAct)) {
      newestAct = act;
    }
  };

  var setBookends = function setBookends(activities) {
    var oldestActsFirst = (0, _activities.sortActivitiesByPublishedDate)(activities);
    var newestInBatch = (0, _last2.default)(oldestActsFirst);
    var oldestInBatch = oldestActsFirst[0];
    setOldestAct(oldestInBatch);
    setNewestAct(newestInBatch);
  };

  return {
    setBookends: setBookends,
    getNewestAct: getNewestAct,
    getOldestAct: getOldestAct
  };
};
/**
 * encapsulates state and logic for when there are no more fetchable activities from convo
 * @returns {object} setters and getters for no more activities logic
 */


exports.bookendManager = bookendManager;

var noMoreActivitiesManager = function noMoreActivitiesManager() {
  // used to determine if we should continue to fetch older activities
  // must be set per iteration, as querying newer activities is still valid when all end of convo has been reached
  var noMoreActs = false;
  var noOlderActs = false;
  var noNewerActs = false;

  var getNoMoreActs = function getNoMoreActs() {
    return noMoreActs;
  };

  var checkAndSetNoOlderActs = function checkAndSetNoOlderActs(act) {
    if (!noOlderActs && (0, _activities.getActivityType)(act) === _activities.ACTIVITY_TYPES.CREATE) {
      noOlderActs = true;
    }
  };

  var checkAndSetNoNewerActs = function checkAndSetNoNewerActs(activities) {
    if (!activities || !activities.length) {
      noNewerActs = true;
    }
  };

  var checkAndSetNoMoreActs = function checkAndSetNoMoreActs(queryType, visibleActs, currentBatchSize) {
    if (queryType === _activities.NEWER && noNewerActs || (queryType === _activities.OLDER || queryType === _activities.INITIAL) && noOlderActs || queryType === _activities.MID && visibleActs < currentBatchSize && noOlderActs) {
      noMoreActs = true;
    }
  };

  return {
    getNoMoreActs: getNoMoreActs,
    checkAndSetNoMoreActs: checkAndSetNoMoreActs,
    checkAndSetNoNewerActs: checkAndSetNoNewerActs,
    checkAndSetNoOlderActs: checkAndSetNoOlderActs
  };
};
/**
 * encapsulates state and logic for managing root activities
 * @returns {object} setters and getters for activity state management
 */


exports.noMoreActivitiesManager = noMoreActivitiesManager;

var rootActivityManager = function rootActivityManager() {
  var rootActivityHash = new _map.default();

  var addNewRoot = function addNewRoot(rootAct) {
    setValue(rootActivityHash, rootAct.id, rootAct);
  };

  var getRootActivityHash = function getRootActivityHash() {
    return rootActivityHash;
  };

  return {
    addNewRoot: addNewRoot,
    getRootActivityHash: getRootActivityHash
  };
};

exports.rootActivityManager = rootActivityManager;

var getLoopCounterFailsafe = function getLoopCounterFailsafe() {
  var fetchLoopCount = 0;
  return function () {
    fetchLoopCount += 1;

    if (fetchLoopCount > fetchLoopCountMax) {
      throw new Error('max fetches reached');
    }
  };
};
/**
 * creates activity query object
 * @param {string} type type of query to create
 * @param {object} queryOptions options to define query
 * @param {string} [queryOptions.newestPublishedDate] the date of the newest fetched activity
 * @param {string} [queryOptions.oldestPublishedDate] the date of the oldest fetched activity
 * @param {number} [queryOptions.batchSize] the number of activities to query
 * @param {object} [queryOptions.activityToSearch] a server activity to use to build middate query
 * @returns {object}
 */


exports.getLoopCounterFailsafe = getLoopCounterFailsafe;

var getQuery = function getQuery(type, queryOptions) {
  var newestPublishedDate = queryOptions.newestPublishedDate,
      oldestPublishedDate = queryOptions.oldestPublishedDate,
      batchSize = queryOptions.batchSize,
      _queryOptions$activit = queryOptions.activityToSearch,
      activityToSearch = _queryOptions$activit === void 0 ? {} : _queryOptions$activit;

  switch (type) {
    case _activities.NEWER:
      {
        var sinceDate = newestPublishedDate + 1;
        var lastActivityFirst = false;
        return {
          sinceDate: sinceDate,
          lastActivityFirst: lastActivityFirst
        };
      }

    case _activities.MID:
      {
        var searchType = (0, _activities.getActivityType)(activityToSearch);
        var midDate;

        if (searchType === _activities.ACTIVITY_TYPES.REPLY || searchType === _activities.ACTIVITY_TYPES.EDIT) {
          midDate = activityToSearch.parent.published;
        } else {
          midDate = activityToSearch.published;
        }

        return {
          midDate: midDate,
          limit: batchSize
        };
      }

    case _activities.OLDER:
      {
        var maxDate = oldestPublishedDate - 1;
        return {
          maxDate: maxDate
        };
      }

    case _activities.INITIAL:
    default:
      {
        return {};
      }
  }
};

exports.getQuery = getQuery;
//# sourceMappingURL=activity-thread-ordering.js.map
