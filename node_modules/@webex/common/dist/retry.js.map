{"version":3,"sources":["retry.js"],"names":["retry","params","options","backoff","delay","maxAttempts","strategyOptions","initialDelay","maxDelay","length","retryDecorator","target","prop","descriptor","value","retryExecutor","fn","args","emitter","EventEmitter","promise","resolve","reject","call","cb","innerPromise","on","emit","bind","then","res","catch","reason","Error","err","setStrategy","ExponentialStrategy","failAfter","start","key","callback","prototype"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {EventEmitter} from 'events';\n\nimport {defaults, isFunction, wrap} from 'lodash';\nimport backoff from 'backoff';\n\n/* eslint max-nested-callbacks: [0] */\n\n/**\n * Makes a promise-returning method retryable according to the specified backoff\n * pattern\n * @param {Object} options\n * @param {boolean} options.backoff\n * @param {number} options.delay\n * @param {number} options.initialDelay\n * @param {number} options.maxAttempts\n * @param {number} options.maxDelay\n *\n * @returns {Function}\n */\nexport default function retry(...params) {\n  let options = params[0] || {};\n\n  options = Object.assign({}, options);\n  defaults(options, {\n    backoff: true,\n    delay: 1,\n    maxAttempts: 3\n  });\n\n  let strategyOptions;\n\n  if (options.backoff) {\n    strategyOptions = {\n      initialDelay: options.delay,\n      maxDelay: options.maxDelay\n    };\n  }\n  else {\n    strategyOptions = {\n      initialDelay: 1,\n      maxDelay: 1\n    };\n  }\n\n  if (params.length === 3) {\n    return Reflect.apply(retryDecorator, null, params);\n  }\n\n  return retryDecorator;\n\n  /**\n   * @param {Object} target\n   * @param {string} prop\n   * @param {Object} descriptor\n   * @private\n   * @returns {Object}\n   */\n  function retryDecorator(target, prop, descriptor) {\n    descriptor.value = wrap(descriptor.value, function retryExecutor(fn, ...args) {\n      const emitter = new EventEmitter();\n      const promise = new Promise((resolve, reject) => {\n        // backoff.call is not Function.prototype.call; it's an unfortunate naming\n        // collision.\n        /* eslint prefer-reflect: [0] */\n        const call = backoff.call(\n          (cb) => {\n            /* eslint no-invalid-this: [0] */\n            const innerPromise = Reflect.apply(fn, this, args);\n\n            if (isFunction(innerPromise.on)) {\n              innerPromise.on('progress', emitter.emit.bind(emitter, 'progress'));\n              innerPromise.on('upload-progress', emitter.emit.bind(emitter, 'upload-progress'));\n              innerPromise.on('download-progress', emitter.emit.bind(emitter, 'download-progress'));\n            }\n\n            return innerPromise\n              .then((res) => {\n                cb(null, res);\n              })\n              .catch((reason) => {\n                if (!reason) {\n                  reason = new Error('retryable method failed without providing an error object');\n                }\n                cb(reason);\n              });\n          },\n          (err, res) => {\n            if (err) {\n              return reject(err);\n            }\n\n            return resolve(res);\n          }\n        );\n\n        call.setStrategy(new backoff.ExponentialStrategy(strategyOptions));\n        if (options.maxAttempts) {\n          call.failAfter(options.maxAttempts - 1);\n        }\n\n        call.start();\n      });\n\n      promise.on = function on(key, callback) {\n        emitter.on(key, callback);\n\n        return promise;\n      };\n\n      return promise;\n    });\n\n    // This *should* make decorators compatible with AmpersandState class\n    // definitions\n    if (typeof target === 'object' && !target.prototype) {\n      target[prop] = descriptor.value;\n    }\n\n    return descriptor;\n  }\n}\n"]}