{"version":3,"sources":["events.js"],"names":["proxyEvents","emitter","proxy","forEach","key","transferEvents","events","source","drain","event","on","args","emit","target","method","trigger","Error","rest"],"mappings":";;;;;;;;;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,WAAT,CAAqBC,OAArB,EAA8BC,KAA9B,EAAqC;AAC1C,GACE,IADF,EAEE,MAFF,EAGEC,OAHF,CAGU,UAACC,GAAD,EAAS;AACjBF,IAAAA,KAAK,CAACE,GAAD,CAAL,GAAa,YAAa;AACxBH,MAAAA,OAAO,CAACG,GAAD,CAAP,OAAAH,OAAO,YAAP;AAEA,aAAOC,KAAP;AACD,KAJD;AAKD,GATD;AAWA,SAAOD,OAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASI,cAAT,CAAwBC,MAAxB,EAAgCC,MAAhC,EAAwCC,KAAxC,EAA+C;AACpDF,EAAAA,MAAM,GAAG,uBAAQA,MAAR,IAAkBA,MAAlB,GAA2B,CAACA,MAAD,CAApC;AACAA,EAAAA,MAAM,CAACH,OAAP,CAAe,UAACM,KAAD,EAAW;AACxB,QAAIF,MAAM,CAACG,EAAX,EAAe;AACbH,MAAAA,MAAM,CAACG,EAAP,CAAUD,KAAV,EAAiB;AAAA,0CAAIE,IAAJ;AAAIA,UAAAA,IAAJ;AAAA;;AAAA,eAAaC,IAAI,MAAJ,UAAKJ,KAAL,EAAYC,KAAZ,SAAsBE,IAAtB,EAAb;AAAA,OAAjB;AACD;AACF,GAJD;AAKD;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASC,IAAT,CAAcC,MAAd,EAA+B;AAC7B,MAAMC,MAAM,GAAGD,MAAM,CAACE,OAAP,IAAkBF,MAAM,CAACD,IAAxC;AAEA;;AACA,MAAI,CAACE,MAAL,EAAa;AACX,UAAM,IAAIE,KAAJ,CAAU,iCAAV,CAAN;AACD;;AAN4B,qCAANC,IAAM;AAANA,IAAAA,IAAM;AAAA;;AAQ7B,SAAO,oBAAcH,MAAd,EAAsBD,MAAtB,EAA8BI,IAA9B,CAAP;AACD","sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {isArray} from 'lodash';\n\n/**\n * Proxies the event binding methods of emitter onto proxy\n * @param {EventEmitter|EventEmitterProxy} emitter\n * @param {mixed} proxy (probably a promise)\n * @returns {EventEmitter} Returns the source emitter to ease use in promise chains\n */\nexport function proxyEvents(emitter, proxy) {\n  [\n    'on',\n    'once'\n  ].forEach((key) => {\n    proxy[key] = (...args) => {\n      emitter[key](...args);\n\n      return proxy;\n    };\n  });\n\n  return emitter;\n}\n\n/**\n * Given a list of events, fires them on drain when they're emitted from source\n * @param {Array|string} events\n * @param {EventEmitter} source\n * @param {EventEmitter} drain\n * @returns {undefined}\n */\nexport function transferEvents(events, source, drain) {\n  events = isArray(events) ? events : [events];\n  events.forEach((event) => {\n    if (source.on) {\n      source.on(event, (...args) => emit(drain, event, ...args));\n    }\n  });\n}\n\n/**\n * Emits an event\n * @param {EventEmitter} target The EventEmitter from which to emit an event\n * @returns {mixed}\n */\nfunction emit(target, ...rest) {\n  const method = target.trigger || target.emit;\n\n  /* istanbul ignore if */\n  if (!method) {\n    throw new Error('count not determine emit method');\n  }\n\n  return Reflect.apply(method, target, rest);\n}\n"]}