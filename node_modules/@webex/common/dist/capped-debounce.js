"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = debounce;

var _apply = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/apply"));

/*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */

/**
 * Behaves like debounce, but additionally executes after a number of calls are
 * attempted, rather than just time
 * @param {Function} fn
 * @param {Number} wait
 * @param {Object} options
 * @returns {Function}
 */
function debounce(fn, wait, options) {
  /* eslint no-invalid-this: [0] */
  if (!fn) {
    throw new Error('`fn` must be a function');
  }

  if (!wait) {
    throw new Error('`wait` is required');
  }

  options = options || {};

  if (!options.maxWait) {
    throw new Error('`options.maxWait` is required');
  }

  if (!options.maxCalls) {
    throw new Error('`options.maxCalls` is required');
  }

  var _options = options,
      maxCalls = _options.maxCalls,
      maxWait = _options.maxWait;
  var count = 0;
  var maxWaitTimer, waitTimer;
  return function wrapper() {
    count += 1;
    clearTimeout(waitTimer);
    waitTimer = setTimeout(function () {
      return exec();
    }, wait);

    if (!maxWaitTimer) {
      maxWaitTimer = setTimeout(function () {
        return exec();
      }, maxWait);
    }

    if (count >= maxCalls) {
      (0, _apply.default)(exec, this, []);
    }
  };
  /**
   * @private
   * @returns {undefined}
   */

  function exec() {
    clearTimeout(waitTimer);
    waitTimer = null;
    clearTimeout(maxWaitTimer);
    maxWaitTimer = null;
    count = 0;
    (0, _apply.default)(fn, this, []);
  }
}
//# sourceMappingURL=capped-debounce.js.map
