"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = retry;

var _assign = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/assign"));

var _apply = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/apply"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/typeof"));

var _wrap2 = _interopRequireDefault(require("lodash/wrap"));

var _isFunction2 = _interopRequireDefault(require("lodash/isFunction"));

var _defaults2 = _interopRequireDefault(require("lodash/defaults"));

var _events = require("events");

var _backoff = _interopRequireDefault(require("backoff"));

/*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */

/* eslint max-nested-callbacks: [0] */

/**
 * Makes a promise-returning method retryable according to the specified backoff
 * pattern
 * @param {Object} options
 * @param {boolean} options.backoff
 * @param {number} options.delay
 * @param {number} options.initialDelay
 * @param {number} options.maxAttempts
 * @param {number} options.maxDelay
 *
 * @returns {Function}
 */
function retry() {
  for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
    params[_key] = arguments[_key];
  }

  var options = params[0] || {};
  options = (0, _assign.default)({}, options);
  (0, _defaults2.default)(options, {
    backoff: true,
    delay: 1,
    maxAttempts: 3
  });
  var strategyOptions;

  if (options.backoff) {
    strategyOptions = {
      initialDelay: options.delay,
      maxDelay: options.maxDelay
    };
  } else {
    strategyOptions = {
      initialDelay: 1,
      maxDelay: 1
    };
  }

  if (params.length === 3) {
    return (0, _apply.default)(retryDecorator, null, params);
  }

  return retryDecorator;
  /**
   * @param {Object} target
   * @param {string} prop
   * @param {Object} descriptor
   * @private
   * @returns {Object}
   */

  function retryDecorator(target, prop, descriptor) {
    descriptor.value = (0, _wrap2.default)(descriptor.value, function retryExecutor(fn) {
      var _this = this;

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      var emitter = new _events.EventEmitter();
      var promise = new _promise.default(function (resolve, reject) {
        // backoff.call is not Function.prototype.call; it's an unfortunate naming
        // collision.

        /* eslint prefer-reflect: [0] */
        var call = _backoff.default.call(function (cb) {
          /* eslint no-invalid-this: [0] */
          var innerPromise = (0, _apply.default)(fn, _this, args);

          if ((0, _isFunction2.default)(innerPromise.on)) {
            innerPromise.on('progress', emitter.emit.bind(emitter, 'progress'));
            innerPromise.on('upload-progress', emitter.emit.bind(emitter, 'upload-progress'));
            innerPromise.on('download-progress', emitter.emit.bind(emitter, 'download-progress'));
          }

          return innerPromise.then(function (res) {
            cb(null, res);
          }).catch(function (reason) {
            if (!reason) {
              reason = new Error('retryable method failed without providing an error object');
            }

            cb(reason);
          });
        }, function (err, res) {
          if (err) {
            return reject(err);
          }

          return resolve(res);
        });

        call.setStrategy(new _backoff.default.ExponentialStrategy(strategyOptions));

        if (options.maxAttempts) {
          call.failAfter(options.maxAttempts - 1);
        }

        call.start();
      });

      promise.on = function on(key, callback) {
        emitter.on(key, callback);
        return promise;
      };

      return promise;
    }); // This *should* make decorators compatible with AmpersandState class
    // definitions

    if ((0, _typeof2.default)(target) === 'object' && !target.prototype) {
      target[prop] = descriptor.value;
    }

    return descriptor;
  }
}
//# sourceMappingURL=retry.js.map
