"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _apply = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/apply"));

var _partition2 = _interopRequireDefault(require("lodash/partition"));

require("@webex/internal-plugin-device");

var _webexCore = require("@webex/webex-core");

/*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */
var Feature = _webexCore.WebexPlugin.extend({
  namespace: 'Feature',

  /**
   * Returns the value of the requested feature toggle.
   * @param {string} keyType <developer|user|entitlement>
   * @param {string} key
   * @param {Object} options
   * @param {boolean} options.full to get full feature record including metadata.
   * @returns {string|boolean|number|FeatureModel|null}
   */
  getFeature: function getFeature(keyType, key, options) {
    if (keyType !== 'developer' && keyType !== 'user' && keyType !== 'entitlement') {
      return _promise.default.reject(new Error('Invalid feature keyType provided. Only `developer`, `user`, and `entitlement` feature toggles are permitted.'));
    }

    options = options || {};
    var feature = this.webex.internal.device.features[keyType].get(key);

    if (!feature) {
      return _promise.default.resolve(null);
    }

    if (options.full) {
      return _promise.default.resolve(feature.serialize());
    }

    return _promise.default.resolve(feature.value);
  },

  /**
   * Handles a feature toggle update from the server.
   * @param {Object} envelope
   * @returns {undefined}
   */
  handleFeatureUpdate: function handleFeatureUpdate(envelope) {
    if (envelope && envelope.data) {
      var feature = envelope.data.featureToggle;
      var keyType = feature.type.toLowerCase();

      if (keyType === 'user' || keyType === 'developer') {
        this.webex.internal.device.features[keyType].add([feature], {
          merge: true
        });
      }
    }
  },

  /**
   * Register to listen for incoming feature events
   * @instance
   * @returns {undefined}
   */
  listen: function listen() {
    this.listenTo(this.webex.internal.mercury, 'event:featureToggle_update', this.handleFeatureUpdate);
  },

  /**
   * Issues request to server to set a value for a feature toggle.
   * @param {string} keyType <developer|user>
   * @param {string} key
   * @param {string} value
   * @returns {Promise} Refreshes the local device and resolves with the features endpoint's response.
   */
  setFeature: function setFeature(keyType, key, value) {
    var _this = this;

    // Limit only to developer feature toggles for now.
    if (keyType !== 'developer' && keyType !== 'user') {
      return _promise.default.reject(new Error('Only `developer` and `user` feature toggles can be set.'));
    }

    return this.request({
      method: 'POST',
      api: 'feature',
      resource: "features/users/".concat(this.webex.internal.device.userId, "/").concat(keyType),
      body: {
        key: key,
        mutable: true,
        val: value
      }
    }).then(function (res) {
      return _this.webex.internal.device.features[keyType].add(res.body, {
        merge: true
      });
    });
  },

  /**
   * Issues request to server to set a value for a feature toggle.
   * @param {array} featureList
   * @returns {Promise} Refreshes the local device and resolves with the features endpoint`s response.
   */
  setBundledFeatures: function setBundledFeatures(featureList) {
    var _this2 = this;

    featureList.forEach(function (item) {
      item.mutable = item.mutable || 'true';

      if (item.type !== 'USER' && item.type !== 'DEV') {
        item.type = 'USER';
      }
    });
    return this.request({
      method: 'POST',
      api: 'feature',
      resource: "features/users/".concat(this.webex.internal.device.userId, "/toggles"),
      body: featureList
    }).then(function (res) {
      var partitionedToggles = (0, _partition2.default)(res.body.featureToggles, {
        type: 'USER'
      });

      _this2.webex.internal.device.features.user.add(partitionedToggles[0], {
        merge: true
      });

      _this2.webex.internal.device.features.developer.add(partitionedToggles[1], {
        merge: true
      });
    });
  },
  initialize: function initialize() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (0, _apply.default)(_webexCore.WebexPlugin.prototype.initialize, this, args);
    this.listenToAndRun(this.webex, 'change:internal.device.features.developer', this.trigger.bind(this, 'change:developer'));
    this.listenToAndRun(this.webex, 'change:internal.device.features.entitlement', this.trigger.bind(this, 'change:entitlement'));
    this.listenToAndRun(this.webex, 'change:internal.device.features.user', this.trigger.bind(this, 'change:user'));
  },
  version: "1.125.6"
});

var _default = Feature;
exports.default = _default;
//# sourceMappingURL=feature.js.map
