"use strict";

var _Reflect$construct = require("@babel/runtime-corejs2/core-js/reflect/construct");

var _Array$from = require("@babel/runtime-corejs2/core-js/array/from");

var _Symbol = require("@babel/runtime-corejs2/core-js/symbol");

var _Symbol$iterator = require("@babel/runtime-corejs2/core-js/symbol/iterator");

var _Array$isArray = require("@babel/runtime-corejs2/core-js/array/is-array");

var _getIterator = require("@babel/runtime-corejs2/core-js/get-iterator");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = exports.KMSError = void 0;

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/wrapNativeSuper"));

var _isArray2 = _interopRequireDefault(require("lodash/isArray"));

var _url = require("url");

var _validUrl = require("valid-url");

var _asn1js = require("asn1js");

var _pkijs = require("pkijs");

var _nodeJose = _interopRequireDefault(require("node-jose"));

var _isomorphicWebcrypto = _interopRequireDefault(require("isomorphic-webcrypto"));

var _safeBuffer = require("safe-buffer");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof _Symbol === "undefined" || o[_Symbol$iterator] == null) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = _getIterator(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return _Array$from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

(0, _pkijs.setEngine)('newEngine', _isomorphicWebcrypto.default, new _pkijs.CryptoEngine({
  name: '',
  crypto: _isomorphicWebcrypto.default,
  subtle: _isomorphicWebcrypto.default.subtle
}));
var VALID_KTY = 'RSA';
var VALID_KID_PROTOCOL = 'kms:';
var X509_COMMON_NAME_KEY = '2.5.4.3';
var X509_SUBJECT_ALT_NAME_KEY = '2.5.29.17';
/**
 * Customize Error so the SDK knows to quit retrying and notify
 * the user
 */

var KMSError = /*#__PURE__*/function (_Error) {
  (0, _inherits2.default)(KMSError, _Error);

  var _super = _createSuper(KMSError);

  /**
   * add kmsError field to notify
   * @param {string} message
   */
  function KMSError(message) {
    var _this;

    (0, _classCallCheck2.default)(this, KMSError);
    _this = _super.call(this, message);
    _this.kmsError = true;
    return _this;
  }

  return KMSError;
}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Error));

exports.KMSError = KMSError;

var throwError = function throwError(err) {
  throw new KMSError("INVALID KMS: ".concat(err));
};
/**
 * Converts the PEM string to a pkijs certificate object
 * @param {string} pem PEM representation of a certificate
 * @returns {Certificate} pkijs object of the certificate
 */


var decodeCert = function decodeCert(pem) {
  if (typeof pem !== 'string') {
    throwError('certificate needs to be a string');
  }

  var der = _safeBuffer.Buffer.from(pem, 'base64');

  var ber = new Uint8Array(der).buffer;
  var asn1 = (0, _asn1js.fromBER)(ber);
  return new _pkijs.Certificate({
    schema: asn1.result
  });
};
/**
 * Validate the 'kty' property of the KMS credentials
 * @param {Object} JWT KMS credentials
 * @param {string} JWT.kty type of certificate
 * @throws {KMSError} if kty is not a valid type
 * @returns {void}
 */


var validateKtyHeader = function validateKtyHeader(_ref) {
  var kty = _ref.kty;

  if (kty !== VALID_KTY) {
    throwError("'kty' header must be '".concat(VALID_KTY, "'"));
  }
};

var validateKidHeader = function validateKidHeader(_ref2) {
  var kid = _ref2.kid;

  if (!(0, _validUrl.isUri)(kid)) {
    throwError('\'kid\' is not a valid URI');
  }

  if ((0, _url.parse)(kid).protocol !== VALID_KID_PROTOCOL) {
    throwError("'kid' protocol must be '".concat(VALID_KID_PROTOCOL, "'"));
  }
};
/**
 * Checks the first certificate matches the 'kid' in the JWT.
 * It first checks the Subject Alternative Name then it checks
 * the Common Name
 * @param {Certificate} certificate represents the KMS
 * @param {Object} JWT KMS credentials
 * @param {string} JWT.kid the uri of the KMS
 * @throws {KMSError} if unable to validate certificate against KMS credentials
 * @returns {void}
 */


var validateCommonName = function validateCommonName(_ref3, _ref4) {
  var _ref5 = (0, _slicedToArray2.default)(_ref3, 1),
      certificate = _ref5[0];

  var kid = _ref4.kid;
  var kidHostname = (0, _url.parse)(kid).hostname;
  var validationSuccessful = false;

  if (certificate.extensions) {
    // Subject Alt Names are in here
    var _iterator = _createForOfIteratorHelper(certificate.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var extension = _step.value;

        if (extension.extnID === X509_SUBJECT_ALT_NAME_KEY) {
          var altNames = extension.parsedValue.altNames;

          var _iterator2 = _createForOfIteratorHelper(altNames),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var entry = _step2.value;
              var san = entry.value;
              validationSuccessful = san === kidHostname;

              if (validationSuccessful) {
                break;
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          if (validationSuccessful) {
            break;
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  if (!validationSuccessful) {
    // Didn't match kid in the Subject Alt Names, checking the Common Name
    var subjectAttributes = certificate.subject.typesAndValues;

    var _iterator3 = _createForOfIteratorHelper(subjectAttributes),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var attribute = _step3.value;

        if (attribute.type === X509_COMMON_NAME_KEY) {
          var commonName = attribute.value.valueBlock.value;
          validationSuccessful = commonName === kidHostname;

          if (validationSuccessful) {
            break;
          }
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  }

  if (!validationSuccessful) {
    throwError('hostname of the 1st certificate does not match \'kid\'');
  }
};
/**
 * Validate the first KMS certificate against the information
 * provided in the JWT
 * @param {Certificate} certificate first certificate the identifies the KMS
 * @param {Object} JWT credentials of the KMS
 * @param {string} JWT.e Public exponent of the first certificate
 * @param {string} KWT.n Modulus of the first certificate
 * @throws {KMSError} if e or n doesn't match the first certificate
 * @returns {void}
 */


var validatePublicCertificate = function validatePublicCertificate(_ref6, _ref7) {
  var _ref8 = (0, _slicedToArray2.default)(_ref6, 1),
      certificate = _ref8[0];

  var publicExponent = _ref7.e,
      modulus = _ref7.n;
  var encode = _nodeJose.default.util.base64url.encode;
  var publicKey = certificate.subjectPublicKeyInfo.subjectPublicKey;
  var asn1PublicCert = (0, _asn1js.fromBER)(publicKey.valueBlock.valueHex);
  var publicCert = new _pkijs.RSAPublicKey({
    schema: asn1PublicCert.result
  });
  var publicExponentHex = publicCert.publicExponent.valueBlock.valueHex;
  var modulusHex = publicCert.modulus.valueBlock.valueHex;

  if (publicExponent !== encode(publicExponentHex)) {
    throwError('Public exponent is invalid');
  }

  if (modulus !== encode(modulusHex)) {
    throwError('Modulus is invalid');
  }
};
/**
 * Validates the list of certificates against the CAs provided
 * @param {certificate[]} certificates list of certificates provided
 *   by the KMS to certify itself
 * @param {string[]} [caroots=[]] list of Certificate Authorities used to
 *   validate the KMS's certificates
 * @returns {Promise} rejects if unable to validate the certificates
 */


var validateCertificatesSignature = function validateCertificatesSignature(certificates) {
  var caroots = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var certificateEngine = new _pkijs.CertificateChainValidationEngine({
    trustedCerts: caroots.map(decodeCert),
    certs: certificates
  });
  return certificateEngine.verify().then(function (_ref9) {
    var result = _ref9.result,
        resultCode = _ref9.resultCode,
        resultMessage = _ref9.resultMessage;

    if (!result) {
      throwError("Certificate Validation failed [".concat(resultCode, "]: ").concat(resultMessage));
    }
  });
};
/**
 * Validates the information provided by the KMS. This is a curried function.
 * The first function takes the caroots param and returns a second function.
 * The second function takes the credentials of the KMS and validates it
 * @param {string[]} caroots PEM encoded certificates that will be used
 *   as Certificate Authorities
 * @param {Object} jwt Object containing the fields necessary to
 *   validate the KMS
 * @returns {Promise} when resolved will return the jwt
 */


var validateKMS = function validateKMS(caroots) {
  return function () {
    var jwt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return _promise.default.resolve().then(function () {
      validateKtyHeader(jwt);
      validateKidHeader(jwt);

      if (!((0, _isArray2.default)(jwt.x5c) && jwt.x5c.length > 0)) {
        throwError('JWK does not contain a list of certificates');
      }

      var certificates = jwt.x5c.map(decodeCert);
      validateCommonName(certificates, jwt);
      validatePublicCertificate(certificates, jwt); // Skip validating signatures if no CA roots were provided

      var promise = caroots ? validateCertificatesSignature(certificates, caroots) : _promise.default.resolve();
      return promise.then(function () {
        return jwt;
      });
    });
  };
};

var _default = validateKMS;
exports.default = _default;
//# sourceMappingURL=kms-certificate-validation.js.map
