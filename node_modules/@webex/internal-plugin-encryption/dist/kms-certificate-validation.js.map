{"version":3,"sources":["kms-certificate-validation.js"],"names":["crypto","CryptoEngine","name","subtle","VALID_KTY","VALID_KID_PROTOCOL","X509_COMMON_NAME_KEY","X509_SUBJECT_ALT_NAME_KEY","KMSError","message","kmsError","Error","throwError","err","decodeCert","pem","der","Buffer","from","ber","Uint8Array","buffer","asn1","Certificate","schema","result","validateKtyHeader","kty","validateKidHeader","kid","protocol","validateCommonName","certificate","kidHostname","hostname","validationSuccessful","extensions","extension","extnID","altNames","parsedValue","entry","san","value","subjectAttributes","subject","typesAndValues","attribute","type","commonName","valueBlock","validatePublicCertificate","publicExponent","e","modulus","n","encode","jose","util","base64url","publicKey","subjectPublicKeyInfo","subjectPublicKey","asn1PublicCert","valueHex","publicCert","RSAPublicKey","publicExponentHex","modulusHex","validateCertificatesSignature","certificates","caroots","certificateEngine","CertificateChainValidationEngine","trustedCerts","map","certs","verify","then","resultCode","resultMessage","validateKMS","jwt","resolve","x5c","length","promise"],"mappings":"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","sourcesContent":["import {parse as parseUrl} from 'url';\n\nimport {isUri} from 'valid-url';\nimport {fromBER} from 'asn1js';\nimport {\n  Certificate,\n  RSAPublicKey,\n  CertificateChainValidationEngine,\n  CryptoEngine,\n  setEngine\n} from 'pkijs';\nimport {isArray} from 'lodash';\nimport jose from 'node-jose';\nimport crypto from 'isomorphic-webcrypto';\nimport {Buffer} from 'safe-buffer';\n\nsetEngine(\n  'newEngine',\n  crypto,\n  new CryptoEngine({\n    name: '',\n    crypto,\n    subtle: crypto.subtle\n  })\n);\n\nconst VALID_KTY = 'RSA';\nconst VALID_KID_PROTOCOL = 'kms:';\n\nconst X509_COMMON_NAME_KEY = '2.5.4.3';\n\nconst X509_SUBJECT_ALT_NAME_KEY = '2.5.29.17';\n\n/**\n * Customize Error so the SDK knows to quit retrying and notify\n * the user\n */\nexport class KMSError extends Error {\n  /**\n   * add kmsError field to notify\n   * @param {string} message\n   */\n  constructor(message) {\n    super(message);\n    this.kmsError = true;\n  }\n}\n\nconst throwError = (err) => {\n  throw new KMSError(`INVALID KMS: ${err}`);\n};\n\n/**\n * Converts the PEM string to a pkijs certificate object\n * @param {string} pem PEM representation of a certificate\n * @returns {Certificate} pkijs object of the certificate\n */\nconst decodeCert = (pem) => {\n  if (typeof pem !== 'string') {\n    throwError('certificate needs to be a string');\n  }\n\n  const der = Buffer.from(pem, 'base64');\n  const ber = new Uint8Array(der).buffer;\n\n  const asn1 = fromBER(ber);\n\n  return new Certificate({schema: asn1.result});\n};\n\n/**\n * Validate the 'kty' property of the KMS credentials\n * @param {Object} JWT KMS credentials\n * @param {string} JWT.kty type of certificate\n * @throws {KMSError} if kty is not a valid type\n * @returns {void}\n */\nconst validateKtyHeader = ({kty}) => {\n  if (kty !== VALID_KTY) {\n    throwError(`'kty' header must be '${VALID_KTY}'`);\n  }\n};\n\nconst validateKidHeader = ({kid}) => {\n  if (!isUri(kid)) {\n    throwError('\\'kid\\' is not a valid URI');\n  }\n\n  if (parseUrl(kid).protocol !== VALID_KID_PROTOCOL) {\n    throwError(`'kid' protocol must be '${VALID_KID_PROTOCOL}'`);\n  }\n};\n\n/**\n * Checks the first certificate matches the 'kid' in the JWT.\n * It first checks the Subject Alternative Name then it checks\n * the Common Name\n * @param {Certificate} certificate represents the KMS\n * @param {Object} JWT KMS credentials\n * @param {string} JWT.kid the uri of the KMS\n * @throws {KMSError} if unable to validate certificate against KMS credentials\n * @returns {void}\n */\nconst validateCommonName = ([certificate], {kid}) => {\n  const kidHostname = parseUrl(kid).hostname;\n  let validationSuccessful = false;\n\n  if (certificate.extensions) {\n    // Subject Alt Names are in here\n    for (const extension of certificate.extensions) {\n      if (extension.extnID === X509_SUBJECT_ALT_NAME_KEY) {\n        const {altNames} = extension.parsedValue;\n\n        for (const entry of altNames) {\n          const san = entry.value;\n\n          validationSuccessful = san === kidHostname;\n          if (validationSuccessful) {\n            break;\n          }\n        }\n\n        if (validationSuccessful) {\n          break;\n        }\n      }\n    }\n  }\n\n  if (!validationSuccessful) {\n    // Didn't match kid in the Subject Alt Names, checking the Common Name\n    const subjectAttributes = certificate.subject.typesAndValues;\n\n    for (const attribute of subjectAttributes) {\n      if (attribute.type === X509_COMMON_NAME_KEY) {\n        const commonName = attribute.value.valueBlock.value;\n\n        validationSuccessful = commonName === kidHostname;\n        if (validationSuccessful) {\n          break;\n        }\n      }\n    }\n  }\n\n  if (!validationSuccessful) {\n    throwError('hostname of the 1st certificate does not match \\'kid\\'');\n  }\n};\n\n/**\n * Validate the first KMS certificate against the information\n * provided in the JWT\n * @param {Certificate} certificate first certificate the identifies the KMS\n * @param {Object} JWT credentials of the KMS\n * @param {string} JWT.e Public exponent of the first certificate\n * @param {string} KWT.n Modulus of the first certificate\n * @throws {KMSError} if e or n doesn't match the first certificate\n * @returns {void}\n */\nconst validatePublicCertificate =\n  ([certificate], {e: publicExponent, n: modulus}) => {\n    const {encode} = jose.util.base64url;\n\n    const publicKey = certificate.subjectPublicKeyInfo.subjectPublicKey;\n    const asn1PublicCert = fromBER(publicKey.valueBlock.valueHex);\n    const publicCert = new RSAPublicKey({schema: asn1PublicCert.result});\n    const publicExponentHex = publicCert.publicExponent.valueBlock.valueHex;\n    const modulusHex = publicCert.modulus.valueBlock.valueHex;\n\n    if (publicExponent !== encode(publicExponentHex)) {\n      throwError('Public exponent is invalid');\n    }\n    if (modulus !== encode(modulusHex)) {\n      throwError('Modulus is invalid');\n    }\n  };\n\n/**\n * Validates the list of certificates against the CAs provided\n * @param {certificate[]} certificates list of certificates provided\n *   by the KMS to certify itself\n * @param {string[]} [caroots=[]] list of Certificate Authorities used to\n *   validate the KMS's certificates\n * @returns {Promise} rejects if unable to validate the certificates\n */\nconst validateCertificatesSignature = (certificates, caroots = []) => {\n  const certificateEngine = new CertificateChainValidationEngine({\n    trustedCerts: caroots.map(decodeCert),\n    certs: certificates\n  });\n\n  return certificateEngine.verify()\n    .then(({result, resultCode, resultMessage}) => {\n      if (!result) {\n        throwError(\n          `Certificate Validation failed [${resultCode}]: ${resultMessage}`\n        );\n      }\n    });\n};\n\n/**\n * Validates the information provided by the KMS. This is a curried function.\n * The first function takes the caroots param and returns a second function.\n * The second function takes the credentials of the KMS and validates it\n * @param {string[]} caroots PEM encoded certificates that will be used\n *   as Certificate Authorities\n * @param {Object} jwt Object containing the fields necessary to\n *   validate the KMS\n * @returns {Promise} when resolved will return the jwt\n */\nconst validateKMS = (caroots) => (jwt = {}) => Promise.resolve()\n  .then(() => {\n    validateKtyHeader(jwt);\n    validateKidHeader(jwt);\n\n    if (!(isArray(jwt.x5c) && jwt.x5c.length > 0)) {\n      throwError('JWK does not contain a list of certificates');\n    }\n    const certificates = jwt.x5c.map(decodeCert);\n\n    validateCommonName(certificates, jwt);\n    validatePublicCertificate(certificates, jwt);\n\n    // Skip validating signatures if no CA roots were provided\n    const promise = caroots ?\n      validateCertificatesSignature(certificates, caroots) : Promise.resolve();\n\n    return promise\n      .then(() => jwt);\n  });\n\nexport default validateKMS;\n"]}