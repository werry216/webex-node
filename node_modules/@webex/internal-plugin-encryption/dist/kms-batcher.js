"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = exports.TIMEOUT_SYMBOL = void 0;

var _symbol = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/symbol"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _commonTimers = require("@webex/common-timers");

var _webexCore = require("@webex/webex-core");

var _kmsErrors = require("./kms-errors");

/*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */
var TIMEOUT_SYMBOL = (0, _symbol.default)('TIMEOUT_SYMBOL');
/**
 * @class
 */

exports.TIMEOUT_SYMBOL = TIMEOUT_SYMBOL;

var KmsBatcher = _webexCore.Batcher.extend({
  namespace: 'Encryption',

  /**
   * Accepts a kmsMessage event and passes its contents to acceptItem
   * @param {Object} event
   * @returns {Promise}
   */
  processKmsMessageEvent: function processKmsMessageEvent(event) {
    var _this = this;

    this.logger.info('kms-batcher: received kms message');
    return _promise.default.all(event.encryption.kmsMessages.map(function (kmsMessage) {
      return new _promise.default(function (resolve) {
        /* istanbul ignore else */
        if (process.env.NODE_ENV !== 'production') {
          _this.logger.info('kms-batcher:', kmsMessage.body);
        }

        resolve(_this.acceptItem(kmsMessage));
      });
    }));
  },

  /**
   * Attaches a timeout to the given KMS message
   * @param {Object} item
   * @returns {Promise<Object>}
   */
  prepareItem: function prepareItem(item) {
    var _this2 = this;

    return this.getDeferredForRequest(item).then(function (defer) {
      var timeout = item[TIMEOUT_SYMBOL];
      /* istanbul ignore if */

      if (!timeout) {
        throw new Error('timeout is required');
      }

      var timer = (0, _commonTimers.safeSetTimeout)(function () {
        _this2.logger.warn("kms: request timed out; request id: ".concat(item.requestId, "; timeout: ").concat(timeout));

        _this2.handleItemFailure(item, new _kmsErrors.KmsTimeoutError({
          timeout: timeout,
          request: item
        }));
      }, timeout); // Reminder: reassign `promise` is not a viable means of inserting into
      // the Promise chain

      defer.promise.then(function () {
        return clearTimeout(timer);
      });
      defer.promise.catch(function () {
        return clearTimeout(timer);
      });
      return item;
    });
  },

  /**
   * Attaches the final bits of cluster info to the payload
   * @param {Array} queue
   * @returns {Promise<Array>}
   */
  prepareRequest: function prepareRequest(queue) {
    return this.webex.internal.encryption.kms._getKMSCluster().then(function (cluster) {
      return {
        destination: cluster,
        kmsMessages: queue.map(function (req) {
          return req.wrapped;
        })
      };
    });
  },

  /**
   * @param {Object} payload
   * @returns {Promise<HttpResponseObject>}
   */
  submitHttpRequest: function submitHttpRequest(payload) {
    this.logger.info('kms: batched-request-length', payload.kmsMessages.length);
    return this.webex.request({
      method: 'POST',
      service: 'encryption',
      resource: '/kms/messages',
      body: payload
    });
  },

  /**
   * Does nothing; the http response doesn't carry our response data
   * @returns {Promise}
   */
  handleHttpSuccess: function handleHttpSuccess() {
    return _promise.default.resolve();
  },

  /**
   * @param {Object} item
   * @returns {Promise<boolean>}
   */
  didItemFail: function didItemFail(item) {
    return _promise.default.resolve(item.status >= 400);
  },

  /**
   * @param {Object} item
   * @returns {Promise}
   */
  handleItemSuccess: function handleItemSuccess(item) {
    return this.getDeferredForResponse(item).then(function (defer) {
      defer.resolve(item.body);
    });
  },

  /**
   * @param {Object} item
   * @param {KmsError} [reason]
   * @returns {Promise}
   */
  handleItemFailure: function handleItemFailure(item, reason) {
    return this.getDeferredForResponse(item).then(function (defer) {
      defer.reject(reason || new _kmsErrors.KmsError(item.body));
    });
  },

  /**
   * @param {Object} item
   * @returns {Promise}
   */
  fingerprintRequest: function fingerprintRequest(item) {
    return _promise.default.resolve(item.requestId);
  },

  /**
   * @param {Object} item
   * @returns {Promise}
   */
  fingerprintResponse: function fingerprintResponse(item) {
    return _promise.default.resolve(item.requestId);
  }
});

var _default = KmsBatcher;
exports.default = _default;
//# sourceMappingURL=kms-batcher.js.map
