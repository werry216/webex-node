"use strict";

var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");

var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");

var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");

var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");

var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _events = require("events");

var _url = _interopRequireDefault(require("url"));

var _webexCore = require("@webex/webex-core");

var _common = require("@webex/common");

var _nodeJose = _interopRequireDefault(require("node-jose"));

var _nodeScr = _interopRequireDefault(require("node-scr"));

var _ensureBuffer = _interopRequireDefault(require("./ensure-buffer"));

var _kms = _interopRequireDefault(require("./kms"));

function ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }

var Encryption = _webexCore.WebexPlugin.extend({
  children: {
    kms: _kms.default
  },
  namespace: 'Encryption',
  processKmsMessageEvent: function processKmsMessageEvent(event) {
    return this.kms.processKmsMessageEvent(event);
  },
  decryptBinary: function decryptBinary(scr, buffer) {
    return (0, _ensureBuffer.default)(buffer).then(function (b) {
      /* istanbul ignore if */
      if (buffer.length === 0 || buffer.byteLength === 0) {
        return _promise.default.reject(new Error('Attempted to decrypt zero-length buffer'));
      }

      return scr.decrypt(b);
    });
  },

  /**
   * Decrypt a SCR (Secure Content Resource) using the supplied key uri.
   *
   * @param {string} key - The uri of a key stored in KMS
   * @param {Object} cipherScr - An encrypted SCR
   * @param {Object} options
   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role
   * @returns {Object} Decrypted SCR
   */
  decryptScr: function decryptScr(key, cipherScr, options) {
    return this.getKey(key, options).then(function (k) {
      return _nodeScr.default.fromJWE(k.jwk, cipherScr);
    });
  },

  /**
   * Decrypt text using the supplied key uri.
   *
   * @param {string} key - The uri of a key stored in KMS
   * @param {string} ciphertext - Encrypted text
   * @param {Object} options
   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role
   * @returns {string} Decrypted plaintext
   */
  decryptText: function decryptText(key, ciphertext, options) {
    return this.getKey(key, options).then(function (k) {
      return _nodeJose.default.JWE.createDecrypt(k.jwk).decrypt(ciphertext).then(function (result) {
        return result.plaintext.toString();
      });
    });
  },

  /**
   * Validate and initiate a Download request for requested file
   *
   * @param {Object} scr - Plaintext
   * @param {Object} options - optional paramaters to download a file
   * @returns {promise}
   */
  download: function download(scr, options) {
    var _this = this;

    /* istanbul ignore if */
    if (!scr.loc) {
      return _promise.default.reject(new Error('`scr.loc` is required'));
    }

    var shunt = new _events.EventEmitter();

    var promise = this._fetchDownloadUrl(scr, options).then(function (uri) {
      var options = {
        method: 'GET',
        uri: uri,
        responseType: 'buffer'
      };

      var ret = _this.request(options);

      (0, _common.transferEvents)('progress', options.download, shunt);
      return ret;
    }).then(function (res) {
      return _this.decryptBinary(scr, res.body);
    });

    (0, _common.proxyEvents)(shunt, promise);
    return promise;
  },

  /**
   * Fetch Download URL for the requested file
   *
   * @param {Object} scr - Plaintext
   * @param {Object} options - optional paramaters to download a file
   * @returns {promise} url of the downloadable file
   */
  _fetchDownloadUrl: function _fetchDownloadUrl(scr, options) {
    var _this2 = this;

    this.logger.info('encryption: retrieving download url for encrypted file');

    if (process.env.NODE_ENV !== 'production' && scr.loc.includes('localhost')) {
      this.logger.info('encryption: bypassing webex files because this looks to be a test file on localhost');
      return _promise.default.resolve(scr.loc);
    }

    var inputBody = {
      endpoints: [scr.loc]
    };

    var endpointUrl = _url.default.parse(scr.loc); // hardcode the url to use 'https' and the file service '/v1/download/endpoints' api


    endpointUrl.protocol = 'https';
    endpointUrl.pathname = '/v1/download/endpoints';
    return this.request({
      method: 'POST',
      uri: _url.default.format(endpointUrl),
      body: options ? _objectSpread(_objectSpread({}, inputBody), {}, {
        allow: options.params.allow
      }) : inputBody
    }).then(function (res) {
      var url = res.body.endpoints[scr.loc];

      if (!url) {
        _this2.logger.warn('encryption: could not determine download url for `scr.loc`; attempting to download `scr.loc` directly');

        return scr.loc;
      }

      _this2.logger.info('encryption: retrieved download url for encrypted file');

      return url;
    });
  },
  encryptBinary: function encryptBinary(file) {
    return (0, _ensureBuffer.default)(file).then(function (buffer) {
      return _nodeScr.default.create().then(function (scr) {
        return scr.encrypt(buffer).then(_ensureBuffer.default) // eslint-disable-next-line max-nested-callbacks
        .then(function (cdata) {
          return {
            scr: scr,
            cdata: cdata
          };
        });
      });
    });
  },

  /**
   * Encrypt a SCR (Secure Content Resource) using the supplied key uri.
   *
   * @param {string} key - The uri of a key stored in KMS
   * @param {Object} scr - Plaintext
   * @param {Object} options
   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role
   * @returns {string} Encrypted SCR
   */
  encryptScr: function encryptScr(key, scr, options) {
    /* istanbul ignore if */
    if (!scr.loc) {
      return _promise.default.reject(new Error('Cannot encrypt `scr` without first setting `loc`'));
    }

    return this.getKey(key, options).then(function (k) {
      return scr.toJWE(k.jwk);
    });
  },

  /**
   * Encrypt plaintext using the supplied key uri.
   *
   * @param {string} key - The uri of a key stored in KMS
   * @param {string} plaintext
   * @param {Object} options
   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role
   * @returns {string} Encrypted text
   */
  encryptText: function encryptText(key, plaintext, options) {
    var _this3 = this;

    return this.getKey(key, options).then(function (k) {
      return _nodeJose.default.JWE.createEncrypt(_this3.config.joseOptions, {
        key: k.jwk,
        header: {
          alg: 'dir'
        },
        reference: null
      }).final(plaintext, 'utf8');
    });
  },

  /**
   * Fetch the key associated with the supplied KMS uri.
   *
   * @param {string} uri - The uri of a key stored in KMS
   * @param {Object} options
   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role
   * @returns {string} Key
   */
  getKey: function getKey(uri) {
    var _this4 = this;

    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        onBehalfOf = _ref.onBehalfOf;

    if (uri.jwk) {
      return this.kms.asKey(uri);
    }

    var storageKey = uri;

    if (onBehalfOf) {
      storageKey += "/onBehalfOf/".concat(onBehalfOf);
    }

    return this.unboundedStorage.get(storageKey).then(function (keyString) {
      return JSON.parse(keyString);
    }).then(function (keyObject) {
      return _this4.kms.asKey(keyObject);
    }).catch(function () {
      return _this4.kms.fetchKey({
        uri: uri,
        onBehalfOf: onBehalfOf
      }).then((0, _common.tap)(function (key) {
        return _this4.unboundedStorage.put(storageKey, (0, _stringify.default)(key, replacer));
      }));
    });
  },
  version: "1.125.6"
});
/**
 * JSON.stringify replacer that ensures private key data is serialized.
 * @param {string} k
 * @param {mixed} v
 * @returns {mixed}
 */


function replacer(k, v) {
  if (k === 'jwk') {
    // note: this[k] and v may be different representations of the same value
    // eslint-disable-next-line no-invalid-this
    var json = this[k].toJSON(true);
    return json;
  }

  return v;
}

var _default = Encryption;
exports.default = _default;
//# sourceMappingURL=encryption.js.map
